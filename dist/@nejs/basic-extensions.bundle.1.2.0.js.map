{
  "version": 3,
  "sources": ["../../src/index.js", "../../node_modules/@nejs/extension/dist/mjs/errors/CannotBeExtendedError.js", "../../node_modules/@nejs/extension/dist/mjs/errors/MissingOwnerValue.js", "../../node_modules/@nejs/extension/dist/mjs/patchtoggle.js", "../../node_modules/@nejs/extension/dist/mjs/patch.js", "../../node_modules/@nejs/extension/dist/mjs/extension.js", "../../src/functionextensions.js", "../../src/objectextensions.js", "../../src/reflectextensions.js", "../../src/stringextensions.js", "../../src/symbolextensions.js", "../../src/arrayextensions.js", "../../src/descriptor.js"],
  "sourcesContent": ["import { FunctionExtensions } from './functionextensions.js'\nimport { ObjectExtensions } from './objectextensions.js'\nimport { ReflectExtensions } from './reflectextensions.js'\nimport { StringExtensions } from './stringextensions.js'\nimport { SymbolExtensions } from './symbolextensions.js'\nimport { ArrayPrototypeExtensions } from './arrayextensions.js'\nimport { DescriptorExtension } from './descriptor.js'\n\nimport { Patch } from '@nejs/extension'\n\nconst Owners = [\n  Object,\n  Function,\n  Reflect,\n  String,\n  Symbol,\n\n  Array.prototype,\n]\n\nconst NetNew = [\n  DescriptorExtension,\n]\n\nexport function enableAll(owners) {\n  const list = owners || Owners || []\n\n  list.forEach(owner => {\n    Patch.enableFor(owner)\n  })\n\n  NetNew.forEach(extension => {\n    extension.apply()\n  })\n}\n\nexport function disableAll(owners) {\n  list.forEach(owner => {\n    Patch.disableFor(owner)\n  })\n\n  NetNew.forEach(extension => {\n    extension.revert()\n  })\n}\n\nexport {\n  ObjectExtensions,\n  FunctionExtensions,\n  ReflectExtensions,\n  StringExtensions,\n  SymbolExtensions,\n  ArrayPrototypeExtensions,\n}", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1];\n/**\n * Represents an error that is thrown when there is an attempt to extend a\n * restricted part of the code. This error is specifically used to signal\n * violations of extension constraints, such as tampering with certain keys\n * or properties of an object. The error message constructed will include the\n * details of the owner (the restricted part) and the key that was attempted to\n * be tampered with.\n */\nexport class CannotBeExtendedError extends Error {\n    /**\n     * Constructs a new CannotBeExtendedError instance.\n     *\n     * @param {string} owner The name or identifier of the restricted part\n     * that is disallowing extension or tampering.\n     * @param {string} key The key or property that was attempted to be\n     * modified or extended.\n     */\n    constructor(owner, key) {\n        super(`${typeOf(owner)} disallows tampering with ${key}.`);\n        Object.assign(this, { owner, key });\n    }\n    /**\n     * Custom getter for the toStringTag symbol. Overrides the default\n     * Object.prototype.toString behavior, returning the constructor's name\n     * of this error instance. Useful for debugging and logging purposes.\n     * @returns {string} The name of the constructor for this error instance.\n     */\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1];\n/**\n * Represents an error that is thrown when a property is missing from a specified\n * owner object. This error is used to indicate that a specific key or property\n * expected to be present on the owner is not found, highlighting potential issues\n * in property access or data integrity.\n */\nexport class MissingOwnerValue extends Error {\n    /**\n     * Constructs a new MissingOwnerValue instance.\n     *\n     * @param {string} owner The object or entity that is supposed to contain the\n     * property.\n     * @param {string} key The name of the property that is missing from the owner.\n     */\n    constructor(owner, key) {\n        super(`${typeOf(owner)} does not have a property named '${key}'.`);\n        Object.assign(this, { owner, key });\n    }\n    /**\n     * Custom getter for the toStringTag symbol. Overrides the default\n     * Object.prototype.toString behavior, returning the constructor's name\n     * of this error instance. Useful for debugging and logging purposes.\n     *\n     * @returns {string} The name of the constructor for this error instance.\n     */\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n", "import { Patch } from \"./patch\";\n/**\n * Early usage of the Patch and Extension classes made it clear that it was\n * cumbersome to use a Patch temporarily for a block of code and excessive\n * amounts of if/else statements were required. This simple wrapper makes that\n * process easier.\n */\nexport class PatchToggle {\n    /**\n     * Wraps an instance of a Patch. It allows low-code clean-readability to\n     * start and stop the underlying patch regardless of whether or not the\n     * patch has been already applied.\n     *\n     * @param {Patch} patch instance of `Patch` to wrap with this toggle\n     * @param {boolean} preventRevert prevents the call to `.revert()` on the\n     * supplied patch when stop() is called.\n     */\n    constructor(patch, preventRevert = false) {\n        this.started = false;\n        this.preventRevert = preventRevert;\n        this.patch = patch;\n        this.patchName = (patch.owner?.name ??\n            patch.owner?.constructor?.name ??\n            /(\\w+)]/.exec(Object.prototype.toString.call(patch.owner))[1]);\n        this.state = {\n            needsApplication: false,\n            needsReversion: false,\n        };\n    }\n    /**\n     * If the usage of the wrapped Patch hasn't been started yet, the code checks\n     * whether or not the patch has been applied by checking for signs of it in\n     * the owning object.\n     *\n     * If the patch needs to be applied, it will be applied at this time.\n     *\n     * @returns {PatchToggle} returns `this` to allow for chaining\n     */\n    start() {\n        if (!this.started) {\n            this.state.needsApplication = !this.patch.applied;\n            this.state.needsReversion = this.patch.applied;\n            this.started = true;\n            if (this.state.needsApplication) {\n                this.patch.apply();\n            }\n        }\n        return this;\n    }\n    /**\n     * Checks to see if the toggle has been started. If so, the patch is reverted\n     * if it needed to be applied previously. After stopping, the state of the instance\n     * is reverted to allow for clean subsequent calls to start.\n     *\n     * @returns {PatchToggle} returns `this` to allow further chaining\n     */\n    stop() {\n        if (this.started) {\n            if (this.preventRevert || this.patch.applied) {\n                this.patch.revert();\n            }\n            this.state.needsApplication = false;\n            this.state.needsReversion = false;\n            this.started = false;\n        }\n        return this;\n    }\n    /**\n     * When the string tag for this class instance is inspected, it will\n     * reflect the string `PatchToggle:PatchName`\n     */\n    get [Symbol.toStringTag]() {\n        return `${this.constructor.name}:${this.patchName}`;\n    }\n    /**\n     * Custom inspect function for Node.js that provides a formatted representation\n     * of the PatchToggle instance, primarily for debugging purposes.\n     *\n     * @param {number} depth The depth to which the object should be formatted.\n     * @param {object} options Formatting options.\n     * @param {function} inspect The inspection function to format the object.\n     * @returns {string} A formatted string representing the PatchEntry instance.\n     */\n    [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n        const objName = this[Symbol.toStringTag];\n        const status = `(started: ${this.started} needed: ${this.state.needsApplication})`;\n        return inspect(`${objName} ${status}`, { ...options, depth });\n    }\n}\n", "import { PatchToggle } from './patchtoggle.js';\n/**\n * The Patch class provides a mechanism to apply patches to properties or\n * methods of an object (the owner). It keeps track of the original state of\n * these properties and allows for the application and reversion of patches.\n */\nexport class Patch {\n    /**\n     * Constructs a new Patch instance.\n     *\n     * @param {object} owner The object to which patches will be applied.\n     * @param {object} patches An object containing properties or methods to\n     *                         be patched onto the owner.\n     * @param {object} [options={}] Additional options for patching behavior.\n     */\n    constructor(owner, patches, options = {}) {\n        Object.assign(this, {\n            owner,\n            options,\n            applied: false,\n        });\n        this.patchConflicts = {};\n        this.patchEntries = {};\n        this.patchesOwner = patches;\n        Reflect.ownKeys(patches).forEach(key => {\n            this.patchEntries[key] = new Patch.#PatchEntry(key, this.patchesOwner);\n            if (Reflect.has(this.owner, key)) {\n                this.patchConflicts[key] = new Patch.#PatchEntry(key, this.owner);\n            }\n        });\n        if (!Patch.patches.has(owner)) {\n            Patch.patches.set(owner, []);\n        }\n        Patch.patches.get(owner).push(this);\n    }\n    /**\n     * Retrieves the patch entries as an array of [key, patchEntry] pairs.\n     *\n     * @returns {Array} An array of [key, patchEntry] pairs.\n     */\n    get patches() {\n        return Reflect.ownKeys(this.patchEntries).map(key => {\n            return [key, this.patchEntries[key]];\n        });\n    }\n    /**\n     * Retrieves the conflict entries (existing properties on the owner that\n     * will be overridden by patches) as an array of [key, patchEntry] pairs.\n     *\n     * @returns {Array} An array of [key, patchEntry] pairs.\n     */\n    get conflicts() {\n        return Reflect.ownKeys(this.patchConflicts).map(key => {\n            return [key, this.patchConflicts[key]];\n        });\n    }\n    /**\n     * Applies all patches to the owner object. If a property with the same key\n     * already exists on the owner, it will be overridden.\n     */\n    apply() {\n        if (!this.applied) {\n            this.patches.forEach(([, patch]) => {\n                Object.defineProperty(this.owner, patch.key, patch.descriptor);\n            });\n            this.applied = true;\n        }\n    }\n    /**\n     * Creates an easy to use toggle for working with `Patch` classes\n     *\n     * @param {boolean} preventRevert true if calling stop() on the toggle does not\n     * revert the patch. false, the default, if it should.\n     * @returns {PatchToggle} an instance of PatchToggle wrapped around this instance\n     * of `Patch`\n     * @example const toggle = ObjectExtensions.createToggle().start()\n     */\n    createToggle(preventRevert = false) {\n        return new PatchToggle(this, preventRevert);\n    }\n    /**\n     * Reverts all applied patches on the owner object, restoring any overridden\n     * properties to their original state.\n     */\n    revert() {\n        if (this.applied) {\n            this.patches.forEach(([, patch]) => {\n                delete this.owner[patch.key];\n            });\n            this.conflicts.forEach(([, patch]) => {\n                Object.defineProperty(this.owner, patch.key, patch.descriptor);\n            });\n            this.applied = false;\n        }\n    }\n    /**\n     * Removes this Patch instance from being tracked amongst all the tracked Patch\n     * instances. The JavaScript virtual machine will clean this instance up once\n     * nothing else is holding a reference to it.\n     */\n    release() {\n        const patches = Patch.patches.get(this.owner);\n        patches.splice(patches.find(e => e === this), 1);\n    }\n    /**\n     * The object to which the patches are applied.\n     */\n    owner = null;\n    /**\n     * Additional options for patching behavior.\n     */\n    options = null;\n    /**\n     * A global mapping of all patches in play\n     */\n    static patches = new Map();\n    /**\n     * Applies all patches associated with a given owner object. This method\n     * is used to enable all patches for a specific owner if they have been\n     * previously registered.\n     *\n     * @param {object} owner The object whose patches are to be applied.\n     */\n    static enableFor(owner) {\n        if (Patch.patches.has(owner)) {\n            for (const patch of Patch.patches.get(owner)) {\n                patch.apply();\n            }\n        }\n    }\n    /**\n     * Reverts all patches associated with a given owner object. This method\n     * is used to disable all patches for a specific owner if they have been\n     * previously applied.\n     *\n     * @param {object} owner The object whose patches are to be reverted.\n     */\n    static disableFor(owner) {\n        if (Patch.patches.has(owner)) {\n            for (const patch of Patch.patches.get(owner)) {\n                patch.revert();\n            }\n        }\n    }\n    /**\n     * Internal class representing a single patch entry.\n     */\n    static #PatchEntry = class {\n        /**\n         * Constructs a new PatchEntry instance.\n         *\n         * @param {string} property The property key to be patched.\n         * @param {object} [owningObject=globalThis] The object from which the\n         * property descriptor is taken.\n         */\n        constructor(property, owningObject = globalThis) {\n            Object.assign(this, {\n                key: property,\n                descriptor: Object.getOwnPropertyDescriptor(owningObject, property),\n                owner: owningObject\n            });\n        }\n        /**\n         * Computes and returns the current value of the patch, based on its type\n         * (data or accessor).\n         *\n         * @returns {any} The current value of the patch.\n         */\n        get computed() {\n            if (this.isAccessor) {\n                return this.descriptor.get.bind(this.owner).call();\n            }\n            else {\n                return this.descriptor.value;\n            }\n        }\n        /**\n         * Checks if the patch is a data property (has a value).\n         *\n         * @returns {boolean} True if the patch is a data property, false otherwise.\n         */\n        get isData() {\n            return Reflect.has(this.descriptor, 'value');\n        }\n        /**\n         * Checks if the patch is an accessor property (has a getter).\n         *\n         * @returns {boolean} True if the patch is an accessor property, false otherwise.\n         */\n        get isAccessor() {\n            return Reflect.has(this.descriptor, 'get');\n        }\n        /**\n         * Checks if the patch is read-only (not configurable or not writable).\n         *\n         * @returns {boolean} True if the patch is read-only, false otherwise.\n         */\n        get isReadOnly() {\n            return ((Reflect.has(this.descriptor, 'configurable') && !this.descriptor.configurable) ||\n                (Reflect.has(this.descriptor, 'writable') && !this.descriptor.writable));\n        }\n        /**\n         * Custom getter for the toStringTag symbol. Provides the class name of\n         * the PatchEntry instance.\n         *\n         * @returns {string} The class name of the PatchEntry instance.\n         */\n        get [Symbol.toStringTag]() {\n            return this.constructor.name;\n        }\n        /**\n         * Custom inspect function for Node.js that provides a formatted representation\n         * of the PatchEntry instance, primarily for debugging purposes.\n         *\n         * @param {number} depth The depth to which the object should be formatted.\n         * @param {object} options Formatting options.\n         * @param {function} inspect The inspection function to format the object.\n         * @returns {string} A formatted string representing the PatchEntry instance.\n         */\n        [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n            return `PatchEntry<${this.key}, ${this.isData ? 'Data' : 'Accessor'}${this.isReadOnly ? ' [ReadOnly]' : ''}>`;\n        }\n    };\n}\n", "import { CannotBeExtendedError } from \"./errors/CannotBeExtendedError.js\";\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js';\nimport { Patch } from './patch.js';\n/**\n * The Extension class, inheriting from the Patch class, is specifically designed\n * for extending properties or methods of a given object. It facilitates the\n * extension process by determining the target key and value for the extension and\n * ensuring the target property is writable and configurable. If these conditions\n * are not met, the class throws a CannotBeExtendedError. This class is useful\n * in scenarios like testing, dynamic behavior adjustments, or managing complex\n * object configurations.\n */\nexport class Extension extends Patch {\n    /**\n     * Constructs a new Extension instance. This constructor initializes the extension\n     * by determining the target key and value for the extension and ensuring that\n     * the property to be extended is configurable and writable. It throws an error\n     * if these conditions are not satisfied. The constructor leverages the Patch\n     * class's functionalities to manage the extension effectively.\n     *\n     * @param {Function|string} keyClassOrFn - The key, class, or function to be\n     * used for the extension. If a function or class is provided, its name is used\n     * as the key.\n     * @param {*} value - The value or method to be used for the extension.\n     * @param {object} [owner=globalThis] - The object to which the extension will\n     * be applied.\n     * @param {object} [options={}] - Additional options for the extension behavior.\n     * @throws {CannotBeExtendedError} If the target property is not writable or\n     * configurable.\n     * @throws {MissingOwnerValue} If the `keyClassOrFn` value is null or there\n     * is an error determining the key and extension values, MissingOwnerValue is\n     * thrown.\n     */\n    constructor(keyClassOrFn, value, owner = globalThis, options = {}) {\n        let { key, extension, valid } = Extension.determineInput(keyClassOrFn);\n        extension = value || extension;\n        if (!valid) {\n            throw new MissingOwnerValue(owner, key);\n        }\n        const descriptor = Object.getOwnPropertyDescriptor(owner, key);\n        if (descriptor) {\n            if ((Reflect.has(descriptor, 'writable') && !descriptor.writable) ||\n                (Reflect.has(descriptor, 'configurable') && !descriptor.configurable)) {\n                throw new CannotBeExtendedError(owner, key);\n            }\n        }\n        super(owner, { [key]: extension }, options);\n        this.key = key;\n    }\n    /**\n     * Determines the input type for the extension. This method processes the input\n     * and identifies the key for the extension and the associated value or method.\n     * It supports inputs as either a string key or a function/class, providing\n     * flexibility in defining extensions.\n     *\n     * @param {Function|string} keyClassOrFn - The key, class, or function provided\n     * as input. If a function or class is provided, its name is used as the key.\n     * containing the determined key, the extension value/method, and a validity flag\n     * indicating whether the input is usable.\n     * @returns {{key: string|null, extension: *|null, valid: boolean}} An object\n     */\n    static determineInput(keyClassOrFn) {\n        let input = { key: null, extension: null, valid: false };\n        if (keyClassOrFn instanceof Function) {\n            input = { key: keyClassOrFn.name, extension: keyClassOrFn, valid: true };\n        }\n        else if (typeof keyClassOrFn === 'string' || keyClassOrFn instanceof String) {\n            input = { key: keyClassOrFn, extension: null, valid: true };\n        }\n        return input;\n    }\n    /**\n     * Custom inspect function for Node.js that provides a formatted representation\n     * of the Extension instance, primarily for debugging purposes.\n     *\n     * @param {number} depth The depth to which the object should be formatted.\n     * @param {object} options Formatting options.\n     * @param {function} inspect The inspection function to format the object.\n     * @returns {string} A formatted string representing the Extension instance.\n     */\n    [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n        return `Extension<${this.key}>`;\n    }\n    /**\n     * Custom getter for the toStringTag symbol. Provides the class name when the\n     * object is converted to a string, typically used for debugging and logging.\n     *\n     * @returns {string} The class name of the Extension instance.\n     */\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n", "import { Patch } from '@nejs/extension'\n\n/**\n * The `FunctionExtensions` class is a patch applied to the built-in JavaScript `Function`\n * constructor. It extends `Function` with additional utility methods for determining the\n * specific type or nature of function-like objects. These methods allow developers to\n * distinguish between classes, regular functions, async functions, and arrow functions\n * in a more intuitive and straightforward manner. This class is part of the `@nejs/extension`\n * library and enhances the capabilities of function handling and introspection in JavaScript.\n */\nexport const FunctionExtensions = new Patch(Function, {\n  /**\n   * Determines if a given value is a class. It checks if the value is an instance of\n   * `Function` and if its string representation includes the keyword 'class'. This method\n   * is useful for distinguishing classes from other function types in JavaScript.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is a class, otherwise `false`.\n   */\n  isClass(value) {\n    return value instanceof Function && String(value).includes('class');\n  },\n\n  /**\n   * Checks if a given value is a regular function. This method verifies if the value is\n   * an instance of `Function`, which includes regular functions, classes, and async\n   * functions but excludes arrow functions.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is a regular function, otherwise `false`.\n   */\n  isFunction(value) {\n    return value instanceof Function;\n  },\n\n  /**\n   * Determines if a given value is an asynchronous function. It checks if the value is an\n   * instance of `Function` and if its string representation includes the keyword 'Async'.\n   * This method is particularly useful for identifying async functions.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is an async function, otherwise `false`.\n   */\n  isAsync(value) {\n    const stringTag = /(\\w+)]/g.exec(Object.prototype.toString.call(value))[1]\n    return (\n      value instanceof Function &&\n      stringTag.includes('Async')\n    )\n  },\n\n  /**\n   * Checks if a given value is an arrow function. It verifies if the value is an instance\n   * of `Function`, if its string representation includes the '=>' symbol, and if it lacks\n   * a prototype, which is a characteristic of arrow functions in JavaScript.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is an arrow function, otherwise `false`.\n   */\n  isBigArrow(value) {\n    return (\n      value instanceof Function &&\n      String(value).includes('=>') &&\n      !String(value).startsWith('bound') &&\n      !Reflect.has(value, 'prototype')\n    );\n  },\n\n  /**\n   * Determines if a given value is a bound function. Bound functions are created using\n   * the `Function.prototype.bind` method, which allows setting the `this` value at the\n   * time of binding. This method checks if the value is an instance of `Function`, if\n   * its string representation starts with 'bound', and if it lacks a `prototype`\n   * property. These characteristics are indicative of bound functions in JavaScript.\n   *\n   * @param {*} value - The value to be checked, typically a function.\n   * @returns {boolean} Returns `true` if the value is a bound function, otherwise\n   * `false`. Bound functions have a specific format in their string representation\n   * and do not have their own `prototype` property.\n   */\n  isBound(value) {\n    return (\n      value instanceof Function &&\n      String(value).startsWith('bound') &&\n      !Reflect.has(value, 'prototype')\n    )\n  },\n})\n", "import { Patch } from '@nejs/extension';\n\n/**\n * `ObjectExtensions` is a patch for the JavaScript built-in `Object` class. It\n * adds utility methods to the `Object` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `Object` class with additional\n * utility functions.\n */\nexport const ObjectExtensions = new Patch(Object, {\n  /**\n   * Checks if the given value is a valid key for an object. In JavaScript, a valid\n   * key can be either a string or a symbol. This method is useful for validating\n   * object keys before using them in operations like setting or getting object properties.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} - Returns `true` if the value is a valid object key (string or symbol),\n   *                      otherwise `false`.\n   */\n  isValidKey(value) {\n    return (typeof value === 'string' || typeof value === 'symbol');\n  },\n\n  /**\n   * Determines if the provided value is an object. This method checks whether the\n   * value is an instance of `Object` or if its type is 'object'. It's a utility\n   * method for type-checking, ensuring that a value is an object before performing\n   * operations that are specific to objects.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} - Returns `true` if the value is an object, otherwise `false`.\n   */\n  isObject(value) {\n    return value && (value instanceof Object || typeof value === 'object');\n  },\n\n  /**\n   * Retrieves the string tag of an object. The string tag is a representation of\n   * the object's type, as defined by its `Object.prototype.toString` method. This\n   * utility method is helpful for getting a more descriptive type of an object than\n   * what is returned by the `typeof` operator, especially for custom objects.\n   *\n   * @param {*} value - The object whose string tag is to be retrieved.\n   * @returns {string} - The string tag of the object, indicating its type.\n   */\n  getStringTag(value) {\n    return /\\s(.+)]/.exec(Object.prototype.toString.call(value))[1];\n  },\n\n  /**\n   * Strips an object down to only the keys specified. Optionally, any\n   * accessors can be made to retain their context on the source object.\n   *\n   * @param {object} object the object to pare down\n   * @param {Array<string|symbol>} keys the keys that should appear in the\n   * final reduced object\n   * @param {boolean} [bindAccessors = true] if this value is true\n   * then any accessors from the source object will continue to have their\n   * `this` value bound to the source. If the getter or setter on that object\n   * is defined using an arrow function, this will not work as intended.\n   * @returns {object} an object containing only the keys and symbols specified\n   * in the `keys` parameter.\n   */\n  stripTo(object, keys, bindAccessors = true) {\n    const result = {}\n\n    if (!Array.isArray(keys)) {\n      return result\n    }\n\n    for (let key of keys) {\n      if (Reflect.has(object, key)) {\n        const descriptor = Object.getOwnPropertyDescriptor(object, key)\n        if (Reflect.has(descriptor, 'get') || Reflect.has(descriptor, 'set')) {\n          if (bindAccessors) {\n            descriptor.get = descriptor?.get?.bind(object)\n            descriptor.set = descriptor?.set?.bind(object)\n          }\n          Object.defineProperty(result, descriptor)\n        }\n        else {\n          Object.defineProperty(result, descriptor)\n        }\n      }\n    }\n\n    return result\n  },\n\n  /**\n   * Determines the type of the given value based on its string tag. This method\n   * uses `Object.getStringTag` to obtain the string tag of the value, which\n   * represents its more specific type (e.g., Array, Map, Set) rather than just\n   * 'object'. The method then maps this string tag to the corresponding type\n   * present in the provided `owner` object, which defaults to `globalThis`.\n   * This utility method is especially useful for identifying the specific\n   * constructor or class of an object, beyond the basic types identified by\n   * the `typeof` operator.\n   *\n   * @param {any} value - The value whose type is to be determined.\n   * @param {object} [owner=globalThis] - The object in which to look up the\n   * constructor corresponding to the string tag. Defaults to `globalThis`, which\n   * covers global constructors like `Array`, `Object`, etc.\n   * @returns {Function|object|null|undefined} - Returns the constructor or type\n   * of the value based on its string tag. For 'Null' and 'Undefined', it returns\n   * `null` and `undefined`, respectively. For other types, it returns the\n   * corresponding constructor (e.g., `Array` for arrays) if available in the\n   * `owner` object.\n   */\n  getType(value, owner = globalThis) {\n    const stringTag = Object.getStringTag(value)\n\n    switch (stringTag) {\n      case 'Null': return null\n      case 'Undefined': return undefined\n      default:\n        return owner[stringTag]\n    }\n  },\n});\n", "import { Patch } from '@nejs/extension'\nimport { ObjectExtensions } from './objectextensions.js'\n\n/**\n * The `ReflectExtensions` class is a patch applied to the built-in JavaScript\n * `Reflect` object. It extends `Reflect` with additional utility methods that\n * enhance its capabilities. These methods provide more advanced ways of\n * interacting with object properties, such as checking for the presence of\n * multiple keys at once (`hasAll`) or verifying if at least one specified key\n * exists in an object (`hasSome`). This class is part of the `@nejs/extension`\n * library and is designed to offer these extended functionalities in a way\n * that is consistent with the existing `Reflect` API, making it intuitive for\n * developers who are already familiar with standard reflection methods in\n * JavaScript.\n */\nexport const ReflectExtensions = new Patch(Reflect, {\n  /**\n   * The function checks if an object has all the specified keys.\n   *\n   * @param object - The `object` parameter is the object that we want to\n   * check if it has all the specified keys.\n   * @param keys - The `keys` parameter is a rest parameter, which means\n   * it can accept any number of arguments. In this case, it is expected\n   * to receive multiple keys as arguments.\n   * @returns a boolean value.\n   */\n  hasAll(object, ...keys) {\n    return Object.isObject(object) && (keys.flat(Infinity)\n      .map(key => Reflect.has(object, key))\n      .every(has => has)\n    )\n  },\n\n  ownDescriptors(object) {\n    const result = {}\n    const revertOnDone = () => revertOnDone.doIt ? ObjectExtensions.revert() : ''\n    revertOnDone.doIt = false\n\n    if (!Object.isObject) {\n      revertOnDone.doIt = true\n      ObjectExtensions.apply()\n    }\n\n    if (!Object.isObject(object)) {\n      revertOnDone()\n      return {}\n    }\n\n    const keys = Reflect.ownKeys(object)\n\n    for (const key of keys) {\n      result[key] = Object.getOwnPropertyDescriptor(key)\n    }\n\n    revertOnDone()\n\n    return result\n  },\n\n  /**\n   * The function checks if an object has at least one of the specified keys.\n   *\n   * @param object - The `object` parameter is the object that we want to check\n   * for the presence of certain keys.\n   * @param keys - The `keys` parameter is a rest parameter, which means it can\n   * accept any number of arguments. These arguments are the keys that we want\n   * to check if they exist in the `object`.\n   * @returns The function `hasSome` returns a boolean value indicating whether\n   * at least one of the keys provided as arguments exists in the given object.\n   */\n  hasSome(object, ...keys) {\n    return Object.isObject(object) && (keys.flat(Infinity)\n      .map(key => Reflect.has(object, key))\n      .some(has => has)\n    )\n  },\n\n  /**\n   * Retrieves an array of [key, descriptor] pairs for each property of the\n   * provided object. This method is akin to `Object.entries` but includes\n   * property descriptors instead of the property values. It's useful for cases\n   * where you need detailed information about properties, including their\n   * configurability, enumerability, and accessors.\n   *\n   * @param {object} object - The object whose property entries are to be\n   * retrieved.\n   * @returns {Array} An array of [key, descriptor] pairs, where each pair\n   * consists of the property name (key) and its descriptor. Returns an empty\n   * array if the input is not a valid object.\n   */\n  entries(object) {\n    if (!object || typeof object !== 'object') { return [] }\n\n    return Reflect.ownKeys(object).map(key => [\n      key, Object.getOwnPropertyDescriptor(object, key)\n    ])\n  },\n\n  /**\n   * Retrieves an array of values from the property descriptors of the given\n   * object. This method works similarly to `Object.values` but operates on\n   * property descriptors instead. It's useful when you need the values of\n   * properties including getters, setters, and other descriptor-specific\n   * attributes.\n   *\n   * @param {object} object - The object whose property values are to be\n   * retrieved.\n   * @returns {Array} An array of values extracted from the object's property\n   * descriptors. The values correspond to the `value` attribute in each\n   * property's descriptor. Returns an empty array if the input is not a valid\n   * object.\n   */\n  values(object) {\n    return Reflect.entries.map(([,value]) => value)\n  }\n})\n", "import { Patch } from '@nejs/extension';\n\n/**\n * `StringExtensions` is a patch for the JavaScript built-in `String` class. It\n * adds utility methods to the `String` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `String` class with additional\n * utility functions.\n */\nexport const StringExtensions = new Patch(String, {\n  /**\n   * The `isString` method does exactly what one would it expect. It returns\n   * true if the string matches typeof or instanceof as a string.\n   *\n   * @param {*} value checks to see if the `value` is a string\n   * @returns {boolean} `true` if it is a `String`, `false` otherwise\n   */\n  isString(value) {\n    if (value && (typeof value === 'string' || value instanceof String)) {\n      return value.length > 0\n    }\n    return false\n  },\n});\n", "import { Patch } from '@nejs/extension';\n\n/**\n * `SymbolExtensions` is a patch for the JavaScript built-in `Symbol` class. It\n * adds utility methods to the `Symbol` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `Symbol` class with additional\n * utility functions.\n */\nexport const SymbolExtensions = new Patch(Symbol, {\n  /**\n   * The `isSymbol` method does exactly what one would it expect. It returns\n   * true if the string matches typeof or instanceof as a symbol.\n   *\n   * @param {*} value checks to see if the `value` is a string\n   * @returns {boolean} `true` if it is a `Symbol`, `false` otherwise\n   */\n  isSymbol(value) {\n    if (value && (typeof value === 'symbol')) {\n      return true\n    }\n    return false\n  },\n});\n", "import { Patch } from '@nejs/extension'\n\n/**\n * The `ArrayPrototypeExtensions` patch extends the prototype of the built-in\n * JavaScript `Array` with additional properties for convenience and improved\n * readability. By applying this patch, all array instances gain new getter\n * properties `first` and `last`, which provide quick access to the first and\n * last elements of the array, respectively. This enhancement simplifies common\n * operations on arrays and makes code more expressive and concise.\n */\nexport const ArrayPrototypeExtensions = new Patch(Array.prototype, {\n  /**\n   * Sometimes defining even a short function for the invocation of `find`\n   * can be troublesome. This helper function performs that job for you. If\n   * the specified element is in the array, `true` will be returned.\n   *\n   * @param {*} value the value to search for. This value must triple equals\n   * the array element in order to return true.\n   * @returns true if the exact element exists in the array, false otherwise\n   */\n  contains(value) {\n    return !!this.find(entry => entry === value)\n  },\n\n  /**\n   * The `findEntry` function searches the entries of the object and returns\n   * the `[index, value]` entry array for the first matching value found.\n   *\n   * @param {function} findFn a function that takes the element to be checked\n   * and returns a boolean value\n   * @returns if `findFn` returns `true`, an array with two elements, the first\n   * being the index, the second being the value, is returned.\n   */\n  findEntry(findFn) {\n    const entries = this.entries()\n    const VALUE = 1\n\n    for (let entry of entries) {\n      if (findFn(entry[VALUE])) {\n        return entry\n      }\n    }\n\n    return undefined\n  },\n\n  /**\n   * A getter property that returns the first element of the array. If the\n   * array is empty, it returns `undefined`. This property is useful for\n   * scenarios where you need to quickly access the first item of an array\n   * without the need for additional checks or method calls.\n   *\n   * @returns {*} The first element of the array or `undefined` if the array\n   * is empty.\n   */\n  get first() {\n    return this[0];\n  },\n\n  /**\n   * A getter property that returns the last element of the array. It\n   * calculates the last index based on the array's length. If the array is\n   * empty, it returns `undefined`. This property is beneficial when you need\n   * to access the last item in an array, improving code readability and\n   * avoiding manual index calculation.\n   *\n   * @returns {*} The last element of the array or `undefined` if the\n   * array is empty.\n   */\n  get last() {\n    return this[this.length - 1];\n  },\n\n})", "import { Extension } from '@nejs/extension'\nimport { ObjectExtensions } from './objectextensions.js'\nimport { StringExtensions } from './stringextensions.js'\nimport { ReflectExtensions } from './reflectextensions.js'\n\nconst isObject = ObjectExtensions.patchEntries?.isObject?.computed\nconst isValidKey = ObjectExtensions.patchEntries?.isValidKey?.computed\nconst isString = StringExtensions.patchEntries?.isString?.computed\nconst hasSome = ReflectExtensions.patchEntries?.hasSome?.computed\n\nclass Descriptor {\n  #desc = Descriptor.enigmatic\n\n  /**\n   * Creates a new instance of Descriptor either from another object or\n   * around the supplied object descriptor value.\n   *\n   * @param {object} object either an object descriptor or the object\n   * from which to get the descriptor\n   * @param {symbol|string} key a valid key for accessing the descriptor\n   * on the aforesupplied object.\n   */\n  constructor(object, key) {\n    this.#desc = object\n\n    if (isObject(object) && isValidKey(key)) {\n      this.#desc = Object.getOwnPropertyDescriptor(object, key)\n    }\n\n    if (!this.isDescriptor) {\n      throw new Error(`Not a valid descriptor:`, this.#desc)\n    }\n  }\n\n  /**\n   * Detects whether or not this instance is an accessor object descriptor\n   *\n   * @returns {boolean} true if this object has a getter or setter and is not\n   * a data descriptor\n   */\n  get isAccessor() {\n    return Descriptor.isAccessor(this.#desc)\n  }\n\n  /**\n   * Detects whether or not this instance is an data object descriptor\n   *\n   * @returns {boolean} true if this object has a value property and is not\n   * an accessor descriptor\n   */\n  get isData() {\n    return Descriptor.isData(this.#desc)\n  }\n\n  /**\n   * Detects whether or not this instance is a valid object descriptor\n   *\n   * @returns {boolean} true if this descriptor store is a valid descriptor\n   */\n  get isDescriptor() {\n    return Descriptor.isDescriptor(this.#desc)\n  }\n\n  /**\n   * Getter around the `configurable` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {boolean} a boolean value or undefined if the internal\n   * descriptor store is invalid.\n   */\n  get configurable() {\n    return !!this.#desc?.configurable\n  }\n\n  /**\n   * Sets the `configurable` value of this object. If the internal descriptor\n   * store store is invalid, the value is thrown away\n   *\n   * @param {boolean} value the value to set for the `configurable` descriptor\n   * property. If this value is not a `boolean` it will be converted to one\n   */\n  set configurable(value) {\n    (this.#desc || {}).configurable = !!value\n  }\n\n  /**\n   * Getter around the `enumerable` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {boolean} a boolean value or undefined if the internal\n   * descriptor store is invalid.\n   */\n  get enumerable() {\n    return this.#desc?.enumerable\n  }\n\n  /**\n   * Sets the `enumerable` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {boolean} value the value to set for the `enumerable` descriptor\n   * property. If this value is not a `boolean` it will be converted to one\n   */\n  set enumerable(value) {\n    (this.#desc || {}).enumerable = value\n  }\n\n  /**\n   * Getter around the `writable` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {boolean} a boolean value or undefined if the internal\n   * descriptor store is invalid.\n   */\n  get writable() {\n    return this.#desc?.writable\n  }\n\n  /**\n   * Sets the `writable` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {boolean} value the value to set for the `writable` descriptor\n   * property. If this value is not a `boolean` it will be converted to one\n   */\n  set writable(value) {\n    (this.#desc || {}).writable = value\n  }\n\n  /**\n   * Getter around the `value` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {any} any value stored in this descriptor\n   */\n  get value() {\n    return this.#desc?.value\n  }\n\n  /**\n   * Sets the `value` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {any} value the value to set for the `value` descriptor\n   * property.\n   */\n  set value(value) {\n    (this.#desc || {}).value = value\n  }\n\n  /**\n   * Getter around the `get` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {function} a function if the getter for this descriptor is\n   * defined or `undefined` if the internal descriptor object or the getter\n   * is undefined.\n   */\n  get get() {\n    return this.#desc?.get\n  }\n\n  /**\n   * Sets the `get` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {function} value the getter function for this descriptor\n   */\n  set get(value) {\n    (this.#desc || {}).get = value\n  }\n\n  /**\n   * Getter around the `set` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {function} a function if the setter for this descriptor is\n   * defined or `undefined` if the internal descriptor object or the setter\n   * is undefined.\n   */\n  get set() {\n    return this.#desc?.writable\n  }\n\n  /**\n   * Sets the `set` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {function} value the setter function for this descriptor\n   */\n  set set(value) {\n    (this.#desc || {}).set = value\n  }\n\n  /**\n   * Take the descriptor defined by this objects values and apply them to\n   * the specified object using the specified key.\n   *\n   * @param {object} object the object to apply this descriptor to\n   * @param {string|symbol} forKey the string or symbol for which this\n   * descriptor will abe applied\n   */\n  applyTo(object, forKey) {\n    if (!isObject(object) || !isValidKey(forKey)) {\n      throw new Error(`Cannot apply descriptor to non-object or invalid key`)\n    }\n\n    return Object.defineProperty(object, forKey, this.#desc)\n  }\n\n  /**\n   * Converts this descriptor object into a base representation\n   *\n   * @param {string} hint one of `string`, `number` or default;\n   * @returns if the hint is 'string', then a string identifying the enum\n   * and its type is returned. `number` will always be NaN since it is incoret\n   */\n  [Symbol.toPrimitive](hint) {\n    switch (hint) {\n      case 'string':\n        if (this.isAccessor) {\n          const hasGetter = Reflect.has(this.#desc, 'get') ? `getter` : ''\n          const hasSetter = Reflect.has(this.#desc, 'set') ? `setter` : ''\n          const separator = hasGetter && hasSetter ? ', ' : ''\n\n          return `Accessor (${hasGetter}${separator}${hasSetter})`\n        }\n        else if (this.isData) {\n          const hasGetter = Reflect.has(this.#desc, 'value') ? `value` : ''\n          const hasSetter = Reflect.has(this.#desc, 'writable') ? `writable` : ''\n          const separator = hasGetter && hasSetter ? ', ' : ''\n\n          return `Data (${hasGetter}${separator}${hasSetter})`\n        }\n        break\n\n      case 'number':\n        return NaN\n\n      default:\n        return this.#desc\n    }\n  }\n\n  /**\n   * The function `getData` retrieves the value of a property from an object if it\n   * exists and is a data property.\n   *\n   * @param object - The \"object\" parameter is the object from which we want to\n   * retrieve data.\n   * @param property - The `property` parameter is the name of the property that\n   * you want to retrieve the data from.\n   * @returns either the value of the specified property if it exists and is a data\n   * property, or undefined if the property does not exist or is not a data\n   * property.\n   */\n  static getData(object, property) {\n    if (!isObject(object) || !isString(property)) {\n      return null;\n    }\n\n    const descriptors = Descriptor.all(object)\n    if (descriptors.has(property)) {\n      const descriptor = descriptors.get(property)\n\n      if (Descriptor.isData(descriptor)) {\n        return descriptor.value\n      }\n    }\n\n    return undefined\n  }\n\n  /**\n   * The function `getAccessor` checks if an object has a getter/setter accessor\n   * for a given property and returns the accessor functions if found.\n   *\n   * @param object - The `object` parameter is the object from which we want to\n   * retrieve the accessor for a specific property.\n   * @param property - The `property` parameter is the name of the property for\n   * which we want to get the accessor.\n   * @returns an object that contains the getter and setter functions for the\n   * specified property of the given object. If the property is an accessor\n   * property (defined with a getter and/or setter), the returned object will also\n   * have additional properties such as \"accessor\" and \"descriptor\". If the\n   * property is not found or is not an accessor property, the function returns\n   * undefined.\n   */\n  static getAccessor(object, property) {\n    if (!isObject(object))\n    return null\n\n    const [GETTER, SETTER, OBJECT] = [0, 1, 2]\n    const results = [undefined, undefined, undefined]\n    const descriptors = this.all(object)\n    const isDescriptor = Descriptor.isDescriptor(object)\n\n    if (descriptors.has(property) || isDescriptor) {\n      const descriptor = isDescriptor ? object : descriptors.get(property)\n\n      if (Descriptor.isAccessor(descriptor)) {\n        results[OBJECT] = descriptors.object(property)\n        results[GETTER] = descriptor?.get\n        results[SETTER] = descriptor?.set\n\n        Object.assign(results, {\n          get() { this[GETTER].bind(this[OBJECT])() },\n          set(value) { this[SETTER].bind(this[OBJECT])(value) },\n          get accessor() { return true },\n          get descriptor() { return descriptor },\n          get boundDescriptor() {\n            return {\n              ...descriptor,\n              get: descriptor.get?.bind(object),\n              set: descriptor.set?.bind(object),\n            }\n          }\n        })\n\n        return results\n      }\n    }\n\n    return undefined\n  }\n\n  /**\n   * The function returns an object with enumerable and configurable properties\n   * based on the input parameters.\n   *\n   * @param [enumerable=false] - A boolean value indicating whether the property\n   * can be enumerated (listed) when iterating over the object's properties.\n   * @param [configurable=false] - The `configurable` parameter determines whether\n   * the property can be deleted or its attributes can be modified. If\n   * `configurable` is set to `true`, the property can be deleted and its\n   * attributes can be changed. If `configurable` is set to `false`, the property\n   * cannot be deleted and\n   * @returns An object with the properties `enumerable` and `configurable` is\n   * being returned. The values of these properties are determined by the arguments\n   * passed to the `base` function.\n   */\n  static base(enumerable = false, configurable = false) {\n    return {\n      enumerable,\n      configurable\n    }\n  }\n\n  /**\n   * The function \"newAccessor\" creates a new property descriptor object with a\n   * getter and setter function, along with optional enumerable and configurable\n   * flags.\n   *\n   * @param getter - The getter parameter is a function that will be used as the\n   * getter for the property. It will be called when the property is accessed.\n   * @param setter - The `setter` parameter is a function that will be used as the\n   * setter for the property. It will be called whenever the property is assigned a\n   * new value.\n   * @param [] - - `getter`: A function that will be used as the getter for the\n   * property.\n   * @returns an object with properties \"get\", \"set\", \"enumerable\", and\n   * \"configurable\".\n   */\n  static accessor(\n    getter,\n    setter,\n    { enumerable, configurable } = Descriptor.base()\n  ) {\n    return {\n      get: getter,\n      set: setter,\n      enumerable,\n      configurable\n    }\n  }\n\n  /**\n   * The function \"newData\" creates a new data object with customizable properties.\n   *\n   * @param value - The value parameter represents the value that will be assigned\n   * to the property.\n   * @param [writable=true] - The `writable` parameter determines whether the value\n   * of the property can be changed. If `writable` is set to `true`, the value can\n   * be changed. If `writable` is set to `false`, the value cannot be changed.\n   * @param [] - - `value`: The value to be assigned to the property.\n   * @returns an object with properties `value`, `enumerable`, `writable`, and\n   * `configurable`.\n   */\n  static data(\n    value,\n    writable = true,\n    { enumerable, configurable } = Descriptor.base()\n  ) {\n    return {\n      value,\n      enumerable,\n      writable,\n      configurable\n    }\n  }\n\n  /**\n   * The function checks if an object is a valid object descriptor in JavaScript.\n   *\n   * @param object - The `object` parameter is the object that we want to check if\n   * it is a descriptor.\n   * @returns a boolean value.\n   */\n  static isDescriptor(object) {\n    const knownKeys = [\n      ...Descriptor.SHARED_KEYS,\n      ...Descriptor.ACCESSOR_KEYS,\n      ...Descriptor.DATA_KEYS,\n    ]\n\n    return hasSome(object, knownKeys)\n  }\n\n  /**\n   * The function checks if a given property or descriptor is a data property.\n   *\n   * @param descriptor_orProp - The `descriptor_orProp` parameter can be either a\n   * descriptor or a property name.\n   * @param object - The `object` parameter is the object that you want to check\n   * for data properties.\n   * @returns a boolean value. It returns `true` if the `descriptor` object has any\n   * keys that match the `DATA_KEYS` array, otherwise it returns `false`.\n   */\n  static isData(object_orProp, property) {\n    const needsDescriptor = (\n      ((typeof object_orProp === 'object') || object_orProp instanceof Object) &&\n      property instanceof String\n    )\n\n    const descriptor = (needsDescriptor\n      ? Descriptor.for(object_orProp, property)\n      : object_orProp\n    )\n\n    const { ACCESSOR_KEYS, DATA_KEYS } = this\n    let validData = false\n\n    if (hasSome(descriptor, ACCESSOR_KEYS)) {\n      validData = false\n    }\n    else if (hasSome(descriptor, DATA_KEYS)) {\n      validData = true\n    }\n\n    return validData\n  }\n\n  /**\n   * The function checks if a given property descriptor or property of an object is\n   * an accessor.\n   *\n   * @param object_orProp - The `descriptor_orProp` parameter can be either a\n   * descriptor object or a property name.\n   * @param property - The `object` parameter is the object that you want to check\n   * for accessor properties.\n   * @returns a boolean value. It returns true if the descriptor or property passed\n   * as an argument is an accessor descriptor, and false otherwise.\n   */\n  static isAccessor(object_orProp, property) {\n    const needsDescriptor = (\n      (object_orProp && property) &&\n      ((typeof object_orProp === 'object') || object_orProp instanceof Object) &&\n      (property instanceof String || (typeof property === 'symbol'))\n    )\n\n    const descriptor = (needsDescriptor\n      ? Descriptor.for(object_orProp, property)\n      : object_orProp)\n\n    const { ACCESSOR_KEYS, DATA_KEYS } = this\n    let validAccessor = false\n\n    if (hasSome(descriptor, DATA_KEYS)) {\n      validAccessor = false\n    }\n    else if (hasSome(descriptor, ACCESSOR_KEYS)) {\n      validAccessor = true\n    }\n\n    return validAccessor\n  }\n\n  /**\n   * A base descriptor (new for each read) that is both enumerable and configurable\n   *\n   * @returns The method `flexible` is returning the result of calling the `base`\n   * method with the arguments `true` and `true`.\n   */\n  static get flexible() {\n    return this.base(true, true)\n  }\n\n  /**\n   * A base descriptor (new for each read) that is not enumerable but is configurable\n   *\n   * @returns The method `enigmatic` is returning the result of calling the `base`\n   * method with the arguments `false` and `true`.\n   */\n  static get enigmatic() {\n    return this.base(false, true)\n  }\n\n  /**\n   * A base descriptor (new for each read) that is neither enumerable nor configurable\n   *\n   * @returns The code is returning the result of calling the `base` method with\n   * the arguments `false` and `false`.\n   */\n  static get intrinsic() {\n    return this.base(false, false)\n  }\n\n  /**\n   * A base descriptor (new for each read) that enumerable but not configurable\n   *\n   * @returns The method is returning the result of calling the `base` method with\n   * the arguments `true` and `false`.\n   */\n  static get transparent() {\n    return this.base(true, false)\n  }\n\n  /**\n   * The function returns an array of shared descriptor keys.\n   *\n   * @returns An array containing the strings 'configurable' and 'enumerable'.\n   */\n  static get SHARED_KEYS() {\n    return ['configurable', 'enumerable']\n  }\n\n  /**\n   * The function returns an array of accessor descriptor keys.\n   *\n   * @returns An array containing the strings 'get' and 'set' is being returned.\n   */\n  static get ACCESSOR_KEYS() {\n    return ['get', 'set']\n  }\n\n  /**\n   * The function returns an array of data descriptor keys.\n   *\n   * @returns An array containing the strings 'value' and 'writable' is being\n   * returned.\n   */\n  static get DATA_KEYS() {\n    return ['value', 'writable']\n  }\n}\n\nexport const DescriptorExtension = new Extension(Descriptor)"],
  "mappings": "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",
  "names": ["src_exports", "__export", "ArrayPrototypeExtensions", "FunctionExtensions", "ObjectExtensions", "ReflectExtensions", "StringExtensions", "SymbolExtensions", "disableAll", "enableAll", "typeOf", "o", "CannotBeExtendedError", "owner", "key", "typeOf", "o", "MissingOwnerValue", "owner", "key", "PatchToggle", "patch", "preventRevert", "depth", "options", "inspect", "objName", "status", "Patch", "_Patch", "owner", "patches", "options", "key", "#PatchEntry", "patch", "preventRevert", "PatchToggle", "e", "property", "owningObject", "depth", "inspect", "Extension", "_Extension", "Patch", "keyClassOrFn", "value", "owner", "options", "key", "extension", "valid", "MissingOwnerValue", "descriptor", "CannotBeExtendedError", "input", "depth", "inspect", "FunctionExtensions", "Patch", "value", "stringTag", "ObjectExtensions", "Patch", "value", "object", "keys", "bindAccessors", "result", "key", "descriptor", "owner", "stringTag", "ReflectExtensions", "Patch", "object", "keys", "key", "has", "result", "revertOnDone", "ObjectExtensions", "value", "StringExtensions", "Patch", "value", "SymbolExtensions", "Patch", "value", "ArrayPrototypeExtensions", "Patch", "value", "entry", "findFn", "entries", "VALUE", "isObject", "ObjectExtensions", "isValidKey", "isString", "StringExtensions", "hasSome", "ReflectExtensions", "Descriptor", "_Descriptor", "#desc", "object", "key", "value", "forKey", "hint", "hasGetter", "hasSetter", "property", "descriptors", "descriptor", "GETTER", "SETTER", "OBJECT", "results", "isDescriptor", "enumerable", "configurable", "getter", "setter", "writable", "knownKeys", "object_orProp", "ACCESSOR_KEYS", "DATA_KEYS", "validData", "validAccessor", "DescriptorExtension", "Extension", "Owners", "NetNew", "DescriptorExtension", "enableAll", "owners", "owner", "Patch", "extension", "disableAll"]
}
