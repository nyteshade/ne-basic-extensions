{
  "version": 3,
  "sources": ["../../src/index.js", "../../node_modules/@nejs/extension/dist/mjs/errors/CannotBeExtendedError.js", "../../node_modules/@nejs/extension/dist/mjs/errors/MissingOwnerValue.js", "../../node_modules/@nejs/extension/dist/mjs/patchtoggle.js", "../../node_modules/@nejs/extension/dist/mjs/patch.js", "../../node_modules/@nejs/extension/dist/mjs/extension.js", "../../src/functionextensions.js", "../../src/objectextensions.js", "../../src/reflectextensions.js", "../../src/stringextensions.js", "../../src/symbolextensions.js", "../../src/arrayextensions.js"],
  "sourcesContent": ["import { FunctionExtensions } from './functionextensions.js'\nimport { ObjectExtensions } from './objectextensions.js'\nimport { ReflectExtensions } from './reflectextensions.js'\nimport { StringExtensions } from './stringextensions.js'\nimport { SymbolExtensions } from './symbolextensions.js'\nimport { ArrayPrototypeExtensions } from './arrayextensions.js'\n\nimport { Patch } from '@nejs/extension'\n\nconst Owners = [\n  Object,\n  Function,\n  Reflect,\n  String,\n  Symbol,\n\n  Array.prototype,\n]\n\nexport function enableAll(owners) {\n  (owners || Owners).forEach(owner => {\n    Patch.enableFor(owner)\n  })\n}\n\nexport function disableAll(owners) {\n  (owners || Owners).forEach(owner => {\n    Patch.disableFor(owner)\n  })\n}\n\nexport {\n  ObjectExtensions,\n  FunctionExtensions,\n  ReflectExtensions,\n  StringExtensions,\n  SymbolExtensions,\n  ArrayPrototypeExtensions,\n}", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1];\n/**\n * Represents an error that is thrown when there is an attempt to extend a\n * restricted part of the code. This error is specifically used to signal\n * violations of extension constraints, such as tampering with certain keys\n * or properties of an object. The error message constructed will include the\n * details of the owner (the restricted part) and the key that was attempted to\n * be tampered with.\n */\nexport class CannotBeExtendedError extends Error {\n    /**\n     * Constructs a new CannotBeExtendedError instance.\n     *\n     * @param {string} owner The name or identifier of the restricted part\n     * that is disallowing extension or tampering.\n     * @param {string} key The key or property that was attempted to be\n     * modified or extended.\n     */\n    constructor(owner, key) {\n        super(`${typeOf(owner)} disallows tampering with ${key}.`);\n        Object.assign(this, { owner, key });\n    }\n    /**\n     * Custom getter for the toStringTag symbol. Overrides the default\n     * Object.prototype.toString behavior, returning the constructor's name\n     * of this error instance. Useful for debugging and logging purposes.\n     * @returns {string} The name of the constructor for this error instance.\n     */\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1];\n/**\n * Represents an error that is thrown when a property is missing from a specified\n * owner object. This error is used to indicate that a specific key or property\n * expected to be present on the owner is not found, highlighting potential issues\n * in property access or data integrity.\n */\nexport class MissingOwnerValue extends Error {\n    /**\n     * Constructs a new MissingOwnerValue instance.\n     *\n     * @param {string} owner The object or entity that is supposed to contain the\n     * property.\n     * @param {string} key The name of the property that is missing from the owner.\n     */\n    constructor(owner, key) {\n        super(`${typeOf(owner)} does not have a property named '${key}'.`);\n        Object.assign(this, { owner, key });\n    }\n    /**\n     * Custom getter for the toStringTag symbol. Overrides the default\n     * Object.prototype.toString behavior, returning the constructor's name\n     * of this error instance. Useful for debugging and logging purposes.\n     *\n     * @returns {string} The name of the constructor for this error instance.\n     */\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n", "import { Patch } from \"./patch\";\n/**\n * Early usage of the Patch and Extension classes made it clear that it was\n * cumbersome to use a Patch temporarily for a block of code and excessive\n * amounts of if/else statements were required. This simple wrapper makes that\n * process easier.\n */\nexport class PatchToggle {\n    /**\n     * Wraps an instance of a Patch. It allows low-code clean-readability to\n     * start and stop the underlying patch regardless of whether or not the\n     * patch has been already applied.\n     *\n     * @param {Patch} patch instance of `Patch` to wrap with this toggle\n     * @param {boolean} preventRevert prevents the call to `.revert()` on the\n     * supplied patch when stop() is called.\n     */\n    constructor(patch, preventRevert = false) {\n        this.started = false;\n        this.preventRevert = preventRevert;\n        this.patch = patch;\n        this.patchName = (patch.owner?.name ??\n            patch.owner?.constructor?.name ??\n            /(\\w+)]/.exec(Object.prototype.toString.call(patch.owner))[1]);\n        this.state = {\n            needsApplication: false,\n            needsReversion: false,\n        };\n    }\n    /**\n     * If the usage of the wrapped Patch hasn't been started yet, the code checks\n     * whether or not the patch has been applied by checking for signs of it in\n     * the owning object.\n     *\n     * If the patch needs to be applied, it will be applied at this time.\n     *\n     * @returns {PatchToggle} returns `this` to allow for chaining\n     */\n    start() {\n        if (!this.started) {\n            this.state.needsApplication = !this.patch.applied;\n            this.state.needsReversion = this.patch.applied;\n            this.started = true;\n            if (this.state.needsApplication) {\n                this.patch.apply();\n            }\n        }\n        return this;\n    }\n    /**\n     * Checks to see if the toggle has been started. If so, the patch is reverted\n     * if it needed to be applied previously. After stopping, the state of the instance\n     * is reverted to allow for clean subsequent calls to start.\n     *\n     * @returns {PatchToggle} returns `this` to allow further chaining\n     */\n    stop() {\n        if (this.started) {\n            if (this.preventRevert || this.patch.applied) {\n                this.patch.revert();\n            }\n            this.state.needsApplication = false;\n            this.state.needsReversion = false;\n            this.started = false;\n        }\n        return this;\n    }\n    /**\n     * When the string tag for this class instance is inspected, it will\n     * reflect the string `PatchToggle:PatchName`\n     */\n    get [Symbol.toStringTag]() {\n        return `${this.constructor.name}:${this.patchName}`;\n    }\n    /**\n     * Custom inspect function for Node.js that provides a formatted representation\n     * of the PatchToggle instance, primarily for debugging purposes.\n     *\n     * @param {number} depth The depth to which the object should be formatted.\n     * @param {object} options Formatting options.\n     * @param {function} inspect The inspection function to format the object.\n     * @returns {string} A formatted string representing the PatchEntry instance.\n     */\n    [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n        const objName = this[Symbol.toStringTag];\n        const status = `(started: ${this.started} needed: ${this.state.needsApplication})`;\n        return inspect(`${objName} ${status}`, { ...options, depth });\n    }\n}\n", "import { PatchToggle } from './patchtoggle.js';\n/**\n * The Patch class provides a mechanism to apply patches to properties or\n * methods of an object (the owner). It keeps track of the original state of\n * these properties and allows for the application and reversion of patches.\n */\nexport class Patch {\n    /**\n     * Constructs a new Patch instance.\n     *\n     * @param {object} owner The object to which patches will be applied.\n     * @param {object} patches An object containing properties or methods to\n     *                         be patched onto the owner.\n     * @param {object} [options={}] Additional options for patching behavior.\n     */\n    constructor(owner, patches, options = {}) {\n        Object.assign(this, {\n            owner,\n            options,\n            applied: false,\n        });\n        this.patchConflicts = {};\n        this.patchEntries = {};\n        this.patchesOwner = patches;\n        Reflect.ownKeys(patches).forEach(key => {\n            this.patchEntries[key] = new Patch.#PatchEntry(key, this.patchesOwner);\n            if (Reflect.has(this.owner, key)) {\n                this.patchConflicts[key] = new Patch.#PatchEntry(key, this.owner);\n            }\n        });\n        if (!Patch.patches.has(owner)) {\n            Patch.patches.set(owner, []);\n        }\n        Patch.patches.get(owner).push(this);\n    }\n    /**\n     * Retrieves the patch entries as an array of [key, patchEntry] pairs.\n     *\n     * @returns {Array} An array of [key, patchEntry] pairs.\n     */\n    get patches() {\n        return Reflect.ownKeys(this.patchEntries).map(key => {\n            return [key, this.patchEntries[key]];\n        });\n    }\n    /**\n     * Retrieves the conflict entries (existing properties on the owner that\n     * will be overridden by patches) as an array of [key, patchEntry] pairs.\n     *\n     * @returns {Array} An array of [key, patchEntry] pairs.\n     */\n    get conflicts() {\n        return Reflect.ownKeys(this.patchConflicts).map(key => {\n            return [key, this.patchConflicts[key]];\n        });\n    }\n    /**\n     * Applies all patches to the owner object. If a property with the same key\n     * already exists on the owner, it will be overridden.\n     */\n    apply() {\n        if (!this.applied) {\n            this.patches.forEach(([, patch]) => {\n                Object.defineProperty(this.owner, patch.key, patch.descriptor);\n            });\n            this.applied = true;\n        }\n    }\n    /**\n     * Creates an easy to use toggle for working with `Patch` classes\n     *\n     * @param {boolean} preventRevert true if calling stop() on the toggle does not\n     * revert the patch. false, the default, if it should.\n     * @returns {PatchToggle} an instance of PatchToggle wrapped around this instance\n     * of `Patch`\n     * @example const toggle = ObjectExtensions.createToggle().start()\n     */\n    createToggle(preventRevert = false) {\n        return new PatchToggle(this, preventRevert);\n    }\n    /**\n     * Reverts all applied patches on the owner object, restoring any overridden\n     * properties to their original state.\n     */\n    revert() {\n        if (this.applied) {\n            this.patches.forEach(([, patch]) => {\n                delete this.owner[patch.key];\n            });\n            this.conflicts.forEach(([, patch]) => {\n                Object.defineProperty(this.owner, patch.key, patch.descriptor);\n            });\n            this.applied = false;\n        }\n    }\n    /**\n     * Removes this Patch instance from being tracked amongst all the tracked Patch\n     * instances. The JavaScript virtual machine will clean this instance up once\n     * nothing else is holding a reference to it.\n     */\n    release() {\n        const patches = Patch.patches.get(this.owner);\n        patches.splice(patches.find(e => e === this), 1);\n    }\n    /**\n     * The object to which the patches are applied.\n     */\n    owner = null;\n    /**\n     * Additional options for patching behavior.\n     */\n    options = null;\n    /**\n     * A global mapping of all patches in play\n     */\n    static patches = new Map();\n    /**\n     * Applies all patches associated with a given owner object. This method\n     * is used to enable all patches for a specific owner if they have been\n     * previously registered.\n     *\n     * @param {object} owner The object whose patches are to be applied.\n     */\n    static enableFor(owner) {\n        if (Patch.patches.has(owner)) {\n            for (const patch of Patch.patches.get(owner)) {\n                patch.apply();\n            }\n        }\n    }\n    /**\n     * Reverts all patches associated with a given owner object. This method\n     * is used to disable all patches for a specific owner if they have been\n     * previously applied.\n     *\n     * @param {object} owner The object whose patches are to be reverted.\n     */\n    static disableFor(owner) {\n        if (Patch.patches.has(owner)) {\n            for (const patch of Patch.patches.get(owner)) {\n                patch.revert();\n            }\n        }\n    }\n    /**\n     * Internal class representing a single patch entry.\n     */\n    static #PatchEntry = class {\n        /**\n         * Constructs a new PatchEntry instance.\n         *\n         * @param {string} property The property key to be patched.\n         * @param {object} [owningObject=globalThis] The object from which the\n         * property descriptor is taken.\n         */\n        constructor(property, owningObject = globalThis) {\n            Object.assign(this, {\n                key: property,\n                descriptor: Object.getOwnPropertyDescriptor(owningObject, property),\n                owner: owningObject\n            });\n        }\n        /**\n         * Computes and returns the current value of the patch, based on its type\n         * (data or accessor).\n         *\n         * @returns {any} The current value of the patch.\n         */\n        get computed() {\n            if (this.isAccessor) {\n                return this.descriptor.get.bind(this.owner).call();\n            }\n            else {\n                return this.descriptor.value;\n            }\n        }\n        /**\n         * Checks if the patch is a data property (has a value).\n         *\n         * @returns {boolean} True if the patch is a data property, false otherwise.\n         */\n        get isData() {\n            return Reflect.has(this.descriptor, 'value');\n        }\n        /**\n         * Checks if the patch is an accessor property (has a getter).\n         *\n         * @returns {boolean} True if the patch is an accessor property, false otherwise.\n         */\n        get isAccessor() {\n            return Reflect.has(this.descriptor, 'get');\n        }\n        /**\n         * Checks if the patch is read-only (not configurable or not writable).\n         *\n         * @returns {boolean} True if the patch is read-only, false otherwise.\n         */\n        get isReadOnly() {\n            return ((Reflect.has(this.descriptor, 'configurable') && !this.descriptor.configurable) ||\n                (Reflect.has(this.descriptor, 'writable') && !this.descriptor.writable));\n        }\n        /**\n         * Custom getter for the toStringTag symbol. Provides the class name of\n         * the PatchEntry instance.\n         *\n         * @returns {string} The class name of the PatchEntry instance.\n         */\n        get [Symbol.toStringTag]() {\n            return this.constructor.name;\n        }\n        /**\n         * Custom inspect function for Node.js that provides a formatted representation\n         * of the PatchEntry instance, primarily for debugging purposes.\n         *\n         * @param {number} depth The depth to which the object should be formatted.\n         * @param {object} options Formatting options.\n         * @param {function} inspect The inspection function to format the object.\n         * @returns {string} A formatted string representing the PatchEntry instance.\n         */\n        [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n            return `PatchEntry<${this.key}, ${this.isData ? 'Data' : 'Accessor'}${this.isReadOnly ? ' [ReadOnly]' : ''}>`;\n        }\n    };\n}\n", "import { CannotBeExtendedError } from \"./errors/CannotBeExtendedError.js\";\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js';\nimport { Patch } from './patch.js';\n/**\n * The Extension class, inheriting from the Patch class, is specifically designed\n * for extending properties or methods of a given object. It facilitates the\n * extension process by determining the target key and value for the extension and\n * ensuring the target property is writable and configurable. If these conditions\n * are not met, the class throws a CannotBeExtendedError. This class is useful\n * in scenarios like testing, dynamic behavior adjustments, or managing complex\n * object configurations.\n */\nexport class Extension extends Patch {\n    /**\n     * Constructs a new Extension instance. This constructor initializes the extension\n     * by determining the target key and value for the extension and ensuring that\n     * the property to be extended is configurable and writable. It throws an error\n     * if these conditions are not satisfied. The constructor leverages the Patch\n     * class's functionalities to manage the extension effectively.\n     *\n     * @param {Function|string} keyClassOrFn - The key, class, or function to be\n     * used for the extension. If a function or class is provided, its name is used\n     * as the key.\n     * @param {*} value - The value or method to be used for the extension.\n     * @param {object} [owner=globalThis] - The object to which the extension will\n     * be applied.\n     * @param {object} [options={}] - Additional options for the extension behavior.\n     * @throws {CannotBeExtendedError} If the target property is not writable or\n     * configurable.\n     * @throws {MissingOwnerValue} If the `keyClassOrFn` value is null or there\n     * is an error determining the key and extension values, MissingOwnerValue is\n     * thrown.\n     */\n    constructor(keyClassOrFn, value, owner = globalThis, options = {}) {\n        let { key, extension, valid } = Extension.determineInput(keyClassOrFn);\n        extension = value || extension;\n        if (!valid) {\n            throw new MissingOwnerValue(owner, key);\n        }\n        const descriptor = Object.getOwnPropertyDescriptor(owner, key);\n        if (descriptor) {\n            if ((Reflect.has(descriptor, 'writable') && !descriptor.writable) ||\n                (Reflect.has(descriptor, 'configurable') && !descriptor.configurable)) {\n                throw new CannotBeExtendedError(owner, key);\n            }\n        }\n        super(owner, { [key]: extension }, options);\n        this.key = key;\n    }\n    /**\n     * Determines the input type for the extension. This method processes the input\n     * and identifies the key for the extension and the associated value or method.\n     * It supports inputs as either a string key or a function/class, providing\n     * flexibility in defining extensions.\n     *\n     * @param {Function|string} keyClassOrFn - The key, class, or function provided\n     * as input. If a function or class is provided, its name is used as the key.\n     * containing the determined key, the extension value/method, and a validity flag\n     * indicating whether the input is usable.\n     * @returns {{key: string|null, extension: *|null, valid: boolean}} An object\n     */\n    static determineInput(keyClassOrFn) {\n        let input = { key: null, extension: null, valid: false };\n        if (keyClassOrFn instanceof Function) {\n            input = { key: keyClassOrFn.name, extension: keyClassOrFn, valid: true };\n        }\n        else if (typeof keyClassOrFn === 'string' || keyClassOrFn instanceof String) {\n            input = { key: keyClassOrFn, extension: null, valid: true };\n        }\n        return input;\n    }\n    /**\n     * Custom inspect function for Node.js that provides a formatted representation\n     * of the Extension instance, primarily for debugging purposes.\n     *\n     * @param {number} depth The depth to which the object should be formatted.\n     * @param {object} options Formatting options.\n     * @param {function} inspect The inspection function to format the object.\n     * @returns {string} A formatted string representing the Extension instance.\n     */\n    [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n        return `Extension<${this.key}>`;\n    }\n    /**\n     * Custom getter for the toStringTag symbol. Provides the class name when the\n     * object is converted to a string, typically used for debugging and logging.\n     *\n     * @returns {string} The class name of the Extension instance.\n     */\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n", "import { Patch } from '@nejs/extension'\n\n/**\n * The `FunctionExtensions` class is a patch applied to the built-in JavaScript `Function`\n * constructor. It extends `Function` with additional utility methods for determining the\n * specific type or nature of function-like objects. These methods allow developers to\n * distinguish between classes, regular functions, async functions, and arrow functions\n * in a more intuitive and straightforward manner. This class is part of the `@nejs/extension`\n * library and enhances the capabilities of function handling and introspection in JavaScript.\n */\nexport const FunctionExtensions = new Patch(Function, {\n  /**\n   * Determines if a given value is a class. It checks if the value is an instance of\n   * `Function` and if its string representation includes the keyword 'class'. This method\n   * is useful for distinguishing classes from other function types in JavaScript.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is a class, otherwise `false`.\n   */\n  isClass(value) {\n    return value instanceof Function && String(value).includes('class');\n  },\n\n  /**\n   * Checks if a given value is a regular function. This method verifies if the value is\n   * an instance of `Function`, which includes regular functions, classes, and async\n   * functions but excludes arrow functions.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is a regular function, otherwise `false`.\n   */\n  isFunction(value) {\n    return value instanceof Function;\n  },\n\n  /**\n   * Determines if a given value is an asynchronous function. It checks if the value is an\n   * instance of `Function` and if its string representation includes the keyword 'Async'.\n   * This method is particularly useful for identifying async functions.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is an async function, otherwise `false`.\n   */\n  isAsync(value) {\n    const stringTag = /(\\w+)]/g.exec(Object.prototype.toString.call(value))[1]\n    return (\n      value instanceof Function &&\n      stringTag.includes('Async')\n    )\n  },\n\n  /**\n   * Checks if a given value is an arrow function. It verifies if the value is an instance\n   * of `Function`, if its string representation includes the '=>' symbol, and if it lacks\n   * a prototype, which is a characteristic of arrow functions in JavaScript.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is an arrow function, otherwise `false`.\n   */\n  isBigArrow(value) {\n    return (\n      value instanceof Function &&\n      String(value).includes('=>') &&\n      !String(value).startsWith('bound') &&\n      !Reflect.has(value, 'prototype')\n    );\n  },\n\n  /**\n   * Determines if a given value is a bound function. Bound functions are created using\n   * the `Function.prototype.bind` method, which allows setting the `this` value at the\n   * time of binding. This method checks if the value is an instance of `Function`, if\n   * its string representation starts with 'bound', and if it lacks a `prototype`\n   * property. These characteristics are indicative of bound functions in JavaScript.\n   *\n   * @param {*} value - The value to be checked, typically a function.\n   * @returns {boolean} Returns `true` if the value is a bound function, otherwise\n   * `false`. Bound functions have a specific format in their string representation\n   * and do not have their own `prototype` property.\n   */\n  isBound(value) {\n    return (\n      value instanceof Function &&\n      String(value).startsWith('bound') &&\n      !Reflect.has(value, 'prototype')\n    )\n  },\n})\n", "import { Patch } from '@nejs/extension';\n\n/**\n * `ObjectExtensions` is a patch for the JavaScript built-in `Object` class. It\n * adds utility methods to the `Object` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `Object` class with additional\n * utility functions.\n */\nexport const ObjectExtensions = new Patch(Object, {\n  /**\n   * Checks if the given value is a valid key for an object. In JavaScript, a valid\n   * key can be either a string or a symbol. This method is useful for validating\n   * object keys before using them in operations like setting or getting object properties.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} - Returns `true` if the value is a valid object key (string or symbol),\n   *                      otherwise `false`.\n   */\n  isValidKey(value) {\n    return (typeof value === 'string' || typeof value === 'symbol');\n  },\n\n  /**\n   * Determines if the provided value is an object. This method checks whether the\n   * value is an instance of `Object` or if its type is 'object'. It's a utility\n   * method for type-checking, ensuring that a value is an object before performing\n   * operations that are specific to objects.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} - Returns `true` if the value is an object, otherwise `false`.\n   */\n  isObject(value) {\n    return value && (value instanceof Object || typeof value === 'object');\n  },\n\n  /**\n   * Retrieves the string tag of an object. The string tag is a representation of\n   * the object's type, as defined by its `Object.prototype.toString` method. This\n   * utility method is helpful for getting a more descriptive type of an object than\n   * what is returned by the `typeof` operator, especially for custom objects.\n   *\n   * @param {*} value - The object whose string tag is to be retrieved.\n   * @returns {string} - The string tag of the object, indicating its type.\n   */\n  getStringTag(value) {\n    return /\\s(.+)]/.exec(Object.prototype.toString.call(value))[1];\n  },\n\n  /**\n   * Strips an object down to only the keys specified. Optionally, any\n   * accessors can be made to retain their context on the source object.\n   *\n   * @param {object} object the object to pare down\n   * @param {Array<string|symbol>} keys the keys that should appear in the\n   * final reduced object\n   * @param {boolean} [bindAccessors = true] if this value is true\n   * then any accessors from the source object will continue to have their\n   * `this` value bound to the source. If the getter or setter on that object\n   * is defined using an arrow function, this will not work as intended.\n   * @returns {object} an object containing only the keys and symbols specified\n   * in the `keys` parameter.\n   */\n  stripTo(object, keys, bindAccessors = true) {\n    const result = {}\n\n    if (!Array.isArray(keys)) {\n      return result\n    }\n\n    for (let key of keys) {\n      if (Reflect.has(object, key)) {\n        const descriptor = Object.getOwnPropertyDescriptor(object, key)\n        if (Reflect.has(descriptor, 'get') || Reflect.has(descriptor, 'set')) {\n          if (bindAccessors) {\n            descriptor.get = descriptor?.get?.bind(object)\n            descriptor.set = descriptor?.set?.bind(object)\n          }\n          Object.defineProperty(result, descriptor)\n        }\n        else {\n          Object.defineProperty(result, descriptor)\n        }\n      }\n    }\n\n    return result\n  },\n\n  /**\n   * Determines the type of the given value based on its string tag. This method\n   * uses `Object.getStringTag` to obtain the string tag of the value, which\n   * represents its more specific type (e.g., Array, Map, Set) rather than just\n   * 'object'. The method then maps this string tag to the corresponding type\n   * present in the provided `owner` object, which defaults to `globalThis`.\n   * This utility method is especially useful for identifying the specific\n   * constructor or class of an object, beyond the basic types identified by\n   * the `typeof` operator.\n   *\n   * @param {any} value - The value whose type is to be determined.\n   * @param {object} [owner=globalThis] - The object in which to look up the\n   * constructor corresponding to the string tag. Defaults to `globalThis`, which\n   * covers global constructors like `Array`, `Object`, etc.\n   * @returns {Function|object|null|undefined} - Returns the constructor or type\n   * of the value based on its string tag. For 'Null' and 'Undefined', it returns\n   * `null` and `undefined`, respectively. For other types, it returns the\n   * corresponding constructor (e.g., `Array` for arrays) if available in the\n   * `owner` object.\n   */\n  getType(value, owner = globalThis) {\n    const stringTag = Object.getStringTag(value)\n\n    switch (stringTag) {\n      case 'Null': return null\n      case 'Undefined': return undefined\n      default:\n        return owner[stringTag]\n    }\n  },\n});\n", "import { Patch } from '@nejs/extension'\nimport { ObjectExtensions } from './objectextensions.js'\n\n/**\n * The `ReflectExtensions` class is a patch applied to the built-in JavaScript\n * `Reflect` object. It extends `Reflect` with additional utility methods that\n * enhance its capabilities. These methods provide more advanced ways of\n * interacting with object properties, such as checking for the presence of\n * multiple keys at once (`hasAll`) or verifying if at least one specified key\n * exists in an object (`hasSome`). This class is part of the `@nejs/extension`\n * library and is designed to offer these extended functionalities in a way\n * that is consistent with the existing `Reflect` API, making it intuitive for\n * developers who are already familiar with standard reflection methods in\n * JavaScript.\n */\nexport const ReflectExtensions = new Patch(Reflect, {\n  /**\n   * The function checks if an object has all the specified keys.\n   *\n   * @param object - The `object` parameter is the object that we want to\n   * check if it has all the specified keys.\n   * @param keys - The `keys` parameter is a rest parameter, which means\n   * it can accept any number of arguments. In this case, it is expected\n   * to receive multiple keys as arguments.\n   * @returns a boolean value.\n   */\n  hasAll(object, ...keys) {\n    return Object.isObject(object) && (keys.flat(Infinity)\n      .map(key => Reflect.has(object, key))\n      .every(has => has)\n    )\n  },\n\n  ownDescriptors(object) {\n    const result = {}\n    const revertOnDone = () => revertOnDone.doIt ? ObjectExtensions.revert() : ''\n    revertOnDone.doIt = false\n\n    if (!Object.isObject) {\n      revertOnDone.doIt = true\n      ObjectExtensions.apply()\n    }\n\n    if (!Object.isObject(object)) {\n      revertOnDone()\n      return {}\n    }\n\n    const keys = Reflect.ownKeys(object)\n\n    for (const key of keys) {\n      result[key] = Object.getOwnPropertyDescriptor(key)\n    }\n\n    revertOnDone()\n\n    return result\n  },\n\n  /**\n   * The function checks if an object has at least one of the specified keys.\n   *\n   * @param object - The `object` parameter is the object that we want to check\n   * for the presence of certain keys.\n   * @param keys - The `keys` parameter is a rest parameter, which means it can\n   * accept any number of arguments. These arguments are the keys that we want\n   * to check if they exist in the `object`.\n   * @returns The function `hasSome` returns a boolean value indicating whether\n   * at least one of the keys provided as arguments exists in the given object.\n   */\n  hasSome(object, ...keys) {\n    return Object.isObject(object) && (keys.flat(Infinity)\n      .map(key => Reflect.has(object, key))\n      .some(has => has)\n    )\n  },\n\n  /**\n   * Retrieves an array of [key, descriptor] pairs for each property of the\n   * provided object. This method is akin to `Object.entries` but includes\n   * property descriptors instead of the property values. It's useful for cases\n   * where you need detailed information about properties, including their\n   * configurability, enumerability, and accessors.\n   *\n   * @param {object} object - The object whose property entries are to be\n   * retrieved.\n   * @returns {Array} An array of [key, descriptor] pairs, where each pair\n   * consists of the property name (key) and its descriptor. Returns an empty\n   * array if the input is not a valid object.\n   */\n  entries(object) {\n    if (!object || typeof object !== 'object') { return [] }\n\n    return Reflect.ownKeys(object).map(key => [\n      key, Object.getOwnPropertyDescriptor(object, key)\n    ])\n  },\n\n  /**\n   * Retrieves an array of values from the property descriptors of the given\n   * object. This method works similarly to `Object.values` but operates on\n   * property descriptors instead. It's useful when you need the values of\n   * properties including getters, setters, and other descriptor-specific\n   * attributes.\n   *\n   * @param {object} object - The object whose property values are to be\n   * retrieved.\n   * @returns {Array} An array of values extracted from the object's property\n   * descriptors. The values correspond to the `value` attribute in each\n   * property's descriptor. Returns an empty array if the input is not a valid\n   * object.\n   */\n  values(object) {\n    return Reflect.entries.map(([,value]) => value)\n  }\n})\n", "import { Patch } from '@nejs/extension';\n\n/**\n * `StringExtensions` is a patch for the JavaScript built-in `String` class. It\n * adds utility methods to the `String` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `String` class with additional\n * utility functions.\n */\nexport const StringExtensions = new Patch(String, {\n  /**\n   * The `isString` method does exactly what one would it expect. It returns\n   * true if the string matches typeof or instanceof as a string.\n   *\n   * @param {*} value checks to see if the `value` is a string\n   * @returns {boolean} `true` if it is a `String`, `false` otherwise\n   */\n  isString(value) {\n    if (value && (typeof value === 'string' || value instanceof String)) {\n      return value.length > 0\n    }\n    return false\n  },\n});\n", "import { Patch } from '@nejs/extension';\n\n/**\n * `SymbolExtensions` is a patch for the JavaScript built-in `Symbol` class. It\n * adds utility methods to the `Symbol` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `Symbol` class with additional\n * utility functions.\n */\nexport const SymbolExtensions = new Patch(Symbol, {\n  /**\n   * The `isSymbol` method does exactly what one would it expect. It returns\n   * true if the string matches typeof or instanceof as a symbol.\n   *\n   * @param {*} value checks to see if the `value` is a string\n   * @returns {boolean} `true` if it is a `Symbol`, `false` otherwise\n   */\n  isSymbol(value) {\n    if (value && (typeof value === 'symbol')) {\n      return true\n    }\n    return false\n  },\n});\n", "import { Patch } from '@nejs/extension'\n\n/**\n * The `ArrayPrototypeExtensions` patch extends the prototype of the built-in\n * JavaScript `Array` with additional properties for convenience and improved\n * readability. By applying this patch, all array instances gain new getter\n * properties `first` and `last`, which provide quick access to the first and\n * last elements of the array, respectively. This enhancement simplifies common\n * operations on arrays and makes code more expressive and concise.\n */\nexport const ArrayPrototypeExtensions = new Patch(Array.prototype, {\n  /**\n   * Sometimes defining even a short function for the invocation of `find`\n   * can be troublesome. This helper function performs that job for you. If\n   * the specified element is in the array, `true` will be returned.\n   *\n   * @param {*} value the value to search for. This value must triple equals\n   * the array element in order to return true.\n   * @returns true if the exact element exists in the array, false otherwise\n   */\n  contains(value) {\n    return !!this.find(entry => entry === value)\n  },\n\n  /**\n   * The `findEntry` function searches the entries of the object and returns\n   * the `[index, value]` entry array for the first matching value found.\n   *\n   * @param {function} findFn a function that takes the element to be checked\n   * and returns a boolean value\n   * @returns if `findFn` returns `true`, an array with two elements, the first\n   * being the index, the second being the value, is returned.\n   */\n  findEntry(findFn) {\n    const entries = this.entries()\n    const VALUE = 1\n\n    for (let entry of entries) {\n      if (findFn(entry[VALUE])) {\n        return entry\n      }\n    }\n\n    return undefined\n  },\n\n  /**\n   * A getter property that returns the first element of the array. If the\n   * array is empty, it returns `undefined`. This property is useful for\n   * scenarios where you need to quickly access the first item of an array\n   * without the need for additional checks or method calls.\n   *\n   * @returns {*} The first element of the array or `undefined` if the array\n   * is empty.\n   */\n  get first() {\n    return this[0];\n  },\n\n  /**\n   * A getter property that returns the last element of the array. It\n   * calculates the last index based on the array's length. If the array is\n   * empty, it returns `undefined`. This property is beneficial when you need\n   * to access the last item in an array, improving code readability and\n   * avoiding manual index calculation.\n   *\n   * @returns {*} The last element of the array or `undefined` if the\n   * array is empty.\n   */\n  get last() {\n    return this[this.length - 1];\n  },\n\n})"],
  "mappings": "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",
  "names": ["src_exports", "__export", "ArrayPrototypeExtensions", "FunctionExtensions", "ObjectExtensions", "ReflectExtensions", "StringExtensions", "SymbolExtensions", "disableAll", "enableAll", "typeOf", "o", "CannotBeExtendedError", "owner", "key", "typeOf", "o", "MissingOwnerValue", "owner", "key", "PatchToggle", "patch", "preventRevert", "depth", "options", "inspect", "objName", "status", "Patch", "_Patch", "owner", "patches", "options", "key", "#PatchEntry", "patch", "preventRevert", "PatchToggle", "e", "property", "owningObject", "depth", "inspect", "Extension", "_Extension", "Patch", "keyClassOrFn", "value", "owner", "options", "key", "extension", "valid", "MissingOwnerValue", "descriptor", "CannotBeExtendedError", "input", "depth", "inspect", "FunctionExtensions", "Patch", "value", "stringTag", "ObjectExtensions", "Patch", "value", "object", "keys", "bindAccessors", "result", "key", "descriptor", "owner", "stringTag", "ReflectExtensions", "Patch", "object", "keys", "key", "has", "result", "revertOnDone", "ObjectExtensions", "value", "StringExtensions", "Patch", "value", "SymbolExtensions", "Patch", "value", "ArrayPrototypeExtensions", "Patch", "value", "entry", "findFn", "entries", "VALUE", "Owners", "enableAll", "owners", "owner", "Patch", "disableAll"]
}
