var nejsBasicExtensions=(()=>{var M=Object.defineProperty;var ft=Object.getOwnPropertyDescriptor;var pt=Object.getOwnPropertyNames;var ht=Object.prototype.hasOwnProperty;var dt=(r,t)=>{for(var e in t)M(r,e,{get:t[e],enumerable:!0})},yt=(r,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of pt(t))!ht.call(r,n)&&n!==e&&M(r,n,{get:()=>t[n],enumerable:!(s=ft(t,n))||s.enumerable});return r};var bt=r=>yt(M({},"__esModule",{value:!0}),r);var vt={};dt(vt,{Controls:()=>g,Extensions:()=>A,GlobalFunctionsAndProps:()=>w,InstancePatches:()=>O,Patches:()=>k,StaticPatches:()=>j,all:()=>ut,default:()=>Tt});var gt=r=>/(\w+)]/.exec(Object.prototype.toString.call(r))[1],P=class extends Error{constructor(t,e){super(`${gt(t)} disallows tampering with ${e}.`),Object.assign(this,{owner:t,key:e})}get[Symbol.toStringTag](){return this.constructor.name}};var mt=r=>/(\w+)]/.exec(Object.prototype.toString.call(r))[1],R=class extends Error{constructor(t,e){super(`${mt(t)} does not have a property named '${e}'.`),Object.assign(this,{owner:t,key:e})}get[Symbol.toStringTag](){return this.constructor.name}};var T=class{constructor(t,e=!1){this.started=!1,this.preventRevert=e,this.patch=t,this.patchName=t.owner?.name??t.owner?.constructor?.name??/(\w+)]/.exec(Object.prototype.toString.call(t.owner))[1],this.state={needsApplication:!1,needsReversion:!1}}start(){return this.started||(this.state.needsApplication=!this.patch.applied,this.state.needsReversion=this.patch.applied,this.started=!0,this.state.needsApplication&&this.patch.apply()),this}stop(){return this.started&&((this.preventRevert||this.patch.applied)&&this.patch.revert(),this.state.needsApplication=!1,this.state.needsReversion=!1,this.started=!1),this}get[Symbol.toStringTag](){return`${this.constructor.name}:${this.patchName}`}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){let n=this[Symbol.toStringTag],i=`(started: ${this.started} needed: ${this.state.needsApplication})`;return s(`${n} ${i}`,{...e,depth:t})}};var S=class{constructor(t,e=globalThis,s=void 0,n={}){let i=l=>l==null,o=(l,f=["string","symbol"])=>!i(l)&&!!f.find(m=>m===typeof l),c=l=>o(l,["object"]);if(!o(t))throw console.error("Property",t,`(type: ${typeof t})`,"owningObject",e,`(type: ${typeof e})`,"condition",s,`(type: ${typeof s})`),new TypeError("Property must be non-null and either a string or symbol");if(!c(e))throw new TypeError("Cannot create Patch entry as owning object is invalid");let u={...Object.getOwnPropertyDescriptor(e,t),...Object(n)};Object.assign(this,{key:t,descriptor:u,owner:e,condition:typeof s=="function"?s:void 0})}get computed(){return this.isAccessor?this.descriptor.get.bind(this.owner).call():this.descriptor.value}get isData(){return Reflect.has(this.descriptor,"value")}get isAccessor(){return Reflect.has(this.descriptor,"get")}get isReadOnly(){return Reflect.has(this.descriptor,"configurable")&&!this.descriptor.configurable||Reflect.has(this.descriptor,"writable")&&!this.descriptor.writable}get isAllowed(){return this.condition&&typeof this.condition=="function"?this.condition():!0}applyTo(t,e=!1){let s={...this.descriptor};e&&(typeof s.get=="function"&&(s.get=s.get.bind(this.owner)),typeof s.set=="function"&&(s.set=s.set.bind(this.owner))),Object.defineProperty(t,this.key,s)}get[Symbol.toStringTag](){return this.constructor.name}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){let n=this.isData?" Data":" Accessor",i=this.isReadOnly?" [ReadOnly]":"";return`PatchEntry<${this.key}${n}${i}>`}};var a=class r{patchConflicts=Object.create(null);patchEntries=Object.create(null);patchesOwner=void 0;patchCount=0;patchesApplied=0;constructor(t,e,s=Object.create(null)){Object.assign(this,{owner:t,options:s}),this.patchesOwner=r.constructWithStore(e,this),this.generatePatchEntries(this.patchesOwner),r.patches.has(t)||r.patches.set(t,[]),r.patches.get(t).push(this)}generatePatchEntries(t,e=void 0){let s=this?.options.condition;Reflect.ownKeys(t).forEach(n=>{let i=this?.options?.conditions?.[n]??s;try{let o=e??r.getDescriptorOverridesFromSymbol(n),c=t;if(r.isKnownPatchSymbol(n)){c=r.constructWithStore(t[n],this,n),t[n]=c,this.generatePatchEntries(c,o);return}this.patchEntries[n]=new S(n,t,i,e),this.patchCount+=1}catch(o){console.error(`Failed to process patch for ${String(n)}
`,o)}if(Reflect.has(this.owner,n))try{this.patchConflicts[n]=new S(n,this.owner)}catch(o){console.error(`Cannot capture conflicting patch key ${n}
`,o)}})}get entries(){return Reflect.ownKeys(this.patchEntries).map(t=>[t,this.patchEntries[t]])}get appliedEntries(){return Reflect.ownKeys(this.patchEntries).filter(t=>this.patchState.get(t)===!0).map(t=>[t,this.patchEntries[t]])}get unappliedEntries(){return Reflect.ownKeys(this.patchEntries).filter(t=>this.patchState.get(t)===!1).map(t=>[t,this.patchEntries[t]])}get patches(){return this.entries.reduce((t,[e,s])=>(t[e]=s.computed,t),Object.create(null))}get appliedPatches(){return this.entries.reduce((t,[e,s])=>(this.patchState.get(e)===!0&&(t[e]=s.computed),t),Object.create(null))}get unappliedPatches(){return this.entries.reduce((t,[e,s])=>(this.patchState.get(e)===!1&&(t[e]=s.computed),t),Object.create(null))}get patchKeys(){return this.entries.map(([t,e])=>t)}get conflicts(){return Reflect.ownKeys(this.patchConflicts).map(t=>[t,this.patchConflicts[t]])}get applied(){return this.patchesApplied>0}get isPartiallyPatched(){return this.applied}get isFullyPatched(){return this.patchCount==this.patchesApplied}apply(t){let e=this.entries,s={patches:e.length,applied:0,errors:[],notApplied:e.length};this.patchState.clear(),e.forEach(([,n])=>{if(n.isAllowed){Object.defineProperty(this.owner,n.key,n.descriptor);let i=Object.getOwnPropertyDescriptor(this.owner,n.key);this.#t(i,n.descriptor)?(s.applied+=1,s.notApplied-=1,this.patchState.set(n,!0)):(s.errors.push([n,new Error(`Could not apply patch for key ${n.key}`)]),this.patchState.set(n,!1))}else this.patchState.set(n,!1)}),this.patchesApplied=s.applied,typeof t=="function"&&t(s)}createToggle(t=!1){return new T(this,t)}revert(t){if(!this.applied)return;let e=this.entries,s=this.conflicts,n={patches:e.length,reverted:0,restored:0,conflicts:s.length,errors:[],stillApplied:0};e.forEach(([,i])=>{delete this.owner[i.key]?(this.patchesApplied-=1,n.reverted+=1,this.patchState.set(i,!1)):n.errors.push([i,new Error(`Failed to revert patch ${i.key}`)])}),s.forEach(([,i])=>{Object.defineProperty(this.owner,i.key,i.descriptor);let o=Object.getOwnPropertyDescriptor(this.owner,i.key);this.#t(i.descriptor,o)?n.restored+=1:n.errors.push([i,new Error(`Failed to restore original ${i.key}`)])}),n.stillApplied=this.patchesApplied,typeof t=="function"&&t(n)}release(){let t=r.patches.get(this.owner);t.splice(t.find(e=>e===this),1)}owner=null;options=null;patchState=new Map;[Symbol.iterator](){return this.entries.values()}#t(t,e){return!t||!e?!1:t.configurable===e.configurable&&t.enumerable===e.enumerable&&t.value===e.value&&t.writable===e.writable&&t.get===e.get&&t.set===e.set}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){let n={get quotes(){return/^(\x1B\[\d+m)?['"]|["'](\x1B\[\d+m)?$/g},get arrays(){return/^(\x1B\[\d+m)?\[ | \](\x1B\[\d+m)?$/g}},i={...e,depth:t},o=this.owner?.name??"",c=o.length?`[${s(o,e).replaceAll(n.quotes,"$1$2")}]`:"",u=s(this.patchKeys,i).replaceAll(n.arrays,"$1$2").replaceAll(/'(.*?)'/g,"$1");return`${this.constructor.name}${c} { ${u} }`}static patches=new Map;static enableFor(t){if(r.patches.has(t))for(let e of r.patches.get(t))e.apply()}static disableFor(t){if(r.patches.has(t))for(let e of r.patches.get(t))e.revert()}static get applied(){return this.#e(globalThis,!0)}static get known(){return this.#e(globalThis,!1)}static get use(){return this.#e(globalThis,!1,!0)}static get lazy(){return this.#e(globalThis,!1,!1,!0)}static scopedTo(t){let e=(s,n,i=!1,o=!1)=>this.#e(s,n,i,o);return{get applied(){return e(t,!0,!1)},get known(){return e(t,!1,!1)},get use(){return e(t,!1,!0)},get lazy(){return e(t,!1,!1,!0)}}}static#e(t,e,s=!1,n=!1){return[...r.patches.values()].flat().filter(i=>i.owner===t).reduce((i,o)=>{for(let[,c]of o.entries)if(!(e&&o.patchState.get(c)!==!0)){if(s){i[c.key]=async u=>{if(typeof u!="function")return;let l=Object.prototype.toString.call(u),f=o.createToggle();f.start(),l==="[object AsyncFunction]"?await u(c.computed,c):u(c.computed,c),f.stop()};continue}if(n){Object.defineProperty(i,c.key,{get(){return o.apply(),c.computed},enumerable:!0,configurable:!0});continue}if(c.isAccessor){let u=`applyAccessorFor_${String(c.key)}`,l={[u](f){return c.applyTo(f),f}};i[c.key]=l[u]}else c.applyTo(i)}return i},Object.create(null))}static get CustomInspect(){return Symbol.for("nodejs.util.inspect.custom")}static stripExtras(t){return t.replaceAll(/^(\x1B\[\d+m)?[\[\{]\s?|\s?[\]\}](\x1B\[\d+m)?$/gm,"$1$2").replaceAll(/['"](.*?)['"]/gm,"$1")}static get kMutablyHidden(){return Symbol.for('{"enumerable":false,"configurable":true}')}static mutablyHidden(t,e=Object.create(null)){return this.customDescriptorPatch(t,this.kMutablyHidden,e)}static get kMutablyVisible(){return Symbol.for('{"enumerable":true,"configurable":true}')}static mutablyVisible(t,e=Object.create(null)){return this.customDescriptorPatch(t,this.kMutablyVisible,e)}static get kImmutablyHidden(){return Symbol.for('{"enumerable":false,"configurable":false}')}static immutablyHidden(t,e=Object.create(null)){return this.customDescriptorPatch(t,this.kImmutablyHidden,e)}static get kImmutablyVisible(){return Symbol.for('{"enumerable":true,"configurable":false}')}static immutablyVisible(t,e=Object.create(null)){return this.customDescriptorPatch(t,this.kImmutablyVisible,e)}static customDescriptorPatch(t,e,s=Object.create(null)){return!this.stores.has(t)&&(this.stores.set(t,s),r.isKnownPatchSymbol(e))?(s[e]=Object.create(null),this.stores.get(t)[e]):this.stores.get(t)}static isKnownPatchSymbol(t){return typeof t=="symbol"?[this.kImmutablyHidden,this.kImmutablyVisible,this.kMutablyHidden,this.kMutablyVisible].some(e=>e===t):!1}static constructWithStore(t,e,s,n=Object.create(null)){if(typeof t!="function")return t;try{let i=r.customDescriptorPatch(e,s,n);return t(i)}catch(i){return console.error(i),t}}static getDescriptorOverridesFromSymbol(t){let e=Object.create(null);return this.isKnownPatchSymbol(t)&&(e=JSON.parse(t.description)),e}static stores=new WeakMap};var St=["number","boolean","bigint","string","symbol"],p=class r extends a{constructor(t,e,s=globalThis,n={}){let i=r.determineInput(t),{key:o,extension:c,valid:u}=i;if(c=e||c,!u)throw new R(s,o);let l=Object.getOwnPropertyDescriptor(s,o);if(l&&(Reflect.has(l,"writable")&&!l.writable||Reflect.has(l,"configurable")&&!l.configurable))throw new P(s,o);super(s,{[o]:c},n),this.key=o,this.class=i.class,this.function=i.function}get isFunction(){return!!this.function}get isClass(){return!!this.class}get isPrimitive(){return~St.indexOf(typeof this.value)}get isObject(){return Object(this.value)===this.value}static get applied(){return a.applied}static get known(){return a.known}static get use(){return a.use}static get lazy(){return a.lazy}static scopedTo(t){return a.scopedTo(t)}static determineInput(t){let e={key:null,extension:null,valid:!1};return t instanceof Function?(e={key:t.name,extension:t,valid:!0},/^class .*/.exec(t.toString())&&(e.class=t),/^(async )?function .*/.exec(t.toString())&&(e.function=t)):(typeof t=="string"||t instanceof String)&&(e={key:t,extension:null,valid:!0}),e}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){let n={get braces(){return/^(\x1B\[\d+m)?[\[\{]|[\]\}](\x1B\[\d+m)?$/g},get quotes(){return/^(\x1B\[\d+m)?['"]|["'](\x1B\[\d+m)?$/g}},i=s(this.key,e).replaceAll(n.quotes,"$1$2"),o=s(this.patches[this.key],e).replaceAll(n.braces,"$1$2");return`Extension[${i}:${o}]`}get[Symbol.toStringTag](){return this.constructor.name}static createSet(t,...e){return new r.ExtensionSet(t,...e)}static ExtensionSet=class{constructor(e,...s){this.name=e,this.extensionObjects=new Set,this.extensions=new Set;for(let n of s)n instanceof r?(this.extensions.add(n),this.extensionObjects.add(n.patches[n.key])):n instanceof Function&&(this.extensionObjects.add(n),this.extensions.add(new r(n)))}apply(){for(let e of this.extensions)e.apply()}revert(){for(let e of this.extensions)e.revert()}}};var d=new a(Object,{isNullDefined(r){return r==null},hasStringTag(r){return Object.isObject(r)&&Reflect.has(r,Symbol.toStringTag)},getStringTag(r,t=!1){if(Object.hasStringTag(r))return r[Symbol.toStringTag];if(!t)return r&&typeof r=="function"?r.name:/\s(.+)]/.exec(Object.prototype.toString.call(r))[1]},getType(r,t=globalThis){let e=Object.getStringTag(r);switch(e){case"Null":return null;case"Undefined":return;default:return t[e]}},isObject(r){return r&&(r instanceof Object||typeof r=="object")},isPrimitive(r){if(r===null)return!0;switch(typeof r){case"string":case"number":case"bigint":case"boolean":case"undefined":case"symbol":return!0;default:return!1}},isValidKey(r){return typeof r=="string"||typeof r=="symbol"},stripTo(r,t,e=!0){if(!r||typeof r!="object")throw new TypeError("Object.stripTo requires an object to strip. Received",r);let s={};if(!Array.isArray(t))return s;for(let n of t)if(Reflect.has(r,n)){let o={...Object.getOwnPropertyDescriptor(r,n)};(typeof o.get=="function"||typeof o.set=="function")&&e&&(o.get=o.get?.bind(r),o.set=o.set?.bind(r)),Object.defineProperty(s,n,o)}return s}}),Z=d.patches,_=new a(Object.prototype,{[a.kMutablyHidden](r){return{get hasStringTag(){return Z.hasStringTag(this)},getStringTag(t=!1){return Z.getStringTag(this,t)},stripTo(t,e=!0){return Object.stripTo(this,t,e)}}}});var{getStringTag:tt}=d.patches,$=new a(Function,{isAsync(r){let t=/(\w+)]/g.exec(Object.prototype.toString.call(r))[1];return r instanceof Function&&t.includes("Async")},isAsyncGenerator(r){let t=tt(r);return r instanceof Function&&t=="AsyncGeneratorFunction"},isBigArrow(r){return r instanceof Function&&String(r).includes("=>")&&!String(r).startsWith("bound")&&!Reflect.has(r,"prototype")},isBound(r){return r instanceof Function&&String(r).startsWith("bound")&&!Reflect.has(r,"prototype")},isClass(r){return r instanceof Function&&!!/^class\s/.exec(String(r))},isFunction(r){return r instanceof Function&&!Function.isClass(r)},isGenerator(r){let t=tt(r);return r instanceof Function&&t=="GeneratorFunction"}}),et=new a(Function.prototype,{[a.kMutablyHidden]:{get isAsync(){return Function.isAsync(this)},get isAsyncGenerator(){return Function.isAsyncGenerator(this)},get isBigArrow(){return Function.isBigArrow(this)},get isBound(){return Function.isBound(this)},get isClass(){return Function.isClass(this)},get isFunction(){return Function.isFunction(this)},get isGenerator(){return Function.isGenerator(this)}}});var rt=new a(Map.prototype,{[a.kMutablyHidden]:{getKey(r,t=!0){for(let[e,s]of this)return t&&r===s&&!t&&r==s?e:null}}});var st=new a(Set.prototype,{[a.kMutablyHidden]:{concat(...r){for(let t of r){if(typeof t=="string"||!Reflect.has(t,Symbol.iterator)){this.add(t);continue}for(let e of t)this.add(e)}},contains(r){for(let t of this)if(r==t)return!0;return!1},every(r,t){if(typeof r!="function")throw new TypeError(`everyFn must be a function! Received ${String(r)}`);let e=0;for(let s of this)r.call(t,s,NaN,this)&&e++;return e===this.size},find(r,t){if(typeof r!="function")throw new TypeError(`findFn must be a function! Received ${String(r)}`);for(let e of this)if(r.call(t,e,NaN,this))return e},findLast(r,t){if(typeof r!="function")throw new TypeError(`findFn must be a function! Received ${String(r)}`);let e=[];for(let s of this)r.call(t,s,NaN,this)&&e.push(s);if(e.length)return e[e.length-1]},get length(){return this.size},map(r,t){if(typeof r!="function")throw new TypeError(`mapFn must be a function! Received ${String(r)}`);let e=[];for(let s of this)e.push(r.call(t,s,NaN,this));return e},reduce(r,t,e){if(typeof r!="function")throw new TypeError(`reduceFn must be a Function! Received ${String(r)}`);let s=t;for(let n of this)s=r.call(e,s,n,NaN,this);return s},some(r,t){if(typeof r!="function")throw new TypeError(`someFn must be a function! Received ${String(r)}`);for(let e of this)if(r.call(t,e,NaN,this))return!0;return!1}}});var{isObject:nt}=d.patches,D=new a(Reflect,{hasAll(r,...t){return Object.isObject(r)&&t.flat(1/0).map(e=>Reflect.has(r,e)).every(e=>e)},ownDescriptors(r){if(!nt(r))throw new TypeError("The supplied object must be non-null and an object");let t={},e=Reflect.ownKeys(r);for(let s of e)t[s]=Object.getOwnPropertyDescriptor(s);return t},hasSome(r,...t){return nt(r)&&t.flat(1/0).map(e=>Reflect.has(r,e)).some(e=>e)},entries(r){return!r||typeof r!="object"?[]:Reflect.ownKeys(r).map(t=>[t,Object.getOwnPropertyDescriptor(r,t)])},values(r){return Reflect.entries.map(([,t])=>t)}});var xt=["(",")"],it=new a(String,{isString(r){return r&&(typeof r=="string"||r instanceof String)?r.length>0:!1},get parenthesisPair(){return["(",")"]},get squareBracketsPair(){return["[","]"]},get curlyBracketsPair(){return["{","}"]}}),ot=new a(String.prototype,{[a.kMutablyHidden]:{extractSubstring(r=0,t=xt){let[e,s]=t,n=0,i=-1,o=-1,c="",u=0;for(let h=r;h<this.length;h++){let b=this[h];if(b===e)n++,i===-1&&(i=h);else if(b===s&&(n--,n===0)){o=h;break}}let l=[Math.max(0,i-100),i],f=[...this.substring(l[0],l[1])].reverse().join(""),m;try{m=/([^ \,\"\'\`]+)/.exec(f)[1]??"",c=[...m].reverse().join("")}catch{}if(i!==-1&&o!==-1){let h=[i,o+1];return{extracted:this.slice(h[0],h[1]),range:[i,o],newOffset:o+1,leadingToken:c}}else return{extracted:null,range:[i,o],newOffset:r,leadingToken:c}}}});var N=new a(Symbol,{isSymbol(r){return r&&typeof r=="symbol"},isRegistered(r,t=!1){if(!Symbol.isSymbol(r)){if(t)throw new TypeError("allowOnlySymbols specified; value is not a symbol");return!1}return Symbol.keyFor(r)!==void 0},isNonRegistered(r,t=!1){return!Symbol.isRegistered(r,t)}});var ct=new a(Array.prototype,{[a.kMutablyHidden]:{contains(r){return!!this.find(t=>t===r)},findEntry(r){let t=this.entries(),e=1;for(let s of t)if(r(s[e]))return s},get first(){return this[0]},get last(){return this[this.length-1]}}});var{isObject:y,isValidKey:V}=d.patches,{hasSome:B}=D.patches,x=class r{#t=void 0;#e=void 0;constructor(t,e){if((t??e)===void 0?this.#t=r.enigmatic:r.isDescriptor(t)?(this.#t=t,this.#e=y(e)?e:void 0):y(t)&&V(e)&&(this.#t=Object.getOwnPropertyDescriptor(t,e),this.#e=t),!this.isDescriptor)throw console.error(`
      Descriptor(object,key) FAILED:
        object:      ${t===globalThis?"[GLOBAL]":typeof e=="object"?JSON.stringify(t):String(t)}
        key:         ${e===globalThis?"[GLOBAL]":typeof e=="object"?JSON.stringify(e):String(e)}
        descriptor:  `,this.#t),new Error("Not a valid descriptor:",this.#t)}get isAccessor(){return r.isAccessor(this.#t)}get isData(){return r.isData(this.#t)}get isDescriptor(){return r.isDescriptor(this.#t)}get configurable(){return!!this.#t?.configurable}set configurable(t){(this.#t||{}).configurable=!!t}get enumerable(){return this.#t?.enumerable}set enumerable(t){(this.#t||{}).enumerable=t}get writable(){return this.#t?.writable}set writable(t){(this.#t||{}).writable=t}get value(){return this.#t?.value}set value(t){(this.#t||{}).value=t}get get(){return this.#t?.get}get boundGet(){return y(this.#e)?this.get?.bind(this.#e):this.get}set get(t){(this.#t||{}).get=t}get set(){return(this.#t||{}).set}get boundSet(){return y(this.#e)?this.set?.bind(this.#e):this.set}set set(t){(this.#t||{}).set=t}get hasObject(){return y(this.#e)}get object(){return this.#e}set object(t){this.#e=Object(t)}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){return`Descriptor${this.isAccessor?" (Accessor)":this.isData?" (Data)":""} ${s(this.#t,{...e,depth:t})}`}static for(t,e,s=!1){return!y(t)||!V(e)||!Reflect.has(t,e)?null:s?new r(Object.getOwnPropertyDescriptor(t,e)):Object.getOwnPropertyDescriptor(t,e)}applyTo(t,e,s=!1){if(!y(t)||!V(e))throw new Error("Cannot apply descriptor to non-object or invalid key");return Object.defineProperty(t,e,this.toObject(s))}toObject(t=!1){let e={...this.#t};return t&&this.isAccessor&&(this.hasObject?e={...e,get:this.boundGet,set:this.boundSet}:y(t)&&(e={...e,get:this.get?.bind(t),set:this.set?.bind(t)})),e}[Symbol.toPrimitive](t){switch(t){case"string":if(this.isAccessor){let e=Reflect.has(this.#t,"get")?"getter":"",s=Reflect.has(this.#t,"set")?"setter":"";return`Accessor (${e}${e&&s?", ":""}${s})`}else if(this.isData){let e=Reflect.has(this.#t,"value")?"value":"",s=Reflect.has(this.#t,"writable")?"writable":"";return`Data (${e}${e&&s?", ":""}${s})`}break;case"number":return NaN;default:return this.toObject()}}get[Symbol.toStringTag](){return this.constructor.name}static getData(t,e){if(!y(t)||!Reflect.has(t,e))return;let s=r.for(t,e,!0);return s.isData?s.value:null}static getAccessor(t,e){if(!y(t)||!Reflect.has(t,e))return;let s=r.for(t,e,!0);return s.isAccessor?s.get.bind(t)():null}static base(t=!1,e=!1){return{enumerable:t,configurable:e}}static accessor(t,e,{enumerable:s,configurable:n}=r.base()){return{get:t,set:e,enumerable:s,configurable:n}}static data(t,e=!0,{enumerable:s,configurable:n}=r.base()){return{value:t,enumerable:s,writable:e,configurable:n}}static isDescriptor(t){let e=[...r.SHARED_KEYS,...r.ACCESSOR_KEYS,...r.DATA_KEYS];return B(t,e)}static isData(t,e){let n=(typeof t=="object"||t instanceof Object)&&e instanceof String?r.for(t,e):t,{DATA_KEYS:i}=this,o=!1;return B(n,i)&&(o=!0),o}static isAccessor(t,e){let n=t&&e&&(typeof t=="object"||t instanceof Object)&&(e instanceof String||typeof e=="symbol")?r.for(t,e):t,{ACCESSOR_KEYS:i}=this,o=!1;return B(n,i)&&(o=!0),o}static get flexible(){return this.base(!0,!0)}static get enigmatic(){return this.base(!1,!0)}static get intrinsic(){return this.base(!1,!1)}static get transparent(){return this.base(!0,!1)}static get SHARED_KEYS(){return["configurable","enumerable"]}static get ACCESSOR_KEYS(){return["get","set"]}static get DATA_KEYS(){return["value","writable"]}},G=new p(x);var{isClass:wt,isFunction:F}=$.patches,Et=Symbol.for("nodejs.util.inspect.custom"),w=new a(globalThis,{maskAs(r,t,e){let{prototype:s,toPrimitive:n}=GenericMask({...e,prototype:t}),i={configurable:!0,enumerable:!1},o=F(s)?s.prototype:s,c=wt(s)?s:o?.constructor;return!c&&!o?null:(Object.setPrototypeOf(r,o),Object.defineProperties(r,{valueOf:{value(){return String(n("default",r))},...i},[Symbol.toPrimitive]:{value(u){return n(u,r)},...i},[Symbol.toStringTag]:{value:c.name,...i},[Symbol.species]:{get(){return c},...i},[Et]:{...i,value(u,l,f){return f(this[Symbol.toPrimitive](),{...l,depth:u})}}}),r)},maskAsString(r,t,e){return r&&Reflect.has(r,t)?maskAs(r,StringMask(t??"value",e)):null},maskAsNumber(r,t,e){return r&&Reflect.has(r,t)?maskAs(r,NumberMask(t??"value",e)):null},GenericMask({prototype:r,targetKey:t="value",toPrimitive:e}){let s={targetKey:t,toPrimitive:e,prototype:r};return F(e)||(s.toPrimitive=(n,i)=>{let o=i[t],c=typeof o=="number"&&Number.isFinite(o)||typeof o=="string"&&!isNaN(parseFloat(o))&&isFinite(o);switch(n){case"string":return c?String(o):o??String(i);case"number":return c?Number(o):NaN;case"default":default:return c?Number(o):o}}),s},StringMask(r,t){let e={targetKey:r,toPrimitive:t,prototype:String.prototype};return F(t)||(e.toPrimitive=function(n,i){switch(n){case"default":return i[r];case"number":return parseInt(i[r],36);case"string":return String(i[r]);default:return i}}),e},NumberMask(r,t){let e={targetKey:r,toPrimitive:t,prototype:Number.prototype};return F(t)||(e.toPrimitive=function(n,i){switch(n){case"default":return i[r];case"number":return Number(i[r]);case"string":return String(i[r]);default:return i}}),e}});var C=class r extends Set{#t=!1;objectifying(t=!0){return this.objectifyValues=t,this}get objectifyValues(){return this.#t}set objectifyValues(t){this.#t=!!t}add(t){if(this.#t&&(typeof t=="number"||typeof t=="string"||typeof t=="boolean"||typeof t=="bigint")&&(t=Object(t)),typeof t=="symbol"&&Symbol.keyFor(t)!==void 0)throw new TypeError("RefSet cannot accept registered symbols as values");if(typeof t!="object"&&typeof t!="symbol")throw new TypeError("RefSet values must be objects, non-registered symbols, or objectified primitives");if(t==null)throw new TypeError("RefSet values cannot be null or undefined");super.add(new WeakRef(t))}addAll(t){if(!t||typeof t!="object"||!Reflect.has(t,Symbol.iterator))throw new TypeError("The supplied values are either falsey or non-iterable");for(let e of t)this.add(e)}clean(){for(let t of this)t.deref()||this.delete(t);return this}entries(){return Array.from(super.entries()).map(([e,s])=>[s.deref(),s.deref()]).filter(([e,s])=>!!s)}forEach(t,e){let s=this;super.forEach(function(n){let i=n.deref();i&&t.call(e,i,i,s)})}values(){let t=[];for(let e of this){let s=e.deref();s&&t.push(s)}return t}keys(){return this.values()}has(t){if(this.#t)return this.contains(t);for(let e of this.values())if(e===t)return!0;return!1}contains(t){return!!Array.from(this.values()).filter(e=>t==e).length}filter(t,e){let s=[];for(let n of this){let i=n?.deref();i&&t.call(e,i,NaN,this)&&s.push(i)}return s}find(t,e){for(let s of this){let n=s?.deref();if(n&&t.call(e,n,NaN,this))return n}}map(t,e,s,n){let i=[],o=!0,c=!0;for(let u of this){let l=u?.deref();if(l){let f=t.call(e,l,NaN,this);(o||c)&&(this.#e(f)||(o=!1,c&&(c=this.#e(Object(f))))),i.push(f)}}if(s){if(o)return new r(i).objectifying(n?this.objectifyValues:!1);if(c)return new r(i.map(u=>this.#e(u)?u:Object(u))).objectifying()}return i}get[Symbol.toStringTag](){return this.constructor.name}#e(t){return!(typeof t=="symbol"&&Symbol.keyFor(t)===void 0||typeof t!="object"&&typeof t!="symbol"||t==null)}},K=new p(C);var at=new a(WeakRef,{isValidReference(r){return!(typeof r=="symbol"&&Symbol.keyFor(r)===void 0||typeof r!="object"&&typeof r!="symbol"||r==null)}});var v=class{#t=[];constructor(t,...e){t!=null&&typeof t[Symbol.iterator]=="function"?this.#t=[...t,...e]:this.#t=[t,...e]}*[Symbol.iterator](){for(let t of this.#t)yield t}get asArray(){return this.#t}get[Symbol.toStringTag](){return this.constructor.name}static isIterable(t){return Object.prototype.toString.call(t?.[Symbol.iterator])==="[object GeneratorFunction]"}},E=class{#t=void 0;constructor(t,e){if(!t||!Reflect.has(t,Symbol.iterator))throw new TypeError("Value used to instantiate Iterator is not iterable");this.#e=t,this.#r=t[Symbol.iterator](),this.#t=typeof e=="function"?e:void 0}get asArray(){return Array.from(this.#e)}get iterable(){return this.#e}next(){let t=this.#r.next(),e=t;return e.done?{value:void 0,done:!0}:(this.#t&&typeof this.#t=="function"&&(e.value=this.#t(t.value)),{value:e.value,done:!1})}reset(){this.#r=this.#e[Symbol.iterator]()}[Symbol.iterator](){return this}get[Symbol.toStringTag](){return this.constructor.name}#e=null;#r=null},H=new p(v),W=new p(E);var{isObject:jt,isNullDefined:Ot,isValidKey:At}=d.patches,{isRegistered:Pt}=N.patches,{isValidReference:lt}=at.patches,L=class r extends Map{#t=!1;constructor(...t){super(...t)}objectifying(t=!0){return this.objectifyValues=t,this}asObject(){let t={};for(let[e,s]of this){let n=At(e)?e:String(e),i=s?.valueOf()||s;t[n]=i}return t}get objectifyValues(){return this.#t}get(t,e){let s=super.get(t);return!s||!s?.deref()?e:s?.deref()}set objectifyValues(t){this.#t=!!t}set(t,e){let s=e;if(this.#t&&(typeof s=="number"||typeof s=="string"||typeof s=="boolean"||typeof s=="bigint")&&(s=Object(s)),typeof s=="symbol"&&Symbol.keyFor(s)!==void 0)throw new TypeError("RefMap cannot accept registered symbols as values");if(typeof s!="object"&&typeof s!="symbol")throw new TypeError("RefMap values must be objects, non-registered symbols, or objectified primitives");if(s==null)throw new TypeError("RefMap values cannot be null or undefined");let n=new WeakRef(s);super.set(t,n)}setAll(t){if(!v.isIterable(t))throw new TypeError("The supplied list of entries must be an array of arrays in the format [[key1, value1], [key2, value2], ...].");let e=s=>{let[n,i]=s;!n||!jt(i)||!Pt(i)||this.set(n,i)};for(let s of t)e(s);return this}clean(){for(let[t,e]of this)e||this.delete(t);return this}entries(){let t=super.entries();return new E(t,s=>{if(s){let[n,i]=s,o=i?.deref();return[n,o]}return s})}forEach(t,e){for(let[s,n]of super.entries()){let i=n?.deref();i&&t.call(e,i,s,this)}}values(){return new E(super.values(),function(e){return e?.deref()||e})}hasValue(t,e=!0){if(Ot(t))return!1;this.#t&&(e=!1);for(let[s,n]of this)if(e&&t===n||!e&&t==n)return!0;return!1}filter(t,e){let s=[];for(let[n,i]of this)t.call(e,i,n,this)&&s.push([n,i]);return s}find(t,e){for(let[s,n]of this){let i=super.get(s),o=t.call(e,i,s,map);if(o||(o=t.call(e,n,s,map)),o)return n}return null}map(t,e,s,n){if(typeof t!="function")throw new TypeError("mapFn must be a function! Received",t);let i=[],o=[],c=n&&this.objectifyValues,u=n===void 0,l=c;for(let[f,m]of this){let[,h]=[0,1],b=t.call(e,[f,m],f,this);lt(b[h])||lt(Object(b[h]))&&(c=!0,u&&!l&&(l=!0,b[h]=Object(b[h]))),i.push(b)}return s?new r(i).objectifying(l):i}*[Symbol.iterator](){for(let[t,e]of this.entries())yield[t,e]}get[Symbol.toStringTag](){return this.constructor.name}},Y=new p(L);var q=class r extends Promise{#t=null;#e=null;#r=null;#n=!1;#i=!1;value=null;reason=null;#s=!1;constructor(t){let e=t&&typeof t=="object"?t:{};if(e?.resolve&&e?.reject)throw new TypeError("resolve and reject options cannot be simultaneously provided");let s,n;super((i,o)=>{s=i,n=o,e?.executor&&typeof e?.executor=="function"&&e?.executor(i,o)}),this.#r=i=>(e?.doNotTrackAnswers!==!0&&(this.value=i),this.#s=!0,this.#i=!0,s(i)),this.#e=async i=>(e?.doNotTrackAnswers!==!0&&(this.reason=i),this.#s=!0,this.#n=!0,n(i)),this.#t=this,e?.resolve?this.#r(e?.resolve):e?.reject&&this.#e(e?.reject)}get settled(){return this.#s}get wasRejected(){return this.#n}get wasResolved(){return this.#i}get promise(){return this.#t}resolve(t){return this.#r(t)}reject(t){return this.#e(t)}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){return["\x1B[1mDeferred [\x1B[22;3mPromise\x1B[23;1m]\x1B[22m ","{ ",this.settled?this.wasResolved?`resolved with \x1B[32m${this.value}\x1B[39m`:`rejected with \x1B[31m${this.reason?.message??this.reason}\x1B[39m`:"\x1B[33munsettled valued or reason\x1B[39m"," }"].join("")}static get[Symbol.species](){return class extends r{constructor(e){super({executor:e})}}}},z=new p(q);var J=class{#t=[];constructor(t,...e){t!=null&&(typeof t[Symbol.iterator]=="function"||typeof t[Symbol.asyncIterator]=="function")?this.#t=[...t,...e]:typeof t=="function"&&t.constructor.name==="AsyncGeneratorFunction"?this.#t=t():this.#t=[t,...e]}async*[Symbol.asyncIterator](){for await(let t of this.#t)yield t}get[Symbol.toStringTag](){return this.constructor.name}static isAsyncIterable(t){return Object.prototype.toString.call(t?.[Symbol.asyncIterator])==="[object AsyncGeneratorFunction]"}},U=class{constructor(t){if(typeof t=="function"&&t.constructor.name==="AsyncGeneratorFunction")this.#t=t();else{if(!t||!Reflect.has(t,Symbol.asyncIterator))throw new TypeError("Value used to instantiate AsyncIterator is not an async iterable");this.#t=t}this.#e=this.#t[Symbol.asyncIterator]()}async asArray(){let t=[];for await(let e of this)t.push(e);return t}get asyncIterable(){return this.#t}async next(){let t=await this.#e.next();return t.done?{value:void 0,done:!0}:{value:t.value,done:!1}}async reset(){this.#e=this.#t[Symbol.asyncIterator]()}[Symbol.asyncIterator](){return this}get[Symbol.toStringTag](){return this.constructor.name}#t=null;#e=null},Q=new p(J),X=new p(U);var j=[[Object,d,Object.name],[Function,$,Function.name],[Reflect,D,"Reflect"],[String,it,String.name],[Symbol,N,"Symbol"]],O=[[Object.prototype,_,Object.name],[String.prototype,ot,String.name],[Function.prototype,et,Function.name],[Array.prototype,ct,Array.name],[Map.prototype,rt,Map.name],[Set.prototype,st,Set.name]],k=new Map([...j,...O]),A={[Q.key]:Q,[X.key]:X,[z.key]:z,[G.key]:G,[H.key]:H,[W.key]:W,[Y.key]:Y,[K.key]:K},g={};Object.assign(g,{enableAll(){g.enablePatches(),g.enableExtensions()},enablePatches(){k.forEach(r=>{r.apply()})},enableStaticPatches(r=([t,e])=>!0){let t=j.filter(I(r));return t.forEach(([e,s])=>s.apply()),t},enableInstancePatches(r=([t,e])=>!0){let t=O.filter(I(r));return t.forEach(([e,s])=>s.apply()),t},enableExtensions(){Object.values(A).forEach(r=>{r.apply()}),w.apply()},disableAll(){g.disablePatches(),g.disableExtensions()},disablePatches(){k.forEach(r=>{r.revert()})},disableStaticPatches(r=([t,e])=>!0){let t=j.filter(I(r));return t.forEach(([e,s])=>s.revert()),t},disableInstancePatches(r=([t,e])=>!0){let t=O.filter(I(r));return t.forEach(([e,s])=>s.revert()),t},disableExtensions(){Object.values(A).forEach(r=>{r.revert()}),w.revert()}});var ut=(()=>{let r={patches:{},classes:{},global:{}},t=(n,[i,o])=>(new x(o.descriptor,o.owner).applyTo(n,i,!0),n),e=(n,[i,o,c])=>(n?.[c]||(n[c]={}),[...o].reduce(t,n[c]),n),s=(n,[i,o,c])=>(n?.[c]||(n[c]={}),n[c]?.prototype||(n[c].prototype={}),[...o].reduce(t,n[c].prototype),n);j.reduce(e,r.patches),O.reduce(s,r.patches),Object.values(A).flatMap(n=>[...n]).reduce(t,r.classes);for(let[n,i]of w){let o=new x(i.descriptor,i.owner);Object.defineProperty(r.global,n,o.toObject(!0))}return r})(),Rt={...g,Extensions:A,Patches:k,GlobalFunctionsAndProps:w,StaticPatches:j,InstancePatches:O,Controls:g,extensions:A,patches:k,all:ut},Tt=Rt;function I(r=([t,e])=>!0){let t=r;if(typeof t!="function"){let e=Array.isArray(r)?r:[r];t=([s,n])=>{for(let i of e){let o=String(i);if(o.startsWith("^")&&(s?.name??s)!=o.substring(1)||(s?.name??s)==o)return!0}return!1}}return t}return bt(vt);})();
//# sourceMappingURL=basic-extensions.bundle.2.5.0.js.map
