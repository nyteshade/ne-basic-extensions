var nejsBasicExtensions=(()=>{var u=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var E=Object.getOwnPropertyNames;var R=Object.prototype.hasOwnProperty;var j=(e,t)=>{for(var r in t)u(e,r,{get:t[r],enumerable:!0})},P=(e,t,r,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of E(t))!R.call(e,n)&&n!==r&&u(e,n,{get:()=>t[n],enumerable:!(s=S(t,n))||s.enumerable});return e};var A=e=>P(u({},"__esModule",{value:!0}),e);var v={};j(v,{ArrayPrototypeExtensions:()=>x,FunctionExtensions:()=>g,ObjectExtensions:()=>l,ReflectExtensions:()=>m,StringExtensions:()=>y,SymbolExtensions:()=>b,disableAll:()=>F,enableAll:()=>D});var T=e=>/(\w+)]/.exec(Object.prototype.toString.call(e))[1],a=class extends Error{constructor(t,r){super(`${T(t)} disallows tampering with ${r}.`),Object.assign(this,{owner:t,key:r})}get[Symbol.toStringTag](){return this.constructor.name}};var $=e=>/(\w+)]/.exec(Object.prototype.toString.call(e))[1],p=class extends Error{constructor(t,r){super(`${$(t)} does not have a property named '${r}'.`),Object.assign(this,{owner:t,key:r})}get[Symbol.toStringTag](){return this.constructor.name}};var h=class{constructor(t,r=!1){this.started=!1,this.preventRevert=r,this.patch=t,this.patchName=t.owner?.name??t.owner?.constructor?.name??/(\w+)]/.exec(Object.prototype.toString.call(t.owner))[1],this.state={needsApplication:!1,needsReversion:!1}}start(){return this.started||(this.state.needsApplication=!this.patch.applied,this.state.needsReversion=this.patch.applied,this.started=!0,this.state.needsApplication&&this.patch.apply()),this}stop(){return this.started&&((this.preventRevert||this.patch.applied)&&this.patch.revert(),this.state.needsApplication=!1,this.state.needsReversion=!1,this.started=!1),this}get[Symbol.toStringTag](){return`${this.constructor.name}:${this.patchName}`}[Symbol.for("nodejs.util.inspect.custom")](t,r,s){let n=this[Symbol.toStringTag],o=`(started: ${this.started} needed: ${this.state.needsApplication})`;return s(`${n} ${o}`,{...r,depth:t})}};var i=class e{constructor(t,r,s={}){Object.assign(this,{owner:t,options:s,applied:!1}),this.patchConflicts={},this.patchEntries={},this.patchesOwner=r,Reflect.ownKeys(r).forEach(n=>{this.patchEntries[n]=new e.#t(n,this.patchesOwner),Reflect.has(this.owner,n)&&(this.patchConflicts[n]=new e.#t(n,this.owner))}),e.patches.has(t)||e.patches.set(t,[]),e.patches.get(t).push(this)}get patches(){return Reflect.ownKeys(this.patchEntries).map(t=>[t,this.patchEntries[t]])}get conflicts(){return Reflect.ownKeys(this.patchConflicts).map(t=>[t,this.patchConflicts[t]])}apply(){this.applied||(this.patches.forEach(([,t])=>{Object.defineProperty(this.owner,t.key,t.descriptor)}),this.applied=!0)}createToggle(t=!1){return new h(this,t)}revert(){this.applied&&(this.patches.forEach(([,t])=>{delete this.owner[t.key]}),this.conflicts.forEach(([,t])=>{Object.defineProperty(this.owner,t.key,t.descriptor)}),this.applied=!1)}release(){let t=e.patches.get(this.owner);t.splice(t.find(r=>r===this),1)}owner=null;options=null;static patches=new Map;static enableFor(t){if(e.patches.has(t))for(let r of e.patches.get(t))r.apply()}static disableFor(t){if(e.patches.has(t))for(let r of e.patches.get(t))r.revert()}static#t=class{constructor(t,r=globalThis){Object.assign(this,{key:t,descriptor:Object.getOwnPropertyDescriptor(r,t),owner:r})}get computed(){return this.isAccessor?this.descriptor.get.bind(this.owner).call():this.descriptor.value}get isData(){return Reflect.has(this.descriptor,"value")}get isAccessor(){return Reflect.has(this.descriptor,"get")}get isReadOnly(){return Reflect.has(this.descriptor,"configurable")&&!this.descriptor.configurable||Reflect.has(this.descriptor,"writable")&&!this.descriptor.writable}get[Symbol.toStringTag](){return this.constructor.name}[Symbol.for("nodejs.util.inspect.custom")](t,r,s){return`PatchEntry<${this.key}, ${this.isData?"Data":"Accessor"}${this.isReadOnly?" [ReadOnly]":""}>`}}};var d=class e extends i{constructor(t,r,s=globalThis,n={}){let{key:o,extension:f,valid:w}=e.determineInput(t);if(f=r||f,!w)throw new p(s,o);let c=Object.getOwnPropertyDescriptor(s,o);if(c&&(Reflect.has(c,"writable")&&!c.writable||Reflect.has(c,"configurable")&&!c.configurable))throw new a(s,o);super(s,{[o]:f},n),this.key=o}static determineInput(t){let r={key:null,extension:null,valid:!1};return t instanceof Function?r={key:t.name,extension:t,valid:!0}:(typeof t=="string"||t instanceof String)&&(r={key:t,extension:null,valid:!0}),r}[Symbol.for("nodejs.util.inspect.custom")](t,r,s){return`Extension<${this.key}>`}get[Symbol.toStringTag](){return this.constructor.name}};var g=new i(Function,{isClass(e){return e instanceof Function&&String(e).includes("class")},isFunction(e){return e instanceof Function},isAsync(e){let t=/(\w+)]/g.exec(Object.prototype.toString.call(e))[1];return e instanceof Function&&t.includes("Async")},isBigArrow(e){return e instanceof Function&&String(e).includes("=>")&&!String(e).startsWith("bound")&&!Reflect.has(e,"prototype")},isBound(e){return e instanceof Function&&String(e).startsWith("bound")&&!Reflect.has(e,"prototype")}});var l=new i(Object,{isValidKey(e){return typeof e=="string"||typeof e=="symbol"},isObject(e){return e&&(e instanceof Object||typeof e=="object")},getStringTag(e){return/\s(.+)]/.exec(Object.prototype.toString.call(e))[1]},stripTo(e,t,r=!0){let s={};if(!Array.isArray(t))return s;for(let n of t)if(Reflect.has(e,n)){let o=Object.getOwnPropertyDescriptor(e,n);(Reflect.has(o,"get")||Reflect.has(o,"set"))&&r&&(o.get=o?.get?.bind(e),o.set=o?.set?.bind(e)),Object.defineProperty(s,o)}return s},getType(e,t=globalThis){let r=Object.getStringTag(e);switch(r){case"Null":return null;case"Undefined":return;default:return t[r]}}});var m=new i(Reflect,{hasAll(e,...t){return Object.isObject(e)&&t.flat(1/0).map(r=>Reflect.has(e,r)).every(r=>r)},ownDescriptors(e){let t={},r=()=>r.doIt?l.revert():"";if(r.doIt=!1,Object.isObject||(r.doIt=!0,l.apply()),!Object.isObject(e))return r(),{};let s=Reflect.ownKeys(e);for(let n of s)t[n]=Object.getOwnPropertyDescriptor(n);return r(),t},hasSome(e,...t){return Object.isObject(e)&&t.flat(1/0).map(r=>Reflect.has(e,r)).some(r=>r)},entries(e){return!e||typeof e!="object"?[]:Reflect.ownKeys(e).map(t=>[t,Object.getOwnPropertyDescriptor(e,t)])},values(e){return Reflect.entries.map(([,t])=>t)}});var y=new i(String,{isString(e){return e&&(typeof e=="string"||e instanceof String)?e.length>0:!1}});var b=new i(Symbol,{isSymbol(e){return!!(e&&typeof e=="symbol")}});var x=new i(Array.prototype,{contains(e){return!!this.find(t=>t===e)},findEntry(e){let t=this.entries(),r=1;for(let s of t)if(e(s[r]))return s},get first(){return this[0]},get last(){return this[this.length-1]}});var O=[Object,Function,Reflect,String,Symbol,Array.prototype];function D(e){(e||O).forEach(t=>{i.enableFor(t)})}function F(e){(e||O).forEach(t=>{i.disableFor(t)})}return A(v);})();
//# sourceMappingURL=basic-extensions.bundle.1.0.0.js.map
