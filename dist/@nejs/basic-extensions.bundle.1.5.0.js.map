{
  "version": 3,
  "sources": ["../../src/index.js", "../../node_modules/@nejs/extension/dist/mjs/errors/CannotBeExtendedError.js", "../../node_modules/@nejs/extension/dist/mjs/errors/MissingOwnerValue.js", "../../node_modules/@nejs/extension/dist/mjs/patchtoggle.js", "../../node_modules/@nejs/extension/dist/mjs/patch.js", "../../node_modules/@nejs/extension/dist/mjs/extension.js", "../../src/functionextensions.js", "../../src/objectextensions.js", "../../src/reflectextensions.js", "../../src/stringextensions.js", "../../src/symbolextensions.js", "../../src/arrayextensions.js", "../../src/descriptor.js", "../../src/globals.js", "../../src/refset.js", "../../src/asyncIterable.js", "../../src/iterable.js"],
  "sourcesContent": ["import { FunctionExtensions } from './functionextensions.js'\nimport { ObjectExtensions } from './objectextensions.js'\nimport { ReflectExtensions } from './reflectextensions.js'\nimport { StringExtensions } from './stringextensions.js'\nimport { SymbolExtensions } from './symbolextensions.js'\nimport { ArrayPrototypeExtensions } from './arrayextensions.js'\nimport { DescriptorExtensions } from './descriptor.js'\nimport { GlobalFunctionsAndProps } from './globals.js'\nimport { RefSetExtensions } from './refset.js'\n\nimport {\n  AsyncIteratorExtensions,\n  AsyncIterableExtensions\n} from './asyncIterable.js'\n\nimport {\n  IteratorExtensions,\n  IterableExtensions\n} from './iterable.js'\n\nimport { Patch } from '@nejs/extension'\n\nconst Owners = [\n  Object,\n  Function,\n  Reflect,\n  String,\n  Symbol,\n\n  Array.prototype,\n]\n\nconst NetNew = [\n  GlobalFunctionsAndProps,\n  DescriptorExtensions,\n  AsyncIterableExtensions,\n  AsyncIteratorExtensions,\n  IterableExtensions,\n  IteratorExtensions,\n  RefSetExtensions,\n]\n\nexport function enableAll(owners) {\n  const list = owners || Owners\n\n  if (!list) {\n    throw new Error('Unable to enable features without owners list')\n  }\n\n  list.forEach(owner => {\n    Patch.enableFor(owner)\n  })\n\n  enableNetNew()\n}\n\nexport function enableNetNew() {\n  NetNew.forEach(extension => { extension.apply() })\n}\n\nexport function disableAll(owners) {\n  const list = owners || Owners\n\n  if (!list) {\n    throw new Error('Unable to disable features without owners list')\n  }\n\n  list.forEach(owner => {\n    Patch.disableFor(owner)\n  })\n\n  disableNetNew()\n}\n\nexport function disableNetNew() {\n  NetNew.forEach(extension => { extension.revert() })\n}\n\nexport const all = (() => {\n  let extensions = [\n    ObjectExtensions,\n    FunctionExtensions,\n    ReflectExtensions,\n    StringExtensions,\n    SymbolExtensions,\n    ArrayPrototypeExtensions,\n\n    GlobalFunctionsAndProps,\n    DescriptorExtensions,\n  ]\n\n  const dest = extensions.reduce((accumulator, extension) => {\n    Reflect.ownKeys(extension.patchEntries).reduce((_, key) => {\n      accumulator[key] = extension.patchEntries[key].computed\n      return accumulator\n    }, accumulator)\n\n    return accumulator\n  }, {})\n\n  return dest\n})()\n\n\nexport {\n  ObjectExtensions,\n  FunctionExtensions,\n  ReflectExtensions,\n  StringExtensions,\n  SymbolExtensions,\n  ArrayPrototypeExtensions,\n\n  GlobalFunctionsAndProps,\n  DescriptorExtensions,\n  AsyncIterableExtensions,\n  AsyncIteratorExtensions,\n  IterableExtensions,\n  IteratorExtensions,\n  RefSetExtensions,\n}", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1];\n/**\n * Represents an error that is thrown when there is an attempt to extend a\n * restricted part of the code. This error is specifically used to signal\n * violations of extension constraints, such as tampering with certain keys\n * or properties of an object. The error message constructed will include the\n * details of the owner (the restricted part) and the key that was attempted to\n * be tampered with.\n */\nexport class CannotBeExtendedError extends Error {\n    /**\n     * Constructs a new CannotBeExtendedError instance.\n     *\n     * @param {string} owner The name or identifier of the restricted part\n     * that is disallowing extension or tampering.\n     * @param {string} key The key or property that was attempted to be\n     * modified or extended.\n     */\n    constructor(owner, key) {\n        super(`${typeOf(owner)} disallows tampering with ${key}.`);\n        Object.assign(this, { owner, key });\n    }\n    /**\n     * Custom getter for the toStringTag symbol. Overrides the default\n     * Object.prototype.toString behavior, returning the constructor's name\n     * of this error instance. Useful for debugging and logging purposes.\n     * @returns {string} The name of the constructor for this error instance.\n     */\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1];\n/**\n * Represents an error that is thrown when a property is missing from a specified\n * owner object. This error is used to indicate that a specific key or property\n * expected to be present on the owner is not found, highlighting potential issues\n * in property access or data integrity.\n */\nexport class MissingOwnerValue extends Error {\n    /**\n     * Constructs a new MissingOwnerValue instance.\n     *\n     * @param {string} owner The object or entity that is supposed to contain the\n     * property.\n     * @param {string} key The name of the property that is missing from the owner.\n     */\n    constructor(owner, key) {\n        super(`${typeOf(owner)} does not have a property named '${key}'.`);\n        Object.assign(this, { owner, key });\n    }\n    /**\n     * Custom getter for the toStringTag symbol. Overrides the default\n     * Object.prototype.toString behavior, returning the constructor's name\n     * of this error instance. Useful for debugging and logging purposes.\n     *\n     * @returns {string} The name of the constructor for this error instance.\n     */\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n", "import { Patch } from \"./patch\";\n/**\n * Early usage of the Patch and Extension classes made it clear that it was\n * cumbersome to use a Patch temporarily for a block of code and excessive\n * amounts of if/else statements were required. This simple wrapper makes that\n * process easier.\n */\nexport class PatchToggle {\n    /**\n     * Wraps an instance of a Patch. It allows low-code clean-readability to\n     * start and stop the underlying patch regardless of whether or not the\n     * patch has been already applied.\n     *\n     * @param {Patch} patch instance of `Patch` to wrap with this toggle\n     * @param {boolean} preventRevert prevents the call to `.revert()` on the\n     * supplied patch when stop() is called.\n     */\n    constructor(patch, preventRevert = false) {\n        this.started = false;\n        this.preventRevert = preventRevert;\n        this.patch = patch;\n        this.patchName = (patch.owner?.name ??\n            patch.owner?.constructor?.name ??\n            /(\\w+)]/.exec(Object.prototype.toString.call(patch.owner))[1]);\n        this.state = {\n            needsApplication: false,\n            needsReversion: false,\n        };\n    }\n    /**\n     * If the usage of the wrapped Patch hasn't been started yet, the code checks\n     * whether or not the patch has been applied by checking for signs of it in\n     * the owning object.\n     *\n     * If the patch needs to be applied, it will be applied at this time.\n     *\n     * @returns {PatchToggle} returns `this` to allow for chaining\n     */\n    start() {\n        if (!this.started) {\n            this.state.needsApplication = !this.patch.applied;\n            this.state.needsReversion = this.patch.applied;\n            this.started = true;\n            if (this.state.needsApplication) {\n                this.patch.apply();\n            }\n        }\n        return this;\n    }\n    /**\n     * Checks to see if the toggle has been started. If so, the patch is reverted\n     * if it needed to be applied previously. After stopping, the state of the instance\n     * is reverted to allow for clean subsequent calls to start.\n     *\n     * @returns {PatchToggle} returns `this` to allow further chaining\n     */\n    stop() {\n        if (this.started) {\n            if (this.preventRevert || this.patch.applied) {\n                this.patch.revert();\n            }\n            this.state.needsApplication = false;\n            this.state.needsReversion = false;\n            this.started = false;\n        }\n        return this;\n    }\n    /**\n     * When the string tag for this class instance is inspected, it will\n     * reflect the string `PatchToggle:PatchName`\n     */\n    get [Symbol.toStringTag]() {\n        return `${this.constructor.name}:${this.patchName}`;\n    }\n    /**\n     * Custom inspect function for Node.js that provides a formatted representation\n     * of the PatchToggle instance, primarily for debugging purposes.\n     *\n     * @param {number} depth The depth to which the object should be formatted.\n     * @param {object} options Formatting options.\n     * @param {function} inspect The inspection function to format the object.\n     * @returns {string} A formatted string representing the PatchEntry instance.\n     */\n    [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n        const objName = this[Symbol.toStringTag];\n        const status = `(started: ${this.started} needed: ${this.state.needsApplication})`;\n        return inspect(`${objName} ${status}`, { ...options, depth });\n    }\n}\n", "import { PatchToggle } from './patchtoggle.js';\n/**\n * The Patch class provides a mechanism to apply patches to properties or\n * methods of an object (the owner). It keeps track of the original state of\n * these properties and allows for the application and reversion of patches.\n */\nexport class Patch {\n    /**\n     * Constructs a new Patch instance.\n     *\n     * @param {object} owner The object to which patches will be applied.\n     * @param {object} patches An object containing properties or methods to\n     *                         be patched onto the owner.\n     * @param {object} [options={}] Additional options for patching behavior.\n     */\n    constructor(owner, patches, options = {}) {\n        Object.assign(this, {\n            owner,\n            options,\n            applied: false,\n        });\n        this.patchConflicts = {};\n        this.patchEntries = {};\n        this.patchesOwner = patches;\n        Reflect.ownKeys(patches).forEach(key => {\n            this.patchEntries[key] = new Patch.#PatchEntry(key, this.patchesOwner);\n            if (Reflect.has(this.owner, key)) {\n                this.patchConflicts[key] = new Patch.#PatchEntry(key, this.owner);\n            }\n        });\n        if (!Patch.patches.has(owner)) {\n            Patch.patches.set(owner, []);\n        }\n        Patch.patches.get(owner).push(this);\n    }\n    /**\n     * Retrieves the patch entries as an array of [key, patchEntry] pairs.\n     *\n     * @returns {Array} An array of [key, patchEntry] pairs.\n     */\n    get patches() {\n        return Reflect.ownKeys(this.patchEntries).map(key => {\n            return [key, this.patchEntries[key]];\n        });\n    }\n    /**\n     * Retrieves the conflict entries (existing properties on the owner that\n     * will be overridden by patches) as an array of [key, patchEntry] pairs.\n     *\n     * @returns {Array} An array of [key, patchEntry] pairs.\n     */\n    get conflicts() {\n        return Reflect.ownKeys(this.patchConflicts).map(key => {\n            return [key, this.patchConflicts[key]];\n        });\n    }\n    /**\n     * Applies all patches to the owner object. If a property with the same key\n     * already exists on the owner, it will be overridden.\n     */\n    apply() {\n        if (!this.applied) {\n            this.patches.forEach(([, patch]) => {\n                Object.defineProperty(this.owner, patch.key, patch.descriptor);\n            });\n            this.applied = true;\n        }\n    }\n    /**\n     * Creates an easy to use toggle for working with `Patch` classes\n     *\n     * @param {boolean} preventRevert true if calling stop() on the toggle does not\n     * revert the patch. false, the default, if it should.\n     * @returns {PatchToggle} an instance of PatchToggle wrapped around this instance\n     * of `Patch`\n     * @example const toggle = ObjectExtensions.createToggle().start()\n     */\n    createToggle(preventRevert = false) {\n        return new PatchToggle(this, preventRevert);\n    }\n    /**\n     * Reverts all applied patches on the owner object, restoring any overridden\n     * properties to their original state.\n     */\n    revert() {\n        if (this.applied) {\n            this.patches.forEach(([, patch]) => {\n                delete this.owner[patch.key];\n            });\n            this.conflicts.forEach(([, patch]) => {\n                Object.defineProperty(this.owner, patch.key, patch.descriptor);\n            });\n            this.applied = false;\n        }\n    }\n    /**\n     * Removes this Patch instance from being tracked amongst all the tracked Patch\n     * instances. The JavaScript virtual machine will clean this instance up once\n     * nothing else is holding a reference to it.\n     */\n    release() {\n        const patches = Patch.patches.get(this.owner);\n        patches.splice(patches.find(e => e === this), 1);\n    }\n    /**\n     * The object to which the patches are applied.\n     */\n    owner = null;\n    /**\n     * Additional options for patching behavior.\n     */\n    options = null;\n    /**\n     * A global mapping of all patches in play\n     */\n    static patches = new Map();\n    /**\n     * Applies all patches associated with a given owner object. This method\n     * is used to enable all patches for a specific owner if they have been\n     * previously registered.\n     *\n     * @param {object} owner The object whose patches are to be applied.\n     */\n    static enableFor(owner) {\n        if (Patch.patches.has(owner)) {\n            for (const patch of Patch.patches.get(owner)) {\n                patch.apply();\n            }\n        }\n    }\n    /**\n     * Reverts all patches associated with a given owner object. This method\n     * is used to disable all patches for a specific owner if they have been\n     * previously applied.\n     *\n     * @param {object} owner The object whose patches are to be reverted.\n     */\n    static disableFor(owner) {\n        if (Patch.patches.has(owner)) {\n            for (const patch of Patch.patches.get(owner)) {\n                patch.revert();\n            }\n        }\n    }\n    /**\n     * Internal class representing a single patch entry.\n     */\n    static #PatchEntry = class {\n        /**\n         * Constructs a new PatchEntry instance.\n         *\n         * @param {string} property The property key to be patched.\n         * @param {object} [owningObject=globalThis] The object from which the\n         * property descriptor is taken.\n         */\n        constructor(property, owningObject = globalThis) {\n            Object.assign(this, {\n                key: property,\n                descriptor: Object.getOwnPropertyDescriptor(owningObject, property),\n                owner: owningObject\n            });\n        }\n        /**\n         * Computes and returns the current value of the patch, based on its type\n         * (data or accessor).\n         *\n         * @returns {any} The current value of the patch.\n         */\n        get computed() {\n            if (this.isAccessor) {\n                return this.descriptor.get.bind(this.owner).call();\n            }\n            else {\n                return this.descriptor.value;\n            }\n        }\n        /**\n         * Checks if the patch is a data property (has a value).\n         *\n         * @returns {boolean} True if the patch is a data property, false otherwise.\n         */\n        get isData() {\n            return Reflect.has(this.descriptor, 'value');\n        }\n        /**\n         * Checks if the patch is an accessor property (has a getter).\n         *\n         * @returns {boolean} True if the patch is an accessor property, false otherwise.\n         */\n        get isAccessor() {\n            return Reflect.has(this.descriptor, 'get');\n        }\n        /**\n         * Checks if the patch is read-only (not configurable or not writable).\n         *\n         * @returns {boolean} True if the patch is read-only, false otherwise.\n         */\n        get isReadOnly() {\n            return ((Reflect.has(this.descriptor, 'configurable') && !this.descriptor.configurable) ||\n                (Reflect.has(this.descriptor, 'writable') && !this.descriptor.writable));\n        }\n        /**\n         * Custom getter for the toStringTag symbol. Provides the class name of\n         * the PatchEntry instance.\n         *\n         * @returns {string} The class name of the PatchEntry instance.\n         */\n        get [Symbol.toStringTag]() {\n            return this.constructor.name;\n        }\n        /**\n         * Custom inspect function for Node.js that provides a formatted representation\n         * of the PatchEntry instance, primarily for debugging purposes.\n         *\n         * @param {number} depth The depth to which the object should be formatted.\n         * @param {object} options Formatting options.\n         * @param {function} inspect The inspection function to format the object.\n         * @returns {string} A formatted string representing the PatchEntry instance.\n         */\n        [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n            return `PatchEntry<${this.key}, ${this.isData ? 'Data' : 'Accessor'}${this.isReadOnly ? ' [ReadOnly]' : ''}>`;\n        }\n    };\n}\n", "import { CannotBeExtendedError } from \"./errors/CannotBeExtendedError.js\";\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js';\nimport { Patch } from './patch.js';\n/**\n * The Extension class, inheriting from the Patch class, is specifically designed\n * for extending properties or methods of a given object. It facilitates the\n * extension process by determining the target key and value for the extension and\n * ensuring the target property is writable and configurable. If these conditions\n * are not met, the class throws a CannotBeExtendedError. This class is useful\n * in scenarios like testing, dynamic behavior adjustments, or managing complex\n * object configurations.\n */\nexport class Extension extends Patch {\n    /**\n     * Constructs a new Extension instance. This constructor initializes the extension\n     * by determining the target key and value for the extension and ensuring that\n     * the property to be extended is configurable and writable. It throws an error\n     * if these conditions are not satisfied. The constructor leverages the Patch\n     * class's functionalities to manage the extension effectively.\n     *\n     * @param {Function|string} keyClassOrFn - The key, class, or function to be\n     * used for the extension. If a function or class is provided, its name is used\n     * as the key.\n     * @param {*} value - The value or method to be used for the extension.\n     * @param {object} [owner=globalThis] - The object to which the extension will\n     * be applied.\n     * @param {object} [options={}] - Additional options for the extension behavior.\n     * @throws {CannotBeExtendedError} If the target property is not writable or\n     * configurable.\n     * @throws {MissingOwnerValue} If the `keyClassOrFn` value is null or there\n     * is an error determining the key and extension values, MissingOwnerValue is\n     * thrown.\n     */\n    constructor(keyClassOrFn, value, owner = globalThis, options = {}) {\n        let { key, extension, valid } = Extension.determineInput(keyClassOrFn);\n        extension = value || extension;\n        if (!valid) {\n            throw new MissingOwnerValue(owner, key);\n        }\n        const descriptor = Object.getOwnPropertyDescriptor(owner, key);\n        if (descriptor) {\n            if ((Reflect.has(descriptor, 'writable') && !descriptor.writable) ||\n                (Reflect.has(descriptor, 'configurable') && !descriptor.configurable)) {\n                throw new CannotBeExtendedError(owner, key);\n            }\n        }\n        super(owner, { [key]: extension }, options);\n        this.key = key;\n    }\n    /**\n     * Determines the input type for the extension. This method processes the input\n     * and identifies the key for the extension and the associated value or method.\n     * It supports inputs as either a string key or a function/class, providing\n     * flexibility in defining extensions.\n     *\n     * @param {Function|string} keyClassOrFn - The key, class, or function provided\n     * as input. If a function or class is provided, its name is used as the key.\n     * containing the determined key, the extension value/method, and a validity flag\n     * indicating whether the input is usable.\n     * @returns {{key: string|null, extension: *|null, valid: boolean}} An object\n     */\n    static determineInput(keyClassOrFn) {\n        let input = { key: null, extension: null, valid: false };\n        if (keyClassOrFn instanceof Function) {\n            input = { key: keyClassOrFn.name, extension: keyClassOrFn, valid: true };\n        }\n        else if (typeof keyClassOrFn === 'string' || keyClassOrFn instanceof String) {\n            input = { key: keyClassOrFn, extension: null, valid: true };\n        }\n        return input;\n    }\n    /**\n     * Custom inspect function for Node.js that provides a formatted representation\n     * of the Extension instance, primarily for debugging purposes.\n     *\n     * @param {number} depth The depth to which the object should be formatted.\n     * @param {object} options Formatting options.\n     * @param {function} inspect The inspection function to format the object.\n     * @returns {string} A formatted string representing the Extension instance.\n     */\n    [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n        return `Extension<${this.key}>`;\n    }\n    /**\n     * Custom getter for the toStringTag symbol. Provides the class name when the\n     * object is converted to a string, typically used for debugging and logging.\n     *\n     * @returns {string} The class name of the Extension instance.\n     */\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n", "import { Patch } from '@nejs/extension'\n\n/**\n * The `FunctionExtensions` class is a patch applied to the built-in JavaScript\n * `Function` constructor. It extends `Function` with additional utility methods\n * for determining the specific type or nature of function-like objects. These\n * methods allow developers to distinguish between classes, regular functions,\n * async functions, and arrow functions in a more intuitive and straightforward\n * manner. This class is part of the `@nejs/extension` library and enhances the\n * capabilities of function handling and introspection in JavaScript.\n */\nexport const FunctionExtensions = new Patch(Function, {\n  /**\n   * Determines if a given value is a class. It checks if the value is an\n   * instance of `Function` and if its string representation includes the\n   * keyword 'class'. This method is useful for distinguishing classes from\n   * other function types in JavaScript.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is a class, otherwise\n   * `false`.\n   */\n  isClass(value) {\n    return value instanceof Function && !!/^class\\s/.exec(String(value))\n  },\n\n  /**\n   * Checks if a given value is a regular function. This method verifies if\n   * the value is an instance of `Function`, which includes regular functions,\n   * classes, and async functions but excludes arrow functions.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is a regular function,\n   * otherwise `false`.\n   */\n  isFunction(value) {\n    return value instanceof Function;\n  },\n\n  /**\n   * Determines if a given value is an asynchronous function. It checks if the\n   * value is an instance of `Function` and if its string representation\n   * includes the keyword 'Async'. This method is particularly useful for\n   * identifying async functions.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is an async function,\n   * otherwise `false`.\n   */\n  isAsync(value) {\n    const stringTag = /(\\w+)]/g.exec(Object.prototype.toString.call(value))[1]\n    return (\n      value instanceof Function &&\n      stringTag.includes('Async')\n    )\n  },\n\n  /**\n   * Checks if a given value is an arrow function. It verifies if the value is\n   * an instance of `Function`, if its string representation includes the '=>'\n   * symbol, and if it lacks a prototype, which is a characteristic of arrow\n   * functions in JavaScript.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is an arrow function,\n   * otherwise `false`.\n   */\n  isBigArrow(value) {\n    return (\n      value instanceof Function &&\n      String(value).includes('=>') &&\n      !String(value).startsWith('bound') &&\n      !Reflect.has(value, 'prototype')\n    );\n  },\n\n  /**\n   * Determines if a given value is a bound function. Bound functions are\n   * created using the `Function.prototype.bind` method, which allows setting\n   * the `this` value at the time of binding. This method checks if the value\n   * is an instance of `Function`, if its string representation starts with\n   * 'bound', and if it lacks a `prototype` property. These characteristics\n   * are indicative of bound functions in JavaScript.\n   *\n   * @param {*} value - The value to be checked, typically a function.\n   * @returns {boolean} Returns `true` if the value is a bound function,\n   * otherwise `false`. Bound functions have a specific format in their\n   * string representation and do not have their own `prototype` property.\n   */\n  isBound(value) {\n    return (\n      value instanceof Function &&\n      String(value).startsWith('bound') &&\n      !Reflect.has(value, 'prototype')\n    )\n  },\n})\n", "import { Patch } from '@nejs/extension';\n\n/**\n * `ObjectExtensions` is a patch for the JavaScript built-in `Object` class. It\n * adds utility methods to the `Object` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `Object` class with additional\n * utility functions.\n */\nexport const ObjectExtensions = new Patch(Object, {\n  /**\n   * Checks to see if the supplied `value` is both an object, and has the\n   * appropriate symbol defined.\n   *\n   * @param {any} value the value to determine if it contains a defined\n   * `Symbol.toStringTag` defined.\n   * @returns true if the symbol is defined, false otherwise\n   */\n  hasStringTag(value) {\n    return Object.isObject(value) && Reflect.has(value, Symbol.toStringTag)\n  },\n\n  /**\n   * Retrieves the string tag of an object. The string tag is a representation of\n   * the object's type, as defined by its `Object.prototype.toString` method. This\n   * utility method is helpful for getting a more descriptive type of an object than\n   * what is returned by the `typeof` operator, especially for custom objects.\n   *\n   * @param {*} value - The object whose string tag is to be retrieved.\n   * @returns {string} - The string tag of the object, indicating its type.\n   */\n  getStringTag(value) {\n    if (Object.hasStringTag(value)) {\n      return value[Symbol.toStringTag]\n    }\n\n    if (value && (typeof value === 'function')) {\n      return value.name\n    }\n\n    return /\\s(.+)]/.exec(Object.prototype.toString.call(value))[1];\n  },\n\n  /**\n   * Determines the type of the given value based on its string tag. This method\n   * uses `Object.getStringTag` to obtain the string tag of the value, which\n   * represents its more specific type (e.g., Array, Map, Set) rather than just\n   * 'object'. The method then maps this string tag to the corresponding type\n   * present in the provided `owner` object, which defaults to `globalThis`.\n   * This utility method is especially useful for identifying the specific\n   * constructor or class of an object, beyond the basic types identified by\n   * the `typeof` operator.\n   *\n   * @param {any} value - The value whose type is to be determined.\n   * @param {object} [owner=globalThis] - The object in which to look up the\n   * constructor corresponding to the string tag. Defaults to `globalThis`, which\n   * covers global constructors like `Array`, `Object`, etc.\n   * @returns {Function|object|null|undefined} - Returns the constructor or type\n   * of the value based on its string tag. For 'Null' and 'Undefined', it returns\n   * `null` and `undefined`, respectively. For other types, it returns the\n   * corresponding constructor (e.g., `Array` for arrays) if available in the\n   * `owner` object.\n   */\n  getType(value, owner = globalThis) {\n    const stringTag = Object.getStringTag(value)\n\n    switch (stringTag) {\n      case 'Null': return null\n      case 'Undefined': return undefined\n      default:\n        return owner[stringTag]\n    }\n  },\n\n  /**\n   * Determines if the provided value is an object. This method checks whether the\n   * value is an instance of `Object` or if its type is 'object'. It's a utility\n   * method for type-checking, ensuring that a value is an object before performing\n   * operations that are specific to objects.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} - Returns `true` if the value is an object, otherwise `false`.\n   */\n  isObject(value) {\n    return value && (value instanceof Object || typeof value === 'object');\n  },\n\n  /**\n   * Checks to see if the supplied value is a primitive value.\n   *\n   * @param {any} value the value to test to see if it is a primitive value type\n   * @returns true if the object is considered widely to be a primitive value,\n   * false otherwise.\n   */\n  isPrimitive(value) {\n    // Check for null as a special case because typeof null\n    // is 'object'\n    if (value === null) {\n      return true;\n    }\n\n    // Check for other primitives\n    switch (typeof value) {\n      case 'string':\n      case 'number':\n      case 'bigint':\n      case 'boolean':\n      case 'undefined':\n      case 'symbol':\n        return true;\n      default:\n        return false;\n    }\n  },\n\n  /**\n   * Checks if the given value is a valid key for an object. In JavaScript, a valid\n   * key can be either a string or a symbol. This method is useful for validating\n   * object keys before using them in operations like setting or getting object properties.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} - Returns `true` if the value is a valid object key (string or symbol),\n   *                      otherwise `false`.\n   */\n  isValidKey(value) {\n    return (typeof value === 'string' || typeof value === 'symbol');\n  },\n\n  /**\n   * Strips an object down to only the keys specified. Optionally, any\n   * accessors can be made to retain their context on the source object.\n   *\n   * @param {object} object the object to pare down\n   * @param {Array<string|symbol>} keys the keys that should appear in the\n   * final reduced object\n   * @param {boolean} [bindAccessors = true] if this value is true\n   * then any accessors from the source object will continue to have their\n   * `this` value bound to the source. If the getter or setter on that object\n   * is defined using an arrow function, this will not work as intended.\n   * @returns {object} an object containing only the keys and symbols specified\n   * in the `keys` parameter.\n   */\n  stripTo(object, keys, bindAccessors = true) {\n    const result = {}\n\n    if (!Array.isArray(keys)) {\n      return result\n    }\n\n    for (let key of keys) {\n      if (Reflect.has(object, key)) {\n        const descriptor = Object.getOwnPropertyDescriptor(object, key)\n        if (Reflect.has(descriptor, 'get') || Reflect.has(descriptor, 'set')) {\n          if (bindAccessors) {\n            descriptor.get = descriptor?.get?.bind(object)\n            descriptor.set = descriptor?.set?.bind(object)\n          }\n          Object.defineProperty(result, descriptor)\n        }\n        else {\n          Object.defineProperty(result, descriptor)\n        }\n      }\n    }\n\n    return result\n  },\n\n});\n", "import { Patch } from '@nejs/extension'\nimport { ObjectExtensions } from './objectextensions.js'\n\n/**\n * The `ReflectExtensions` class is a patch applied to the built-in JavaScript\n * `Reflect` object. It extends `Reflect` with additional utility methods that\n * enhance its capabilities. These methods provide more advanced ways of\n * interacting with object properties, such as checking for the presence of\n * multiple keys at once (`hasAll`) or verifying if at least one specified key\n * exists in an object (`hasSome`). This class is part of the `@nejs/extension`\n * library and is designed to offer these extended functionalities in a way\n * that is consistent with the existing `Reflect` API, making it intuitive for\n * developers who are already familiar with standard reflection methods in\n * JavaScript.\n */\nexport const ReflectExtensions = new Patch(Reflect, {\n  /**\n   * The function checks if an object has all the specified keys.\n   *\n   * @param object - The `object` parameter is the object that we want to\n   * check if it has all the specified keys.\n   * @param keys - The `keys` parameter is a rest parameter, which means\n   * it can accept any number of arguments. In this case, it is expected\n   * to receive multiple keys as arguments.\n   * @returns a boolean value.\n   */\n  hasAll(object, ...keys) {\n    return Object.isObject(object) && (keys.flat(Infinity)\n      .map(key => Reflect.has(object, key))\n      .every(has => has)\n    )\n  },\n\n  ownDescriptors(object) {\n    const result = {}\n    const revertOnDone = () => revertOnDone.doIt ? ObjectExtensions.revert() : ''\n    revertOnDone.doIt = false\n\n    if (!Object.isObject) {\n      revertOnDone.doIt = true\n      ObjectExtensions.apply()\n    }\n\n    if (!Object.isObject(object)) {\n      revertOnDone()\n      return {}\n    }\n\n    const keys = Reflect.ownKeys(object)\n\n    for (const key of keys) {\n      result[key] = Object.getOwnPropertyDescriptor(key)\n    }\n\n    revertOnDone()\n\n    return result\n  },\n\n  /**\n   * The function checks if an object has at least one of the specified keys.\n   *\n   * @param object - The `object` parameter is the object that we want to check\n   * for the presence of certain keys.\n   * @param keys - The `keys` parameter is a rest parameter, which means it can\n   * accept any number of arguments. These arguments are the keys that we want\n   * to check if they exist in the `object`.\n   * @returns The function `hasSome` returns a boolean value indicating whether\n   * at least one of the keys provided as arguments exists in the given object.\n   */\n  hasSome(object, ...keys) {\n    return Object.isObject(object) && (keys.flat(Infinity)\n      .map(key => Reflect.has(object, key))\n      .some(has => has)\n    )\n  },\n\n  /**\n   * Retrieves an array of [key, descriptor] pairs for each property of the\n   * provided object. This method is akin to `Object.entries` but includes\n   * property descriptors instead of the property values. It's useful for cases\n   * where you need detailed information about properties, including their\n   * configurability, enumerability, and accessors.\n   *\n   * @param {object} object - The object whose property entries are to be\n   * retrieved.\n   * @returns {Array} An array of [key, descriptor] pairs, where each pair\n   * consists of the property name (key) and its descriptor. Returns an empty\n   * array if the input is not a valid object.\n   */\n  entries(object) {\n    if (!object || typeof object !== 'object') { return [] }\n\n    return Reflect.ownKeys(object).map(key => [\n      key, Object.getOwnPropertyDescriptor(object, key)\n    ])\n  },\n\n  /**\n   * Retrieves an array of values from the property descriptors of the given\n   * object. This method works similarly to `Object.values` but operates on\n   * property descriptors instead. It's useful when you need the values of\n   * properties including getters, setters, and other descriptor-specific\n   * attributes.\n   *\n   * @param {object} object - The object whose property values are to be\n   * retrieved.\n   * @returns {Array} An array of values extracted from the object's property\n   * descriptors. The values correspond to the `value` attribute in each\n   * property's descriptor. Returns an empty array if the input is not a valid\n   * object.\n   */\n  values(object) {\n    return Reflect.entries.map(([,value]) => value)\n  }\n})\n", "import { Patch } from '@nejs/extension';\n\n/**\n * `StringExtensions` is a patch for the JavaScript built-in `String` class. It\n * adds utility methods to the `String` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `String` class with additional\n * utility functions.\n */\nexport const StringExtensions = new Patch(String, {\n  /**\n   * The `isString` method does exactly what one would it expect. It returns\n   * true if the string matches typeof or instanceof as a string.\n   *\n   * @param {*} value checks to see if the `value` is a string\n   * @returns {boolean} `true` if it is a `String`, `false` otherwise\n   */\n  isString(value) {\n    if (value && (typeof value === 'string' || value instanceof String)) {\n      return value.length > 0\n    }\n    return false\n  },\n});\n", "import { Patch } from '@nejs/extension';\n\n/**\n * `SymbolExtensions` is a patch for the JavaScript built-in `Symbol` class. It\n * adds utility methods to the `Symbol` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `Symbol` class with additional\n * utility functions.\n */\nexport const SymbolExtensions = new Patch(Symbol, {\n  /**\n   * The `isSymbol` method does exactly what one would it expect. It returns\n   * true if the string matches typeof or instanceof as a symbol.\n   *\n   * @param {*} value checks to see if the `value` is a string\n   * @returns {boolean} `true` if it is a `Symbol`, `false` otherwise\n   */\n  isSymbol(value) {\n    return value && (typeof value === 'symbol');\n  },\n\n  /**\n   * Returns true if the supplied value is a Symbol created using\n   * `Symbol.for()`.\n   *\n   * @param {any} value assumption is that the supplied value is of type\n   * 'symbol' however, unless `allowOnlySymbols` is set to `true`, `false`\n   * will be returned for any non-symbol values.\n   * @param {boolean} allowOnlySymbols true if an error should be thrown\n   * if the supplied value is not of type 'symbol'\n   * @returns true if the symbol is registered, meaning, none of the spec\n   * static symbols (`toStringTag`, `iterator`, etc...), and no symbols\n   * created by passing a value directly to the Symbol function, such as\n   * `Symbol('name')`\n   */\n  isRegistered(value, allowOnlySymbols = false) {\n    if (!Symbol.isSymbol(value)) {\n      if (allowOnlySymbols) {\n        throw new TypeError('allowOnlySymbols specified; value is not a symbol')\n      }\n      return false\n    }\n\n    return Symbol.keyFor(value) !== undefined\n  },\n\n  /**\n   * A function that returns true if the symbol is not registered, meaning,\n   * any of the spec static symbols (`toStringTag`, `iterator`, etc...), and\n   * any symbols created by passing a value directly to the `Symbol` function,\n   * such as `Symbol('name')`.\n   *\n   * @param {any} value assumption is that the supplied value is of type\n   * 'symbol' however, unless allowOnlySymbols is set to true, false will\n   * be returned for any non-symbol values.\n   * @param {boolean} allowOnlySymbols true if an error should be thrown\n   * if the supplied value is not of type 'symbol'\n   * @returns true if the symbol is not registered, meaning, any of the\n   * spec static symbols (`toStringTag`, `iterator`, etc...), and any symbols\n   * created by passing a value directly to the `Symbol` function, such as\n   * `Symbol('name')`\n   * @returns\n   */\n  isNonRegistered(value, allowOnlySymbols = false) {\n    return !Symbol.isRegistered(value, allowOnlySymbols)\n  },\n});\n", "import { Patch } from '@nejs/extension'\n\n/**\n * The `ArrayPrototypeExtensions` patch extends the prototype of the built-in\n * JavaScript `Array` with additional properties for convenience and improved\n * readability. By applying this patch, all array instances gain new getter\n * properties `first` and `last`, which provide quick access to the first and\n * last elements of the array, respectively. This enhancement simplifies common\n * operations on arrays and makes code more expressive and concise.\n */\nexport const ArrayPrototypeExtensions = new Patch(Array.prototype, {\n  /**\n   * Sometimes defining even a short function for the invocation of `find`\n   * can be troublesome. This helper function performs that job for you. If\n   * the specified element is in the array, `true` will be returned.\n   *\n   * @param {*} value the value to search for. This value must triple equals\n   * the array element in order to return true.\n   * @returns true if the exact element exists in the array, false otherwise\n   */\n  contains(value) {\n    return !!this.find(entry => entry === value)\n  },\n\n  /**\n   * The `findEntry` function searches the entries of the object and returns\n   * the `[index, value]` entry array for the first matching value found.\n   *\n   * @param {function} findFn a function that takes the element to be checked\n   * and returns a boolean value\n   * @returns if `findFn` returns `true`, an array with two elements, the first\n   * being the index, the second being the value, is returned.\n   */\n  findEntry(findFn) {\n    const entries = this.entries()\n    const VALUE = 1\n\n    for (let entry of entries) {\n      if (findFn(entry[VALUE])) {\n        return entry\n      }\n    }\n\n    return undefined\n  },\n\n  /**\n   * A getter property that returns the first element of the array. If the\n   * array is empty, it returns `undefined`. This property is useful for\n   * scenarios where you need to quickly access the first item of an array\n   * without the need for additional checks or method calls.\n   *\n   * @returns {*} The first element of the array or `undefined` if the array\n   * is empty.\n   */\n  get first() {\n    return this[0];\n  },\n\n  /**\n   * A getter property that returns the last element of the array. It\n   * calculates the last index based on the array's length. If the array is\n   * empty, it returns `undefined`. This property is beneficial when you need\n   * to access the last item in an array, improving code readability and\n   * avoiding manual index calculation.\n   *\n   * @returns {*} The last element of the array or `undefined` if the\n   * array is empty.\n   */\n  get last() {\n    return this[this.length - 1];\n  },\n\n})", "import { Extension } from '@nejs/extension'\nimport { ObjectExtensions } from './objectextensions.js'\nimport { StringExtensions } from './stringextensions.js'\nimport { ReflectExtensions } from './reflectextensions.js'\n\nconst isObject = ObjectExtensions.patchEntries?.isObject?.computed\nconst isValidKey = ObjectExtensions.patchEntries?.isValidKey?.computed\nconst isString = StringExtensions.patchEntries?.isString?.computed\nconst hasSome = ReflectExtensions.patchEntries?.hasSome?.computed\n\nclass Descriptor {\n  #desc = Descriptor.enigmatic\n\n  /**\n   * Creates a new instance of Descriptor either from another object or\n   * around the supplied object descriptor value.\n   *\n   * @param {object} object either an object descriptor or the object\n   * from which to get the descriptor\n   * @param {symbol|string} key a valid key for accessing the descriptor\n   * on the aforesupplied object.\n   */\n  constructor(object, key) {\n    this.#desc = object\n\n    if (isObject(object) && isValidKey(key)) {\n      this.#desc = Object.getOwnPropertyDescriptor(object, key)\n    }\n\n    if (!this.isDescriptor) {\n      throw new Error(`Not a valid descriptor:`, this.#desc)\n    }\n  }\n\n  /**\n   * Detects whether or not this instance is an accessor object descriptor\n   *\n   * @returns {boolean} true if this object has a getter or setter and is not\n   * a data descriptor\n   */\n  get isAccessor() {\n    return Descriptor.isAccessor(this.#desc)\n  }\n\n  /**\n   * Detects whether or not this instance is an data object descriptor\n   *\n   * @returns {boolean} true if this object has a value property and is not\n   * an accessor descriptor\n   */\n  get isData() {\n    return Descriptor.isData(this.#desc)\n  }\n\n  /**\n   * Detects whether or not this instance is a valid object descriptor\n   *\n   * @returns {boolean} true if this descriptor store is a valid descriptor\n   */\n  get isDescriptor() {\n    return Descriptor.isDescriptor(this.#desc)\n  }\n\n  /**\n   * Getter around the `configurable` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {boolean} a boolean value or undefined if the internal\n   * descriptor store is invalid.\n   */\n  get configurable() {\n    return !!this.#desc?.configurable\n  }\n\n  /**\n   * Sets the `configurable` value of this object. If the internal descriptor\n   * store store is invalid, the value is thrown away\n   *\n   * @param {boolean} value the value to set for the `configurable` descriptor\n   * property. If this value is not a `boolean` it will be converted to one\n   */\n  set configurable(value) {\n    (this.#desc || {}).configurable = !!value\n  }\n\n  /**\n   * Getter around the `enumerable` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {boolean} a boolean value or undefined if the internal\n   * descriptor store is invalid.\n   */\n  get enumerable() {\n    return this.#desc?.enumerable\n  }\n\n  /**\n   * Sets the `enumerable` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {boolean} value the value to set for the `enumerable` descriptor\n   * property. If this value is not a `boolean` it will be converted to one\n   */\n  set enumerable(value) {\n    (this.#desc || {}).enumerable = value\n  }\n\n  /**\n   * Getter around the `writable` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {boolean} a boolean value or undefined if the internal\n   * descriptor store is invalid.\n   */\n  get writable() {\n    return this.#desc?.writable\n  }\n\n  /**\n   * Sets the `writable` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {boolean} value the value to set for the `writable` descriptor\n   * property. If this value is not a `boolean` it will be converted to one\n   */\n  set writable(value) {\n    (this.#desc || {}).writable = value\n  }\n\n  /**\n   * Getter around the `value` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {any} any value stored in this descriptor\n   */\n  get value() {\n    return this.#desc?.value\n  }\n\n  /**\n   * Sets the `value` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {any} value the value to set for the `value` descriptor\n   * property.\n   */\n  set value(value) {\n    (this.#desc || {}).value = value\n  }\n\n  /**\n   * Getter around the `get` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {function} a function if the getter for this descriptor is\n   * defined or `undefined` if the internal descriptor object or the getter\n   * is undefined.\n   */\n  get get() {\n    return this.#desc?.get\n  }\n\n  /**\n   * Sets the `get` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {function} value the getter function for this descriptor\n   */\n  set get(value) {\n    (this.#desc || {}).get = value\n  }\n\n  /**\n   * Getter around the `set` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {function} a function if the setter for this descriptor is\n   * defined or `undefined` if the internal descriptor object or the setter\n   * is undefined.\n   */\n  get set() {\n    return this.#desc?.writable\n  }\n\n  /**\n   * Sets the `set` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {function} value the setter function for this descriptor\n   */\n  set set(value) {\n    (this.#desc || {}).set = value\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const type = this.isAccessor ? ' (Accessor)' : this.isData ? ' (Data)' : ''\n    return `Descriptor${type} ${inspect(this.#desc, {...options, depth})}`\n  }\n\n  /**\n   * Shorthand for Object.getOwnPropertyDescriptor()\n   *\n   * @param {object} object a non-null object instance\n   * @param {string|symbol} key a symbol or string referencing which key on the\n   * object to return a descriptor for.\n   * @returns an object descriptor for the requested field or null\n   */\n  static for(object, key) {\n    if (!isObject(object) && !isValidKey(key)) {\n      return null\n    }\n\n    return Object.getOwnPropertyDescriptor(object, key)\n  }\n\n  /**\n   * Take the descriptor defined by this objects values and apply them to\n   * the specified object using the specified key.\n   *\n   * @param {object} object the object to apply this descriptor to\n   * @param {string|symbol} forKey the string or symbol for which this\n   * descriptor will abe applied\n   */\n  applyTo(object, forKey) {\n    if (!isObject(object) || !isValidKey(forKey)) {\n      throw new Error(`Cannot apply descriptor to non-object or invalid key`)\n    }\n\n    return Object.defineProperty(object, forKey, this.#desc)\n  }\n\n  /**\n   * Converts this descriptor object into a base representation\n   *\n   * @param {string} hint one of `string`, `number` or default;\n   * @returns if the hint is 'string', then a string identifying the enum\n   * and its type is returned. `number` will always be NaN since it is incoret\n   */\n  [Symbol.toPrimitive](hint) {\n    switch (hint) {\n      case 'string':\n        if (this.isAccessor) {\n          const hasGetter = Reflect.has(this.#desc, 'get') ? `getter` : ''\n          const hasSetter = Reflect.has(this.#desc, 'set') ? `setter` : ''\n          const separator = hasGetter && hasSetter ? ', ' : ''\n\n          return `Accessor (${hasGetter}${separator}${hasSetter})`\n        }\n        else if (this.isData) {\n          const hasGetter = Reflect.has(this.#desc, 'value') ? `value` : ''\n          const hasSetter = Reflect.has(this.#desc, 'writable') ? `writable` : ''\n          const separator = hasGetter && hasSetter ? ', ' : ''\n\n          return `Data (${hasGetter}${separator}${hasSetter})`\n        }\n        break\n\n      case 'number':\n        return NaN\n\n      default:\n        return this.#desc\n    }\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * The function `getData` retrieves the value of a property from an object\n   * if it exists and is a data property.\n   *\n   * @param object - The \"object\" parameter is the object from which we want to\n   * retrieve data.\n   * @param property - The `property` parameter is the name of the property that\n   * you want to retrieve the data from.\n   * @returns either the value of the specified property if it exists and is\n   * a data property, or undefined if the property does not exist or is not\n   * a data property.\n   */\n  static getData(object, property) {\n    if (!isObject(object) || !isString(property)) {\n      return null;\n    }\n\n    const descriptors = Descriptor.all(object)\n    if (descriptors.has(property)) {\n      const descriptor = descriptors.get(property)\n\n      if (Descriptor.isData(descriptor)) {\n        return descriptor.value\n      }\n    }\n\n    return undefined\n  }\n\n  /**\n   * The function `getAccessor` checks if an object has a getter/setter accessor\n   * for a given property and returns the accessor functions if found.\n   *\n   * @param object - The `object` parameter is the object from which we want to\n   * retrieve the accessor for a specific property.\n   * @param property - The `property` parameter is the name of the property for\n   * which we want to get the accessor.\n   * @returns an object that contains the getter and setter functions for the\n   * specified property of the given object. If the property is an accessor\n   * property (defined with a getter and/or setter), the returned object will\n   * also have additional properties such as \"accessor\" and \"descriptor\". If\n   * the property is not found or is not an accessor property, the function\n   * returns undefined.\n   */\n  static getAccessor(object, property) {\n    if (!isObject(object))\n    return null\n\n    const [GETTER, SETTER, OBJECT] = [0, 1, 2]\n    const results = [undefined, undefined, undefined]\n    const descriptors = this.all(object)\n    const isDescriptor = Descriptor.isDescriptor(object)\n\n    if (descriptors.has(property) || isDescriptor) {\n      const descriptor = isDescriptor ? object : descriptors.get(property)\n\n      if (Descriptor.isAccessor(descriptor)) {\n        results[OBJECT] = descriptors.object(property)\n        results[GETTER] = descriptor?.get\n        results[SETTER] = descriptor?.set\n\n        Object.assign(results, {\n          get() { this[GETTER].bind(this[OBJECT])() },\n          set(value) { this[SETTER].bind(this[OBJECT])(value) },\n          get accessor() { return true },\n          get descriptor() { return descriptor },\n          get boundDescriptor() {\n            return {\n              ...descriptor,\n              get: descriptor.get?.bind(object),\n              set: descriptor.set?.bind(object),\n            }\n          }\n        })\n\n        return results\n      }\n    }\n\n    return undefined\n  }\n\n  /**\n   * The function returns an object with enumerable and configurable properties\n   * based on the input parameters.\n   *\n   * @param [enumerable=false] - A boolean value indicating whether the property\n   * can be enumerated (listed) when iterating over the object's properties.\n   * @param [configurable=false] - The `configurable` parameter determines\n   * whether the property can be deleted or its attributes can be modified.\n   * If `configurable` is set to `true`, the property can be deleted and its\n   * attributes can be changed. If `configurable` is set to `false`, the\n   * property cannot be deleted and\n   * @returns An object with the properties `enumerable` and `configurable` is\n   * being returned. The values of these properties are determined by the\n   * arguments passed to the `base` function.\n   */\n  static base(enumerable = false, configurable = false) {\n    return {\n      enumerable,\n      configurable\n    }\n  }\n\n  /**\n   * The function \"newAccessor\" creates a new property descriptor object with a\n   * getter and setter function, along with optional enumerable and configurable\n   * flags.\n   *\n   * @param getter - The getter parameter is a function that will be used as the\n   * getter for the property. It will be called when the property is accessed.\n   * @param setter - The `setter` parameter is a function that will be used as\n   * the setter for the property. It will be called whenever the property is\n   * assigned a new value.\n   * @param [] - - `getter`: A function that will be used as the getter for the\n   * property.\n   * @returns an object with properties \"get\", \"set\", \"enumerable\", and\n   * \"configurable\".\n   */\n  static accessor(\n    getter,\n    setter,\n    { enumerable, configurable } = Descriptor.base()\n  ) {\n    return {\n      get: getter,\n      set: setter,\n      enumerable,\n      configurable\n    }\n  }\n\n  /**\n   * The function \"newData\" creates a new data object with customizable\n   * properties.\n   *\n   * @param value - The value parameter represents the value that will be\n   * assigned to the property.\n   * @param [writable=true] - The `writable` parameter determines whether the\n   * value of the property can be changed. If `writable` is set to `true`, the\n   * value can be changed. If `writable` is set to `false`, the value cannot be\n   * changed.\n   * @param [] - - `value`: The value to be assigned to the property.\n   * @returns an object with properties `value`, `enumerable`, `writable`, and\n   * `configurable`.\n   */\n  static data(\n    value,\n    writable = true,\n    { enumerable, configurable } = Descriptor.base()\n  ) {\n    return {\n      value,\n      enumerable,\n      writable,\n      configurable\n    }\n  }\n\n  /**\n   * The function checks if an object is a valid object descriptor in\n   * JavaScript.\n   *\n   * @param object - The `object` parameter is the object that we want to\n   * check if it is a descriptor.\n   * @returns a boolean value.\n   */\n  static isDescriptor(object) {\n    const knownKeys = [\n      ...Descriptor.SHARED_KEYS,\n      ...Descriptor.ACCESSOR_KEYS,\n      ...Descriptor.DATA_KEYS,\n    ]\n\n    return hasSome(object, knownKeys)\n  }\n\n  /**\n   * The function checks if a given property or descriptor is a data property.\n   *\n   * @param descriptor_orProp - The `descriptor_orProp` parameter can be\n   * either a descriptor or a property name.\n   * @param object - The `object` parameter is the object that you want to\n   * check for data properties.\n   * @returns a boolean value. It returns `true` if the `descriptor` object\n   * has any keys that match the `DATA_KEYS` array, otherwise it returns\n   * `false`.\n   */\n  static isData(object_orProp, property) {\n    const needsDescriptor = (\n      ((typeof object_orProp === 'object') || object_orProp instanceof Object) &&\n      property instanceof String\n    )\n\n    const descriptor = (needsDescriptor\n      ? Descriptor.for(object_orProp, property)\n      : object_orProp\n    )\n\n    const { ACCESSOR_KEYS, DATA_KEYS } = this\n    let validData = false\n\n    if (hasSome(descriptor, ACCESSOR_KEYS)) {\n      validData = false\n    }\n    else if (hasSome(descriptor, DATA_KEYS)) {\n      validData = true\n    }\n\n    return validData\n  }\n\n  /**\n   * The function checks if a given property descriptor or property of an\n   * object is an accessor.\n   *\n   * @param object_orProp - The `descriptor_orProp` parameter can be either a\n   * descriptor object or a property name.\n   * @param property - The `object` parameter is the object that you want to\n   * check for accessor properties.\n   * @returns a boolean value. It returns true if the descriptor or property\n   * passed as an argument is an accessor descriptor, and false otherwise.\n   */\n  static isAccessor(object_orProp, property) {\n    const needsDescriptor = (\n      (object_orProp && property) &&\n      ((typeof object_orProp === 'object') || object_orProp instanceof Object) &&\n      (property instanceof String || (typeof property === 'symbol'))\n    )\n\n    const descriptor = (needsDescriptor\n      ? Descriptor.for(object_orProp, property)\n      : object_orProp)\n\n    const { ACCESSOR_KEYS, DATA_KEYS } = this\n    let validAccessor = false\n\n    if (hasSome(descriptor, DATA_KEYS)) {\n      validAccessor = false\n    }\n    else if (hasSome(descriptor, ACCESSOR_KEYS)) {\n      validAccessor = true\n    }\n\n    return validAccessor\n  }\n\n  /**\n   * A base descriptor (new for each read) that is both enumerable and\n   * configurable\n   *\n   * @returns The method `flexible` is returning the result of calling the\n   * `base` method with the arguments `true` and `true`.\n   */\n  static get flexible() {\n    return this.base(true, true)\n  }\n\n  /**\n   * A base descriptor (new for each read) that is not enumerable but is\n   * configurable\n   *\n   * @returns The method `enigmatic` is returning the result of calling\n   * the `base` method with the arguments `false` and `true`.\n   */\n  static get enigmatic() {\n    return this.base(false, true)\n  }\n\n  /**\n   * A base descriptor (new for each read) that is neither enumerable\n   * nor configurable\n   *\n   * @returns The code is returning the result of calling the `base` method with\n   * the arguments `false` and `false`.\n   */\n  static get intrinsic() {\n    return this.base(false, false)\n  }\n\n  /**\n   * A base descriptor (new for each read) that enumerable but not configurable\n   *\n   * @returns The method is returning the result of calling the `base`\n   * method with the arguments `true` and `false`.\n   */\n  static get transparent() {\n    return this.base(true, false)\n  }\n\n  /**\n   * The function returns an array of shared descriptor keys.\n   *\n   * @returns An array containing the strings 'configurable' and 'enumerable'.\n   */\n  static get SHARED_KEYS() {\n    return ['configurable', 'enumerable']\n  }\n\n  /**\n   * The function returns an array of accessor descriptor keys.\n   *\n   * @returns An array containing the strings 'get' and 'set' is being returned.\n   */\n  static get ACCESSOR_KEYS() {\n    return ['get', 'set']\n  }\n\n  /**\n   * The function returns an array of data descriptor keys.\n   *\n   * @returns An array containing the strings 'value' and 'writable' is being\n   * returned.\n   */\n  static get DATA_KEYS() {\n    return ['value', 'writable']\n  }\n}\n\nexport const DescriptorExtensions = new Extension(Descriptor)", "import { Patch } from '@nejs/extension'\nimport { FunctionExtensions } from './functionextensions.js'\n\nconst { isClass, isFunction } = FunctionExtensions.patchEntries.isClass.computed\nconst CustomInspect = Symbol.for('nodejs.util.inspect.custom')\n\nexport const GlobalFunctionsAndProps = new Patch(globalThis, {\n  /**\n   * Transforms an object to mimic a specified prototype, altering its type\n   * conversion and inspection behaviors. This function is especially useful\n   * for creating objects that need to behave like different primitive types\n   * under various operations.\n   *\n   * @param {Object} object - The object to be transformed.\n   * @param {Function|Object} [prototype=String.prototype] - The prototype or\n   * class to emulate. If a function is provided, its prototype is used.\n   * Defaults to String.prototype.\n   * @param {Function} [toPrimitive=(hint, val) => String(val)] - A function\n   * defining how the object should be converted to a primitive value. It\n   * receives a type hint ('number', 'string', or 'default') and the object,\n   * returning the primitive value.\n   * @returns {Object|null} The transformed object, or null if neither a class\n   * nor a prototype could be derived from the provided prototype parameter.\n   */\n  maskAs(object, classPrototype, options) {\n    const {\n      prototype,\n      toPrimitive\n    } = GenericMask({...options, prototype: classPrototype})\n\n    const base = { configurable: true, enumerable: false }\n    const proto = isFunction(prototype) ? prototype.prototype : prototype\n    const klass = isClass(prototype) ? prototype : proto?.constructor\n\n    if (!klass && !proto) {\n      return null\n    }\n\n    Object.setPrototypeOf(object, proto)\n    Object.defineProperties(object, {\n      valueOf: {\n        value() { return String(toPrimitive('default', object)) }, ...base },\n\n      [Symbol.toPrimitive]: {\n        value(hint) { return toPrimitive(hint, object) }, ...base\n      },\n      [Symbol.toStringTag]: { value: klass.name, ...base },\n      [Symbol.species]: { get() { return klass }, ...base },\n      [CustomInspect]: { ...base, value(depth, opts, inspect) {\n        return inspect(this[Symbol.toPrimitive](), { ...opts, depth })\n      }}\n    })\n\n    return object\n  },\n\n  /**\n   * Masks an object as a string-like object by setting its prototype to\n   * String and defining how it converts to primitive types. This is\n   * particularly useful when an object needs to behave like a string in\n   * certain contexts, such as type coercion or logging.\n   *\n   * @param {Object} object - The object to be masked as a string.\n   * @param {string} [stringKey='value'] - The object property key used for\n   * the string representation. Defaults to 'value'.\n   * @param {Function} [toPrimitive] - Optional custom function for primitive\n   * conversion. If omitted, a default function handling various conversion\n   * hints is used.\n   * @returns {Object|null} The string-masked object, or null if the object\n   * doesn't have the specified stringKey property.\n   */\n  maskAsString(\n    object,\n    stringKey,\n    toPrimitive\n  ) {\n    if (object && Reflect.has(object, stringKey)) {\n      return maskAs(object, StringMask(stringKey ?? 'value', toPrimitive))\n    }\n\n    return null\n  },\n\n  /**\n   * Masks an object as a number-like object. This allows the object to\n   * behave like a number in operations like arithmetic and type coercion.\n   * It sets the prototype to Number and defines custom conversion behavior.\n   *\n   * @param {Object} object - The object to be masked as a number\n   * representation. Defaults to 'value'.\n   * @param {Function} [toPrimitive] - Optional custom function for primitive\n   * conversion. If not provided, a default function handling different\n   * conversion hints is used.\n   * @returns {Object|null} The number-masked object, or null if the object\n   * doesn't have the specified numberKey property.\n   */\n  maskAsNumber(\n    object,\n    numberKey,\n    toPrimitive\n  ) {\n    if (object && Reflect.has(object, numberKey)) {\n      return maskAs(object, NumberMask(numberKey ?? 'value', toPrimitive))\n    }\n\n    return null\n  },\n\n  /**\n   * Generates options for generic masking of an object, providing defaults for\n   * prototype and toPrimitive function if not specified.\n   *\n   * @param {Object} options - The options object including prototype,\n   * targetKey, and toPrimitive function.\n   * @returns {Object} The options object with defaults applied as necessary.\n   */\n  GenericMask({ prototype, targetKey = 'value', toPrimitive }) {\n    const options = { targetKey, toPrimitive, prototype };\n\n    if (!isFunction(toPrimitive)) {\n      options.toPrimitive = (hint, object) => {\n        let property = object[targetKey];\n        let isNum = (\n          (typeof property === 'number' && Number.isFinite(property)) ||\n          (typeof property === 'string' &&\n            !isNaN(parseFloat(property)) && isFinite(property)\n          )\n        );\n\n        switch (hint) {\n          case 'string':\n            return isNum ? String(property) : (property ?? String(object));\n          case 'number':\n            return isNum ? Number(property) : NaN;\n          case 'default':\n          default:\n            return isNum ? Number(property) : property;\n        }\n      }\n    }\n\n    return options;\n  },\n\n  /**\n   * Generates options for string masking of an object, providing a default\n   * toPrimitive function if not specified.\n   *\n   * @param {string} targetKey - The object property key for string\n   * representation.\n   * @param {Function} toPrimitive - Custom function for primitive conversion.\n   * @returns {Object} Options for string masking.\n   */\n  StringMask(targetKey, toPrimitive) {\n    const options = { targetKey, toPrimitive, prototype: String.prototype }\n\n    if (!isFunction(toPrimitive)) {\n      options.toPrimitive = function toPrimitive(hint, object) {\n        switch (hint) {\n          case 'default': return object[targetKey]\n          case 'number': return parseInt(object[targetKey], 36)\n          case 'string': return String(object[targetKey])\n          default: return object\n        }\n      }\n    }\n\n    return options\n  },\n\n  /**\n   * Generates options for number masking of an object, providing a default\n   * toPrimitive function if not specified.\n   *\n   * @param {string} targetKey - The object property key for number\n   * representation.\n   * @param {Function} toPrimitive - Custom function for primitive conversion.\n   * @returns {Object} Options for number masking.\n   */\n  NumberMask(targetKey, toPrimitive) {\n    const options = { targetKey, toPrimitive, prototype: Number.prototype }\n\n    if (!isFunction(toPrimitive)) {\n      options.toPrimitive = function toPrimitive(hint, object) {\n        switch (hint) {\n          case 'default': return object[targetKey]\n          case 'number': return Number(object[targetKey])\n          case 'string': return String(object[targetKey])\n          default: return object\n        }\n      }\n    }\n\n    return options\n  },\n})\n", "import { Extension } from '@nejs/extension'\n\n/**\n * RefSet class extends the standard Set object to manage a collection of\n * WeakRef objects. It provides additional functionality such as objectification\n * of values and various utility methods.\n *\n * Unlike standard Sets or Arrays, RefSet stores weak references to objects,\n * allowing them to be garbage-collected if there are no other references to\n * them. This behavior is different from Arrays and standard Sets, which\n * maintain strong references to their elements.\n *\n * @extends Set\n */\nclass RefSet extends Set {\n  /**\n   * Private field to track whether the RefSet should objectify primitive\n   * values.\n   *\n   * @private\n   */\n  #objectifyValues = false\n\n  /**\n   * Method to control whether the RefSet should objectify its values. When\n   * objectifying, primitive values (number, string, boolean, bigint) are\n   * converted to their respective object types, which allows them to be used as\n   * WeakRef targets.\n   *\n   * @param {boolean} setObjectification - Flag to enable or disable\n   * objectification.\n   * @returns {RefSet} - The current RefSet instance to allow method chaining.\n   */\n  objectifying(setObjectification = true) {\n    this.objectifyValues = setObjectification\n    return this\n  }\n\n  /**\n   * Returns the state indicating whether or not `RefSet` will attempt to\n   * convert non-valid primitives into targets that are valid input for\n   * new `WeakRef` object instances. If this value is `false` then no\n   * *objectification* will occur.\n   *\n   * @returns {boolean} The current state of objectifyValues.\n   */\n  get objectifyValues() {\n    return this.#objectifyValues\n  }\n\n  /**\n   * Setting this value to true, will cause all added values to the Set to\n   * be analyzed for validity as a candidate to be wrapped in a `WeakRef`\n   * object. If true, and if possible, the object will be turned into an\n   * `Object` variant first. This will also enable less rigid variable\n   * comparison in the `.has()` method (i.e. `==` instead of `===`).\n   *\n   * @param {boolean} value - The new state to set for objectifyValues.\n   */\n  set objectifyValues(value) {\n    this.#objectifyValues = !!value\n  }\n\n  /**\n   * Overrides the add method of Set. Adds a value to the RefSet, converting it\n   * to a WeakRef. Throws an error if the value is not a valid WeakRef target\n   * (e.g., null, undefined, or a registered symbol). If `objectifyValues` is\n   * enabled, an attempt to convert primitives to their object variants will be\n   * made. These are numbers, strings, boolean values and big integers.\n   *\n   * @param {*} value - The value to be added to the RefSet.\n   * @throws {TypeError} If the value is not a valid WeakRef target.\n   */\n  add(value) {\n    // Objectify the value if needed\n    if (this.#objectifyValues && (\n      typeof value === 'number' ||\n      typeof value === 'string' ||\n      typeof value === 'boolean' ||\n      typeof value === 'bigint'\n    )) {\n      value = Object(value);\n    }\n\n    // Check if the value is an object, and if it's a symbol, ensure it's not registered\n    if (typeof value === 'symbol' && Symbol.keyFor(value) !== undefined) {\n      throw new TypeError('RefSet cannot accept registered symbols as values');\n    }\n\n    if (typeof value !== 'object' && typeof value !== 'symbol') {\n      throw new TypeError(\n        'RefSet values must be objects, non-registered symbols, or objectified primitives'\n      );\n    }\n\n    // If the value is null or undefined, throw an error\n    if (value === null || value === undefined) {\n      throw new TypeError('RefSet values cannot be null or undefined');\n    }\n\n    super.add(new WeakRef(value));\n  }\n\n  /**\n   * Adds multiple values to the RefSet. The supplied `values` should be\n   * iterable and truthy. This function defers to `.add()` for its logic so\n   * each value from the supplied collection of values will also be subject\n   * to the criteria of that function.\n   *\n   * @param {Iterable} values - An iterable of values to add to the RefSet.\n   * @throws {TypeError} If the supplied values are falsey or non-iterable.\n   */\n  addAll(values) {\n    if (\n      !values ||\n      (typeof values !== 'object') ||\n      !Reflect.has(values, Symbol.iterator)\n    ) {\n      throw new TypeError('The supplied values are either falsey or non-iterable')\n    }\n\n    for (const value of values) {\n      this.add(value)\n    }\n  }\n\n  /**\n   * Removes all elements from the RefSet that have been garbage collected\n   * (i.e., their WeakRef no longer points to an object).\n   *\n   * @returns {RefSet} - The current RefSet instance to allow method chaining.\n   */\n  clean() {\n    for (const ref of this) {\n      if (!ref.deref()) {\n        this.delete(ref)\n      }\n    }\n\n    return this\n  }\n\n/**\n * Executes a provided function once for each value in the RefSet. The callback\n * function receives the dereferenced value, the value again (as RefSet doesn't\n * use keys), and the RefSet itself. This method provides a way to iterate over\n * and apply operations to the values stored in the RefSet, taking into account\n * that they are weak references and may have been garbage-collected.\n *\n * @param {Function} forEachFn - Function to execute for each element. It\n * takes three arguments: element, element (again, as RefSet has no key), and\n * the RefSet itself.\n * @param {*} thisArg - Value to use as `this` when executing `forEachFn`.\n */\nentries() {\n    const refEntries = super.entries()\n\n    return refEntries\n      .map(([_, ref]) => [ref.deref(), ref.deref()])\n      .filter(([_, value]) => !!value)\n  }\n\n  forEach(forEachFn, thisArg) {\n    const set = this\n\n    super.forEach(function(ref) {\n      const value = ref.deref()\n\n      if (!value) {\n        return\n      }\n\n      forEachFn.call(thisArg, value, value, set)\n    })\n  }\n\n  /**\n   * Returns an iterator for the values in the RefSet. Each value is\n   * dereferenced from its WeakRef before being returned. This method allows\n   * iterating over he set's values, similar to how one would iterate over\n   * values in a standard Set or Array, but with the understanding that the\n   * values are weakly referenced and may no longer exist (in which case\n   * they are skipped).\n   *\n   * @returns {Iterator} An iterator for the values.\n   */\n  values() {\n    const values = []\n\n    for (const value of this) {\n      const dereferenced = value.deref()\n\n      if (dereferenced) {\n        values.push(dereferenced)\n      }\n    }\n\n    return values\n  }\n\n  /**\n   * Returns an iterator for the keys of the RefSet. In RefSet, keys and\n   * values are identical, so this method behaves the same as `values()`. It\n   * provides compatibility with the standard Set interface and allows use in\n   * contexts where keys are expected, despite RefSet not differentiating\n   * between keys and values.\n   *\n   * @returns {Iterator} An iterator for the keys.\n   */\n  keys() {\n    return this.values()\n  }\n\n  /**\n   * Determines whether an element with the specified value exists in the\n   * `RefSet`. For non-objectified sets, this method checks if the dereferenced\n   * values of the set include the specified value.\n   *\n   * For objectified sets, it uses the `contains` method which accounts for\n   * the objectification. This method differs from standard Set `has` in that\n   * it works with weak references and considers objectification settings.\n   *\n   * @param {*} value - The value to check for presence in the RefSet.\n   * @returns {boolean} - True if an element with the specified value exists\n   * in the RefSet, false otherwise.\n   */\n  has(value) {\n    if (this.#objectifyValues) {\n      return this.contains(value)\n    }\n\n    for (const item of this.values()) {\n      if (item === value) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Checks if the RefSet contains a value that is equal to the specified\n   * value. This method is used primarily in objectified RefSets to determine\n   * the presence of a value, taking into account objectification. It differs\n   * from the `has` method in that it's tailored for sets that have\n   * transformed their primitive values into objects, whereas `has` is more\n   * general-purpose.\n   *\n   * @param {*} value - The value to search for in the RefSet.\n   * @returns {boolean} - True if the RefSet contains the value, false otherwise.\n   */\n  contains(value) {\n    return !!(Array.from(this.values())\n      .filter(dereferencedValue => {\n       return value == dereferencedValue\n      })\n      .length\n    )\n  }\n\n  /**\n   * Creates a new array with all elements that pass the test implemented by\n   * the provided function. This method iterates over each element,\n   * dereferences it, and applies the filter function. Unlike Array `filter`,\n   * the callback receives the dereferenced value and not an index or array,\n   * reflecting the non-indexed nature of RefSet. Useful for selectively\n   * creating arrays from the set based on certain conditions, especially when\n   * dealing with weak references.\n   *\n   * @param {Function} filterFn - Function to test each element of the RefSet.\n   * The function receives the dereferenced value.\n   * @param {*} thisArg - Value to use as `this` when executing `filterFn`.\n   * @returns {Array} - A new array with the elements that pass the test.\n   */\n  filter(filterFn, thisArg) {\n    const results = []\n\n    for (const value of this) {\n      const dereferenced = value?.deref()\n\n      if (dereferenced) {\n        const include = filterFn.call(thisArg, dereferenced, NaN, this)\n\n        if (include) {\n          results.push(dereferenced)\n        }\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * Returns the value of the first element in the RefSet that satisfies the\n   * provided testing function. Similar to Array `find`, this method iterates\n   * over the RefSet, dereferencing each value and applying the testing\n   * function. The non-indexed nature of RefSet is considered, as the\n   * callback does not receive an index. This method is useful for finding a\n   * specific element based on a condition.\n   *\n   * @param {*} thisArg - Value to use as this when executing findFn.\n   * @returns {*} - The value of the first element in the RefSet that satisfies\n   * the testing function, or undefined if none found.\n   * @returns\n   */\n  find(findFn, thisArg) {\n    for (const value of this) {\n      const dereferenced = value?.deref()\n\n      if (dereferenced) {\n        const found = findFn.call(thisArg, dereferenced, NaN, this)\n\n        if (found) {\n          return dereferenced\n        }\n      }\n    }\n\n    return undefined\n  }\n\n  /**\n   * Creates a new array or `RefSet` with the results of calling a provided\n   * function on every element in the calling `RefSet`. This method dereferences\n   * each value, applies the `mapFn`, and collects the results. If `toRefSet` is\n   * `true`, a new `RefSet` is returned; otherwise, an array. This method\n   * differs from `Array.map` in handling weak references and the potential to\n   * return a new `RefSet` instead of an array.\n   *\n   * @param {Function} mapFn - Function that produces an element of the new\n   * array or `RefSet`, taking three arguments.\n   * @param {*} thisArg - Value to use as this when executing mapFn.\n   * @param {boolean} toRefSet - Determines if the output should be a new\n   * `RefSet` (`true`) or an array (`false`).\n   * @param {boolean} mirrorObjectification - If `true` and `toRefSet` is\n   * `true`, the new `RefSet` mirrors the objectification setting of the\n   * original.\n   * @returns {Array|RefSet} - A new array or `RefSet` with each element being\n   * the result of the `mapFn`.\n   */\n  map(mapFn, thisArg, toRefSet, mirrorObjectification) {\n    const mapped = []\n\n    let validRefSetOutput = true\n    let validRefSetOutputIfObjectified = true\n\n    for (const value of this) {\n      const dereferenced = value?.deref()\n\n      if (dereferenced) {\n        const mappedItem = mapFn.call(thisArg, dereferenced, NaN, this)\n\n        if (validRefSetOutput || validRefSetOutputIfObjectified) {\n          const weakReferenceable = this.#validWeakRefTarget(mappedItem)\n\n          if (!weakReferenceable) {\n            validRefSetOutput = false\n\n            if (validRefSetOutputIfObjectified) {\n              validRefSetOutputIfObjectified =\n                this.#validWeakRefTarget(Object(mappedItem))\n            }\n          }\n        }\n\n        mapped.push(mappedItem)\n      }\n    }\n\n    if (toRefSet) {\n      if (validRefSetOutput) {\n        return new RefSet(mapped).objectifying(\n          mirrorObjectification ? this.objectifyValues : false\n        )\n      }\n\n      if (validRefSetOutputIfObjectified) {\n        return new RefSet(mapped.map(value => {\n          return this.#validWeakRefTarget(value) ? value : Object(value)\n        })).objectifying()\n      }\n    }\n\n    return mapped\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Private method to check if a given value is a valid target for a WeakRef.\n   *\n   * @param {*} value - The value to check for validity as a WeakRef target.\n   * @returns {boolean} - True if the value is a valid WeakRef target,\n   * false otherwise.\n   * @private\n   */\n  #validWeakRefTarget(value) {\n    return !(\n      (typeof value === 'symbol' && Symbol.keyFor(value) === undefined) ||\n      (typeof value !== 'object' && typeof value !== 'symbol') ||\n      (value === null || value === undefined)\n    )\n  }\n}\n\nexport const RefSetExtensions = new Extension(RefSet)", "import { Extension } from '@nejs/extension'\n\n/**\n * The AsyncIterable class extends the concept of Iterable to asynchronous\n * operations. It allows creating iterable objects where each element can be\n * an asynchronous entity, like a Promise. This class is particularly useful\n * when dealing with asynchronous data sources, such as API responses, file\n * reading in chunks, or any other data that is not immediately available but\n * arrives over time.\n */\nclass AsyncIterable {\n  /**\n   * Private field to store the elements of the async iterable.\n   * @private\n   */\n  #elements = [];\n\n  /**\n   * Constructs an instance of AsyncIterable. Similar to Iterable, it can be\n   * initialized with either an iterable object or individual elements. The\n   * elements can be promises, direct values, or a mix of both. If the first\n   * argument is an iterable, the instance is initialized with the elements\n   * from the iterable, followed by any additional arguments. If the first\n   * argument is not an iterable, all arguments are treated as individual\n   * elements.\n   *\n   * @param {Iterable|Promise|*} elementsOrFirstElement - An iterable object,\n   * a Promise, or the first element.\n   * @param {...Promise|*} moreElements - Additional elements if the first\n   * argument is not an iterable.\n   */\n  constructor(elementsOrFirstElement, ...moreElements) {\n    if (\n      elementsOrFirstElement != null &&\n      typeof elementsOrFirstElement[Symbol.iterator] === 'function'\n    ) {\n      this.#elements = [...elementsOrFirstElement, ...moreElements];\n    } else {\n      this.#elements = [elementsOrFirstElement, ...moreElements];\n    }\n  }\n\n  /**\n   * Implements the async iterable protocol. When an instance of AsyncIterable\n   * is used in a `for await...of` loop, this async generator function is\n   * invoked. It yields each element as a Promise, allowing asynchronous\n   * iteration. Elements that are not Promises are automatically wrapped in\n   * a resolved Promise to ensure consistency.\n   *\n   * @returns {AsyncGenerator} An async generator that yields each element as\n   * a Promise.\n   */\n  async *[Symbol.asyncIterator]() {\n    for (const element of this.#elements) {\n      // Treat each element as a promise. If it's not, it's automatically\n      // wrapped as a resolved promise.\n      yield Promise.resolve(element);\n    }\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Being able to create a compliant `AsyncIterator` around any type of\n   * iterable object. This can be wrapped around any type of object that\n   * has a `[Symbol.asyncIterator]` property assigned to a generator\n   * function.\n   */\n  static AsyncIterator = class AsyncIterator {\n    /**\n     * Creates a new `AsyncIterator` object instance.\n     *\n     * @param {object} asyncIterable any object that has a\n     * `[Symbol.asyncIterable]` property assigned to a generator function.\n     */\n    constructor(asyncIterable) {\n      if (!asyncIterable || !Reflect.has(asyncIterable, Symbol.asyncIterator)) {\n        throw new TypeError(\n          'Value used to instantiate AsyncIterator is not an async iterable'\n        );\n      }\n\n      this.#asyncIterable = asyncIterable;\n      this.#asyncIterator = asyncIterable[Symbol.asyncIterator]();\n    }\n\n    /**\n     * Returns a new `Array` derived from the iterable this object\n     * wraps.\n     *\n     * @returns {array} a new `Array` generated from the wrapped\n     * iterable. The method is generated from using an async for of\n     * loop.\n     */\n    async asArray() {\n      const array = []\n\n      for await (const value of this) {\n        array.push(value)\n      }\n\n      return array\n    }\n\n    /**\n     * Returns the actual iterable object passed to the constructor that\n     * created this instance.\n     *\n     * @returns {object} the object containing the `[Symbol.iterator]`\n     */\n    get asyncIterable() {\n      return this.#asyncIterable\n    }\n\n    /**\n     * The function retrieves the next value in the iterator. If the\n     * the iterator has run its course, `reset()` can be invoked to\n     * reset the pointer to the beginning of the iteration.\n     *\n     * @returns {any} the next value\n     */\n    async next() {\n      const result = await this.#asyncIterator.next();\n      if (result.done) {\n        return { value: undefined, done: true };\n      } else {\n        return { value: result.value, done: false };\n      }\n    }\n\n    /**\n     * Resets the async iterator to the beginning allowing it to be\n     * iterated over again.\n     */\n    async reset() {\n      this.#asyncIterator = this.#asyncIterable[Symbol.asyncIterator]();\n    }\n\n    /**\n     * The existence of this symbol on the object instances, indicates that\n     * it can be used in `for(.. of ..)` loops and its values can be\n     * extracted from calls to `Array.from()`\n     *\n     * @returns {AsyncIterable} this is returned since this object is already\n     * conforming to the expected JavaScript AsyncIterator interface\n     */\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n    /**\n     * Ensures that the constructor of this object instance's name\n     * is returned if the string tag for this instance is queried\n     *\n     * @returns {string} the name of the class\n     */\n    get [Symbol.toStringTag]() {\n      return this.constructor.name;\n    }\n\n    /**\n     * The object from which its iterator functionality is derived.\n     *\n     * @type {object}\n     * @private\n     */\n    #asyncIterable = null;\n\n    /**\n     * The results of a call to the iterable's `[Symbol.asyncIterator]`\n     * generator function.\n     *\n     * @type {object}\n     * @private\n     */\n    #asyncIterator = null;\n  }\n\n  /**\n   * Checks if a given value is an async iterable. This method determines if\n   * the provided value has a `Symbol.asyncIterator` property that is an async\n   * generator function. It's a precise way to identify if the value conforms\n   * to the async iterable protocol using an async generator function.\n   *\n   * Note: This method specifically checks for async generator functions. Some\n   * async iterables might use regular async functions that return an async\n   * iterator, which this method won't identify.\n   *\n   * @param {*} value - The value to be checked for async iterability.\n   * @returns {boolean} - Returns true if the value is an async iterable\n   * implemented using an async generator function, false otherwise.\n   */\n  static isAsyncIterable(value) {\n    const type = Object.prototype.toString.call(value?.[Symbol.asyncIterator]);\n    return type === '[object AsyncGeneratorFunction]';\n  }\n}\n\nexport const AsyncIterableExtensions = new Extension(AsyncIterable)\nexport const AsyncIteratorExtensions = new Extension(AsyncIterable.AsyncIterator)", "import { Extension } from '@nejs/extension'\n\n/**\n * The Iterable class is designed to provide a convenient way to create synchronous\n * iterable objects. It can be initialized with either an array or individual elements.\n * This class implements the iterable protocol, allowing instances to be used with\n * `for...of` loops and other standard JavaScript iteration mechanisms.\n */\nclass Iterable {\n  /**\n   * Private field to store the elements of the iterable.\n   * @private\n   */\n  #elements = [];\n\n  /**\n   * Constructs an instance of Iterable. It can be initialized with either an\n   * iterable object (such as an array, Set, Map, string, or any object\n   * implementing the iterable protocol) or individual elements. If the first\n   * argument is an iterable, the class instance is initialized with the\n   * elements from the iterable, followed by any additional arguments. If the\n   * first argument is not an iterable, all arguments are treated as individual\n   * elements.\n   *\n   * @param {Iterable|*} elementsOrFirstElement - An iterable object or the\n   * first element.\n   * @param {...*} moreElements - Additional elements if the first argument is\n   * not an iterable.\n   */\n  constructor(elementsOrFirstElement, ...moreElements) {\n    if (\n      elementsOrFirstElement != null &&\n      typeof elementsOrFirstElement[Symbol.iterator] === 'function'\n    ) {\n      this.#elements = [...elementsOrFirstElement, ...moreElements];\n    } else {\n      this.#elements = [elementsOrFirstElement, ...moreElements];\n    }\n  }\n\n  /**\n   * Implements the iterable protocol. When an instance of Iterable is used\n   * in a `for...of` loop or spread syntax, this generator function is invoked\n   * to yield the elements one by one in a synchronous manner.\n   *\n   * @returns {Generator} A generator that yields each element of the iterable.\n   */\n  *[Symbol.iterator]() {\n    for (const element of this.#elements) {\n      yield element;\n    }\n  }\n\n  /**\n   * Provides access to the elements as a standard array. Useful for scenarios\n   * where array methods and behaviors are needed.\n   *\n   * @returns {Array} An array containing all the elements of the iterable.\n   */\n  get asArray() {\n    return this.#elements;\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Being able to create a compliant `Iterator` around any type of iterable\n   * object. This can be wrapped around any type of object that has a\n   * `[Symbol.iterator]` property assigned to a generator function.\n   */\n  static Iterator = class Iterator {\n    /**\n     * Creates a new `Iterator` object instance.\n     *\n     * @param {object} iterable any object that has a `[Symbol.iterator]`\n     * property assigned to a generator function.\n     */\n    constructor(iterable) {\n      if (!iterable || !Reflect.has(iterable, Symbol.iterator)) {\n        throw new TypeError(\n          'Value used to instantiate Iterator is not iterable'\n        );\n      }\n\n      this.#iterable = iterable;\n      this.#iterator = iterable[Symbol.iterator]();\n    }\n\n    /**\n     * Returns a new `Array` derived from the iterable this object\n     * wraps.\n     *\n     * @returns {array} a new `Array` generated from the wrapped\n     * iterable. The method is generated from `Array.from()`\n     */\n    get asArray() {\n      return Array.from(this.#iterable)\n    }\n\n    /**\n     * Returns the actual iterable object passed to the constructor that\n     * created this instance.\n     *\n     * @returns {object} the object containing the `[Symbol.iterator]`\n     */\n    get iterable() {\n      return this.#iterable\n    }\n\n    /**\n     * The function retrieves the next value in the iterator. If the\n     * the iterator has run its course, `reset()` can be invoked to\n     * reset the pointer to the beginning of the iteration.\n     *\n     * @returns {any} the next value\n     */\n    next() {\n      const result = this.#iterator.next();\n      if (result.done) {\n        return { value: undefined, done: true };\n      } else {\n        return { value: result.value, done: false };\n      }\n    }\n\n    /**\n     * Resets the iterator to the beginning allowing it to be\n     * iterated over again.\n     */\n    reset() {\n      this.#iterator = this.#iterable[Symbol.iterator]();\n    }\n\n    /**\n     * The existence of this symbol on the object instances, indicates that\n     * it can be used in `for(.. of ..)` loops and its values can be\n     * extracted from calls to `Array.from()`\n     *\n     * @returns {Iterator} this is returned since this object is already\n     * conforming to the expected JavaScript Iterator interface\n     */\n    [Symbol.iterator]() {\n      return this;\n    }\n\n    /**\n     * Ensures that the constructor of this object instance's name\n     * is returned if the string tag for this instance is queried\n     *\n     * @returns {string} the name of the class\n     */\n    get [Symbol.toStringTag]() {\n      return this.constructor.name\n    }\n\n    /**\n     * The object from which its iterator functionality is derived.\n     *\n     * @type {object}\n     * @private\n     */\n    #iterable = null;\n\n    /**\n     * The results of a call to the iterable's `[Symbol.iterator]`\n     * generator function.\n     *\n     * @type {object}\n     * @private\n     */\n    #iterator = null;\n  }\n\n  /**\n   * Checks if a given value is an iterable. This method determines if the\n   * provided value has a `Symbol.iterator` property that is a generator\n   * function. It's a precise way to identify if the value conforms to the\n   * iterable protocol using a generator function.\n   *\n   * Note: This method specifically checks for generator functions. Some\n   * iterables might use regular functions that return an iterator, which\n   * this method won't identify.\n   *\n   * @param {*} value - The value to be checked for iterability.\n   * @returns {boolean} - Returns true if the value is an iterable implemented\n   * using a generator function, false otherwise.\n   */\n  static isIterable(value) {\n    const type = Object.prototype.toString.call(value?.[Symbol.iterator]);\n    return type === '[object GeneratorFunction]';\n  }\n}\n\nexport const IterableExtensions = new Extension(Iterable)\nexport const IteratorExtensions = new Extension(Iterable.Iterator)"],
  "mappings": "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",
  "names": ["src_exports", "__export", "ArrayPrototypeExtensions", "AsyncIterableExtensions", "AsyncIteratorExtensions", "DescriptorExtensions", "FunctionExtensions", "GlobalFunctionsAndProps", "IterableExtensions", "IteratorExtensions", "ObjectExtensions", "RefSetExtensions", "ReflectExtensions", "StringExtensions", "SymbolExtensions", "all", "disableAll", "disableNetNew", "enableAll", "enableNetNew", "typeOf", "o", "CannotBeExtendedError", "owner", "key", "typeOf", "o", "MissingOwnerValue", "owner", "key", "PatchToggle", "patch", "preventRevert", "depth", "options", "inspect", "objName", "status", "Patch", "_Patch", "owner", "patches", "options", "key", "#PatchEntry", "patch", "preventRevert", "PatchToggle", "property", "owningObject", "depth", "inspect", "Extension", "_Extension", "Patch", "keyClassOrFn", "value", "owner", "options", "key", "extension", "valid", "MissingOwnerValue", "descriptor", "CannotBeExtendedError", "input", "depth", "inspect", "FunctionExtensions", "Patch", "value", "stringTag", "ObjectExtensions", "Patch", "value", "owner", "stringTag", "object", "keys", "bindAccessors", "result", "key", "descriptor", "ReflectExtensions", "Patch", "object", "keys", "key", "has", "result", "revertOnDone", "ObjectExtensions", "value", "StringExtensions", "Patch", "value", "SymbolExtensions", "Patch", "value", "allowOnlySymbols", "ArrayPrototypeExtensions", "Patch", "value", "entry", "findFn", "entries", "VALUE", "isObject", "ObjectExtensions", "isValidKey", "isString", "StringExtensions", "hasSome", "ReflectExtensions", "Descriptor", "_Descriptor", "#desc", "object", "key", "value", "depth", "options", "inspect", "forKey", "hint", "hasGetter", "hasSetter", "property", "descriptors", "descriptor", "GETTER", "SETTER", "OBJECT", "results", "isDescriptor", "enumerable", "configurable", "getter", "setter", "writable", "knownKeys", "object_orProp", "ACCESSOR_KEYS", "DATA_KEYS", "validData", "validAccessor", "DescriptorExtensions", "Extension", "isClass", "isFunction", "FunctionExtensions", "CustomInspect", "GlobalFunctionsAndProps", "Patch", "object", "classPrototype", "options", "prototype", "toPrimitive", "base", "proto", "klass", "hint", "depth", "opts", "inspect", "stringKey", "numberKey", "targetKey", "property", "isNum", "RefSet", "_RefSet", "#objectifyValues", "setObjectification", "value", "values", "ref", "_", "forEachFn", "thisArg", "set", "dereferenced", "item", "dereferencedValue", "filterFn", "results", "findFn", "mapFn", "toRefSet", "mirrorObjectification", "mapped", "validRefSetOutput", "validRefSetOutputIfObjectified", "mappedItem", "#validWeakRefTarget", "RefSetExtensions", "Extension", "AsyncIterable", "#elements", "elementsOrFirstElement", "moreElements", "element", "asyncIterable", "#asyncIterable", "#asyncIterator", "array", "value", "result", "AsyncIterableExtensions", "Extension", "AsyncIteratorExtensions", "Iterable", "#elements", "elementsOrFirstElement", "moreElements", "element", "iterable", "#iterable", "#iterator", "result", "value", "IterableExtensions", "Extension", "IteratorExtensions", "Owners", "NetNew", "GlobalFunctionsAndProps", "DescriptorExtensions", "AsyncIterableExtensions", "AsyncIteratorExtensions", "IterableExtensions", "IteratorExtensions", "RefSetExtensions", "enableAll", "owners", "list", "owner", "Patch", "enableNetNew", "extension", "disableAll", "disableNetNew", "all", "ObjectExtensions", "FunctionExtensions", "ReflectExtensions", "StringExtensions", "SymbolExtensions", "ArrayPrototypeExtensions", "accumulator", "_", "key"]
}
