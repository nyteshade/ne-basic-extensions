var nejsBasicExtensions=(()=>{var D=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var W=Object.prototype.hasOwnProperty;var H=(r,t)=>{for(var e in t)D(r,e,{get:t[e],enumerable:!0})},J=(r,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of U(t))!W.call(r,n)&&n!==e&&D(r,n,{get:()=>t[n],enumerable:!(s=B(t,n))||s.enumerable});return r};var L=r=>J(D({},"__esModule",{value:!0}),r);var rt={};H(rt,{ArrayPrototypeExtensions:()=>I,AsyncIterableExtensions:()=>k,AsyncIteratorExtensions:()=>F,DescriptorExtensions:()=>x,FunctionExtensions:()=>y,GlobalFunctionsAndProps:()=>A,IterableExtensions:()=>C,IteratorExtensions:()=>V,ObjectExtensions:()=>p,RefSetExtensions:()=>$,ReflectExtensions:()=>b,StringExtensions:()=>S,SymbolExtensions:()=>j,all:()=>et,disableAll:()=>tt,disableNetNew:()=>M,enableAll:()=>_,enableNetNew:()=>G});var q=r=>/(\w+)]/.exec(Object.prototype.toString.call(r))[1],d=class extends Error{constructor(t,e){super(`${q(t)} disallows tampering with ${e}.`),Object.assign(this,{owner:t,key:e})}get[Symbol.toStringTag](){return this.constructor.name}};var z=r=>/(\w+)]/.exec(Object.prototype.toString.call(r))[1],m=class extends Error{constructor(t,e){super(`${z(t)} does not have a property named '${e}'.`),Object.assign(this,{owner:t,key:e})}get[Symbol.toStringTag](){return this.constructor.name}};var g=class{constructor(t,e=!1){this.started=!1,this.preventRevert=e,this.patch=t,this.patchName=t.owner?.name??t.owner?.constructor?.name??/(\w+)]/.exec(Object.prototype.toString.call(t.owner))[1],this.state={needsApplication:!1,needsReversion:!1}}start(){return this.started||(this.state.needsApplication=!this.patch.applied,this.state.needsReversion=this.patch.applied,this.started=!0,this.state.needsApplication&&this.patch.apply()),this}stop(){return this.started&&((this.preventRevert||this.patch.applied)&&this.patch.revert(),this.state.needsApplication=!1,this.state.needsReversion=!1,this.started=!1),this}get[Symbol.toStringTag](){return`${this.constructor.name}:${this.patchName}`}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){let n=this[Symbol.toStringTag],i=`(started: ${this.started} needed: ${this.state.needsApplication})`;return s(`${n} ${i}`,{...e,depth:t})}};var c=class r{constructor(t,e,s={}){Object.assign(this,{owner:t,options:s,applied:!1}),this.patchConflicts={},this.patchEntries={},this.patchesOwner=e,Reflect.ownKeys(e).forEach(n=>{this.patchEntries[n]=new r.#t(n,this.patchesOwner),Reflect.has(this.owner,n)&&(this.patchConflicts[n]=new r.#t(n,this.owner))}),r.patches.has(t)||r.patches.set(t,[]),r.patches.get(t).push(this)}get patches(){return Reflect.ownKeys(this.patchEntries).map(t=>[t,this.patchEntries[t]])}get patchValues(){return this.patches.reduce((t,[e,s])=>(t[e]=s.computed,t),{})}get conflicts(){return Reflect.ownKeys(this.patchConflicts).map(t=>[t,this.patchConflicts[t]])}apply(){this.applied||(this.patches.forEach(([,t])=>{Object.defineProperty(this.owner,t.key,t.descriptor)}),this.applied=!0)}createToggle(t=!1){return new g(this,t)}revert(){this.applied&&(this.patches.forEach(([,t])=>{delete this.owner[t.key]}),this.conflicts.forEach(([,t])=>{Object.defineProperty(this.owner,t.key,t.descriptor)}),this.applied=!1)}release(){let t=r.patches.get(this.owner);t.splice(t.find(e=>e===this),1)}owner=null;options=null;static patches=new Map;static enableFor(t){if(r.patches.has(t))for(let e of r.patches.get(t))e.apply()}static disableFor(t){if(r.patches.has(t))for(let e of r.patches.get(t))e.revert()}static#t=class{constructor(t,e=globalThis){Object.assign(this,{key:t,descriptor:Object.getOwnPropertyDescriptor(e,t),owner:e})}get computed(){return this.isAccessor?this.descriptor.get.bind(this.owner).call():this.descriptor.value}get isData(){return Reflect.has(this.descriptor,"value")}get isAccessor(){return Reflect.has(this.descriptor,"get")}get isReadOnly(){return Reflect.has(this.descriptor,"configurable")&&!this.descriptor.configurable||Reflect.has(this.descriptor,"writable")&&!this.descriptor.writable}get[Symbol.toStringTag](){return this.constructor.name}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){return`PatchEntry<${this.key}, ${this.isData?"Data":"Accessor"}${this.isReadOnly?" [ReadOnly]":""}>`}}};var f=class r extends c{constructor(t,e,s=globalThis,n={}){let{key:i,extension:o,valid:a}=r.determineInput(t);if(o=e||o,!a)throw new m(s,i);let l=Object.getOwnPropertyDescriptor(s,i);if(l&&(Reflect.has(l,"writable")&&!l.writable||Reflect.has(l,"configurable")&&!l.configurable))throw new d(s,i);super(s,{[i]:o},n),this.key=i}static determineInput(t){let e={key:null,extension:null,valid:!1};return t instanceof Function?e={key:t.name,extension:t,valid:!0}:(typeof t=="string"||t instanceof String)&&(e={key:t,extension:null,valid:!0}),e}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){return`Extension<${this.key}>`}get[Symbol.toStringTag](){return this.constructor.name}};var y=new c(Function,{isClass(r){return r instanceof Function&&!!/^class\s/.exec(String(r))},isFunction(r){return r instanceof Function},isAsync(r){let t=/(\w+)]/g.exec(Object.prototype.toString.call(r))[1];return r instanceof Function&&t.includes("Async")},isBigArrow(r){return r instanceof Function&&String(r).includes("=>")&&!String(r).startsWith("bound")&&!Reflect.has(r,"prototype")},isBound(r){return r instanceof Function&&String(r).startsWith("bound")&&!Reflect.has(r,"prototype")}});var p=new c(Object,{hasStringTag(r){return Object.isObject(r)&&Reflect.has(r,Symbol.toStringTag)},getStringTag(r){return Object.hasStringTag(r)?r[Symbol.toStringTag]:r&&typeof r=="function"?r.name:/\s(.+)]/.exec(Object.prototype.toString.call(r))[1]},getType(r,t=globalThis){let e=Object.getStringTag(r);switch(e){case"Null":return null;case"Undefined":return;default:return t[e]}},isObject(r){return r&&(r instanceof Object||typeof r=="object")},isPrimitive(r){if(r===null)return!0;switch(typeof r){case"string":case"number":case"bigint":case"boolean":case"undefined":case"symbol":return!0;default:return!1}},isValidKey(r){return typeof r=="string"||typeof r=="symbol"},stripTo(r,t,e=!0){let s={};if(!Array.isArray(t))return s;for(let n of t)if(Reflect.has(r,n)){let i=Object.getOwnPropertyDescriptor(r,n);(Reflect.has(i,"get")||Reflect.has(i,"set"))&&e&&(i.get=i?.get?.bind(r),i.set=i?.set?.bind(r)),Object.defineProperty(s,i)}return s}});var b=new c(Reflect,{hasAll(r,...t){return Object.isObject(r)&&t.flat(1/0).map(e=>Reflect.has(r,e)).every(e=>e)},ownDescriptors(r){let t={},e=()=>e.doIt?p.revert():"";if(e.doIt=!1,Object.isObject||(e.doIt=!0,p.apply()),!Object.isObject(r))return e(),{};let s=Reflect.ownKeys(r);for(let n of s)t[n]=Object.getOwnPropertyDescriptor(n);return e(),t},hasSome(r,...t){return Object.isObject(r)&&t.flat(1/0).map(e=>Reflect.has(r,e)).some(e=>e)},entries(r){return!r||typeof r!="object"?[]:Reflect.ownKeys(r).map(t=>[t,Object.getOwnPropertyDescriptor(r,t)])},values(r){return Reflect.entries.map(([,t])=>t)}});var S=new c(String,{isString(r){return r&&(typeof r=="string"||r instanceof String)?r.length>0:!1}});var j=new c(Symbol,{isSymbol(r){return r&&typeof r=="symbol"},isRegistered(r,t=!1){if(!Symbol.isSymbol(r)){if(t)throw new TypeError("allowOnlySymbols specified; value is not a symbol");return!1}return Symbol.keyFor(r)!==void 0},isNonRegistered(r,t=!1){return!Symbol.isRegistered(r,t)}});var I=new c(Array.prototype,{contains(r){return!!this.find(t=>t===r)},findEntry(r){let t=this.entries(),e=1;for(let s of t)if(r(s[e]))return s},get first(){return this[0]},get last(){return this[this.length-1]}});var w=p.patchEntries?.isObject?.computed,N=p.patchEntries?.isValidKey?.computed,Q=S.patchEntries?.isString?.computed,E=b.patchEntries?.hasSome?.computed,v=class r{#t=r.enigmatic;constructor(t,e){if(this.#t=t,w(t)&&N(e)&&(this.#t=Object.getOwnPropertyDescriptor(t,e)),!this.isDescriptor)throw new Error("Not a valid descriptor:",this.#t)}get isAccessor(){return r.isAccessor(this.#t)}get isData(){return r.isData(this.#t)}get isDescriptor(){return r.isDescriptor(this.#t)}get configurable(){return!!this.#t?.configurable}set configurable(t){(this.#t||{}).configurable=!!t}get enumerable(){return this.#t?.enumerable}set enumerable(t){(this.#t||{}).enumerable=t}get writable(){return this.#t?.writable}set writable(t){(this.#t||{}).writable=t}get value(){return this.#t?.value}set value(t){(this.#t||{}).value=t}get get(){return this.#t?.get}set get(t){(this.#t||{}).get=t}get set(){return this.#t?.writable}set set(t){(this.#t||{}).set=t}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){return`Descriptor${this.isAccessor?" (Accessor)":this.isData?" (Data)":""} ${s(this.#t,{...e,depth:t})}`}static for(t,e){return!w(t)&&!N(e)?null:Object.getOwnPropertyDescriptor(t,e)}applyTo(t,e){if(!w(t)||!N(e))throw new Error("Cannot apply descriptor to non-object or invalid key");return Object.defineProperty(t,e,this.#t)}[Symbol.toPrimitive](t){switch(t){case"string":if(this.isAccessor){let e=Reflect.has(this.#t,"get")?"getter":"",s=Reflect.has(this.#t,"set")?"setter":"";return`Accessor (${e}${e&&s?", ":""}${s})`}else if(this.isData){let e=Reflect.has(this.#t,"value")?"value":"",s=Reflect.has(this.#t,"writable")?"writable":"";return`Data (${e}${e&&s?", ":""}${s})`}break;case"number":return NaN;default:return this.#t}}get[Symbol.toStringTag](){return this.constructor.name}static getData(t,e){if(!w(t)||!Q(e))return null;let s=r.all(t);if(s.has(e)){let n=s.get(e);if(r.isData(n))return n.value}}static getAccessor(t,e){if(!w(t))return null;let[s,n,i]=[0,1,2],o=[void 0,void 0,void 0],a=this.all(t),l=r.isDescriptor(t);if(a.has(e)||l){let u=l?t:a.get(e);if(r.isAccessor(u))return o[i]=a.object(e),o[s]=u?.get,o[n]=u?.set,Object.assign(o,{get(){this[s].bind(this[i])()},set(h){this[n].bind(this[i])(h)},get accessor(){return!0},get descriptor(){return u},get boundDescriptor(){return{...u,get:u.get?.bind(t),set:u.set?.bind(t)}}}),o}}static base(t=!1,e=!1){return{enumerable:t,configurable:e}}static accessor(t,e,{enumerable:s,configurable:n}=r.base()){return{get:t,set:e,enumerable:s,configurable:n}}static data(t,e=!0,{enumerable:s,configurable:n}=r.base()){return{value:t,enumerable:s,writable:e,configurable:n}}static isDescriptor(t){let e=[...r.SHARED_KEYS,...r.ACCESSOR_KEYS,...r.DATA_KEYS];return E(t,e)}static isData(t,e){let n=(typeof t=="object"||t instanceof Object)&&e instanceof String?r.for(t,e):t,{ACCESSOR_KEYS:i,DATA_KEYS:o}=this,a=!1;return E(n,i)?a=!1:E(n,o)&&(a=!0),a}static isAccessor(t,e){let n=t&&e&&(typeof t=="object"||t instanceof Object)&&(e instanceof String||typeof e=="symbol")?r.for(t,e):t,{ACCESSOR_KEYS:i,DATA_KEYS:o}=this,a=!1;return E(n,o)?a=!1:E(n,i)&&(a=!0),a}static get flexible(){return this.base(!0,!0)}static get enigmatic(){return this.base(!1,!0)}static get intrinsic(){return this.base(!1,!1)}static get transparent(){return this.base(!0,!1)}static get SHARED_KEYS(){return["configurable","enumerable"]}static get ACCESSOR_KEYS(){return["get","set"]}static get DATA_KEYS(){return["value","writable"]}},x=new f(v);var{isClass:X,isFunction:O}=y.patchEntries.isClass.computed,Z=Symbol.for("nodejs.util.inspect.custom"),A=new c(globalThis,{maskAs(r,t,e){let{prototype:s,toPrimitive:n}=GenericMask({...e,prototype:t}),i={configurable:!0,enumerable:!1},o=O(s)?s.prototype:s,a=X(s)?s:o?.constructor;return!a&&!o?null:(Object.setPrototypeOf(r,o),Object.defineProperties(r,{valueOf:{value(){return String(n("default",r))},...i},[Symbol.toPrimitive]:{value(l){return n(l,r)},...i},[Symbol.toStringTag]:{value:a.name,...i},[Symbol.species]:{get(){return a},...i},[Z]:{...i,value(l,u,h){return h(this[Symbol.toPrimitive](),{...u,depth:l})}}}),r)},maskAsString(r,t,e){return r&&Reflect.has(r,t)?maskAs(r,StringMask(t??"value",e)):null},maskAsNumber(r,t,e){return r&&Reflect.has(r,t)?maskAs(r,NumberMask(t??"value",e)):null},GenericMask({prototype:r,targetKey:t="value",toPrimitive:e}){let s={targetKey:t,toPrimitive:e,prototype:r};return O(e)||(s.toPrimitive=(n,i)=>{let o=i[t],a=typeof o=="number"&&Number.isFinite(o)||typeof o=="string"&&!isNaN(parseFloat(o))&&isFinite(o);switch(n){case"string":return a?String(o):o??String(i);case"number":return a?Number(o):NaN;case"default":default:return a?Number(o):o}}),s},StringMask(r,t){let e={targetKey:r,toPrimitive:t,prototype:String.prototype};return O(t)||(e.toPrimitive=function(n,i){switch(n){case"default":return i[r];case"number":return parseInt(i[r],36);case"string":return String(i[r]);default:return i}}),e},NumberMask(r,t){let e={targetKey:r,toPrimitive:t,prototype:Number.prototype};return O(t)||(e.toPrimitive=function(n,i){switch(n){case"default":return i[r];case"number":return Number(i[r]);case"string":return String(i[r]);default:return i}}),e}});var P=class r extends Set{#t=!1;objectifying(t=!0){return this.objectifyValues=t,this}get objectifyValues(){return this.#t}set objectifyValues(t){this.#t=!!t}add(t){if(this.#t&&(typeof t=="number"||typeof t=="string"||typeof t=="boolean"||typeof t=="bigint")&&(t=Object(t)),typeof t=="symbol"&&Symbol.keyFor(t)!==void 0)throw new TypeError("RefSet cannot accept registered symbols as values");if(typeof t!="object"&&typeof t!="symbol")throw new TypeError("RefSet values must be objects, non-registered symbols, or objectified primitives");if(t==null)throw new TypeError("RefSet values cannot be null or undefined");super.add(new WeakRef(t))}addAll(t){if(!t||typeof t!="object"||!Reflect.has(t,Symbol.iterator))throw new TypeError("The supplied values are either falsey or non-iterable");for(let e of t)this.add(e)}clean(){for(let t of this)t.deref()||this.delete(t);return this}entries(){return Array.from(super.entries()).map(([e,s])=>[s.deref(),s.deref()]).filter(([e,s])=>!!s)}forEach(t,e){let s=this;super.forEach(function(n){let i=n.deref();i&&t.call(e,i,i,s)})}values(){let t=[];for(let e of this){let s=e.deref();s&&t.push(s)}return t}keys(){return this.values()}has(t){if(this.#t)return this.contains(t);for(let e of this.values())if(e===t)return!0;return!1}contains(t){return!!Array.from(this.values()).filter(e=>t==e).length}filter(t,e){let s=[];for(let n of this){let i=n?.deref();i&&t.call(e,i,NaN,this)&&s.push(i)}return s}find(t,e){for(let s of this){let n=s?.deref();if(n&&t.call(e,n,NaN,this))return n}}map(t,e,s,n){let i=[],o=!0,a=!0;for(let l of this){let u=l?.deref();if(u){let h=t.call(e,u,NaN,this);(o||a)&&(this.#e(h)||(o=!1,a&&(a=this.#e(Object(h))))),i.push(h)}}if(s){if(o)return new r(i).objectifying(n?this.objectifyValues:!1);if(a)return new r(i.map(l=>this.#e(l)?l:Object(l))).objectifying()}return i}get[Symbol.toStringTag](){return this.constructor.name}#e(t){return!(typeof t=="symbol"&&Symbol.keyFor(t)===void 0||typeof t!="object"&&typeof t!="symbol"||t==null)}},$=new f(P);var R=class{#t=[];constructor(t,...e){t!=null&&typeof t[Symbol.iterator]=="function"?this.#t=[...t,...e]:this.#t=[t,...e]}async*[Symbol.asyncIterator](){for(let t of this.#t)yield Promise.resolve(t)}get[Symbol.toStringTag](){return this.constructor.name}static AsyncIterator=class{constructor(e){if(!e||!Reflect.has(e,Symbol.asyncIterator))throw new TypeError("Value used to instantiate AsyncIterator is not an async iterable");this.#e=e,this.#r=e[Symbol.asyncIterator]()}async asArray(){let e=[];for await(let s of this)e.push(s);return e}get asyncIterable(){return this.#e}async next(){let e=await this.#r.next();return e.done?{value:void 0,done:!0}:{value:e.value,done:!1}}async reset(){this.#r=this.#e[Symbol.asyncIterator]()}[Symbol.asyncIterator](){return this}get[Symbol.toStringTag](){return this.constructor.name}#e=null;#r=null};static isAsyncIterable(t){return Object.prototype.toString.call(t?.[Symbol.asyncIterator])==="[object AsyncGeneratorFunction]"}},k=new f(R),F=new f(R.AsyncIterator);var T=class{#t=[];constructor(t,...e){t!=null&&typeof t[Symbol.iterator]=="function"?this.#t=[...t,...e]:this.#t=[t,...e]}*[Symbol.iterator](){for(let t of this.#t)yield t}get asArray(){return this.#t}get[Symbol.toStringTag](){return this.constructor.name}static Iterator=class{constructor(e){if(!e||!Reflect.has(e,Symbol.iterator))throw new TypeError("Value used to instantiate Iterator is not iterable");this.#e=e,this.#r=e[Symbol.iterator]()}get asArray(){return Array.from(this.#e)}get iterable(){return this.#e}next(){let e=this.#r.next();return e.done?{value:void 0,done:!0}:{value:e.value,done:!1}}reset(){this.#r=this.#e[Symbol.iterator]()}[Symbol.iterator](){return this}get[Symbol.toStringTag](){return this.constructor.name}#e=null;#r=null};static isIterable(t){return Object.prototype.toString.call(t?.[Symbol.iterator])==="[object GeneratorFunction]"}},C=new f(T),V=new f(T.Iterator);var K=[Object,Function,Reflect,String,Symbol,Array.prototype],Y=[A,x,k,F,C,V,$];function _(r){let t=r||K;if(!t)throw new Error("Unable to enable features without owners list");t.forEach(e=>{c.enableFor(e)}),G()}function G(){Y.forEach(r=>{r.apply()})}function tt(r){let t=r||K;if(!t)throw new Error("Unable to disable features without owners list");t.forEach(e=>{c.disableFor(e)}),M()}function M(){Y.forEach(r=>{r.revert()})}var et=[p,y,b,S,j,I,A,x].reduce((e,s)=>(Reflect.ownKeys(s.patchEntries).reduce((n,i)=>(e[i]=s.patchEntries[i].computed,e),e),e),{});return L(rt);})();
//# sourceMappingURL=basic-extensions.bundle.1.6.0.js.map
