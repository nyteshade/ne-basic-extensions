{
  "version": 3,
  "sources": ["../../src/index.js", "../../node_modules/.pnpm/@nejs+extension@2.20.0/node_modules/@nejs/extension/src/errors/CannotBeExtendedError.js", "../../node_modules/.pnpm/@nejs+extension@2.20.0/node_modules/@nejs/extension/src/errors/MissingOwnerValue.js", "../../node_modules/.pnpm/@nejs+extension@2.20.0/node_modules/@nejs/extension/src/patchtoggle.js", "../../node_modules/.pnpm/@nejs+extension@2.20.0/node_modules/@nejs/extension/src/patchentry.js", "../../node_modules/.pnpm/@nejs+extension@2.20.0/node_modules/@nejs/extension/src/patch.js", "../../node_modules/.pnpm/@nejs+extension@2.20.0/node_modules/@nejs/extension/src/extension.js", "../../src/array.extensions.js", "../../src/big.int.extension.js", "../../src/function.extensions.js", "../../src/global.this.js", "../../src/json.extensions.js", "../../src/map.extensions.js", "../../src/number.extension.js", "../../src/classes/symkeys.js", "../../src/symbol.extensions.js", "../../src/classes/descriptor.js", "../../src/classes/property.js", "../../src/object.extensions.js", "../../src/reflect.extensions.js", "../../src/regular.expression.extensions.js", "../../src/set.extensions.js", "../../src/string.extensions.js", "../../src/classes/deferred.js", "../../src/classes/introspector.js", "../../src/classes/iterable.js", "../../src/classes/param.parser.js", "../../src/classes/pluggable.proxy.js", "../../src/weakref.extensions.js", "../../src/classes/refmap.js", "../../src/classes/refset.js", "../../src/classes/type.js", "../../src/classes/asyncIterable.js"],
  "sourcesContent": ["import { ArrayExtensions, ArrayPrototypeExtensions } from './array.extensions.js'\nimport { BigIntExtensions, BigIntPrototypeExtensions } from './big.int.extension.js'\nimport { FunctionExtensions, FunctionPrototypeExtensions } from './function.extensions.js'\nimport { GlobalFunctionsAndProps } from './global.this.js'\nimport { JSONExtensions } from './json.extensions.js'\nimport { MapExtensions, MapPrototypeExtensions } from './map.extensions.js'\nimport { NumberExtensions, NumberPrototypeExtensions } from './number.extension.js'\nimport { ObjectExtensions, ObjectPrototypeExtensions } from './object.extensions.js'\nimport { ReflectExtensions } from './reflect.extensions.js'\nimport { RegExpExtensions } from './regular.expression.extensions.js'\nimport { SetExtensions, SetPrototypeExtensions } from './set.extensions.js'\nimport { StringExtensions, StringPrototypeExtensions } from './string.extensions.js'\nimport { SymbolExtensions, SymbolPrototypeExtensions } from './symbol.extensions.js'\n\nimport { DeferredExtension } from './classes/deferred.js'\nimport { DescriptorExtensions, Descriptor } from './classes/descriptor.js'\nimport { IntrospectorExtensions } from './classes/introspector.js'\nimport { IteratorExtensions, IterableExtensions } from './classes/iterable.js'\nimport { ParamParserExtensions } from './classes/param.parser.js'\nimport { PropertyExtensions } from './classes/property.js'\nimport {\n  PluggableProxyExtensions,\n  ProxyHandlerExtensions,\n  PluggableProxyExtensionSet\n} from './classes/pluggable.proxy.js'\nimport { RefMapExtensions } from './classes/refmap.js'\nimport { RefSetExtensions } from './classes/refset.js'\nimport { SymkeysExtension } from './classes/symkeys.js'\nimport { TypeExtensions } from './classes/type.js'\n\nimport {\n  AsyncIteratorExtensions,\n  AsyncIterableExtensions\n} from './classes/asyncIterable.js'\n\nconst StaticPatches = [\n  [Array, ArrayExtensions, Array.name],\n  [BigInt, BigIntExtensions, BigInt.name],\n  [Function, FunctionExtensions, Function.name],\n  [JSON, JSONExtensions, 'JSON'],                // Missing a .name property\n  [Map, MapExtensions, Map.name],\n  [Number, NumberExtensions, Number.name],\n  [Object, ObjectExtensions, Object.name],\n  [Reflect, ReflectExtensions, 'Reflect'],       // Missing a .name property\n  [RegExp, RegExpExtensions, RegExp.name],\n  [Set, SetExtensions, Set.name],\n  [String, StringExtensions, String.name],\n  [Symbol, SymbolExtensions, 'Symbol'],          // Missing a .name property\n]\n\nconst InstancePatches = [\n  [Array.prototype, ArrayPrototypeExtensions, Array.name],\n  [BigInt.prototype, BigIntPrototypeExtensions, BigInt.name],\n  [Function.prototype, FunctionPrototypeExtensions, Function.name],\n  [Map.prototype, MapPrototypeExtensions, Map.name],\n  [Number.prototype, NumberPrototypeExtensions, Number.name],\n  [Object.prototype, ObjectPrototypeExtensions, Object.name],\n  [Set.prototype, SetPrototypeExtensions, Set.name],\n  [String.prototype, StringPrototypeExtensions, String.name],\n  [Symbol.prototype, SymbolPrototypeExtensions, Symbol.name],\n]\n\nconst Patches = new Map([\n  ...StaticPatches,\n  ...InstancePatches,\n])\n\nconst Extensions = {\n  [AsyncIterableExtensions.key]: AsyncIterableExtensions,\n  [AsyncIteratorExtensions.key]: AsyncIteratorExtensions,\n  [DeferredExtension.key]: DeferredExtension,\n  [DescriptorExtensions.key]: DescriptorExtensions,\n  [IntrospectorExtensions.key]: IntrospectorExtensions,\n  [IterableExtensions.key]: IterableExtensions,\n  [IteratorExtensions.key]: IteratorExtensions,\n  [ParamParserExtensions.key]: ParamParserExtensions,\n  [PluggableProxyExtensions.key]: PluggableProxyExtensions,\n  [ProxyHandlerExtensions.key]: ProxyHandlerExtensions,\n  [PropertyExtensions.key]: PropertyExtensions,\n  [RefMapExtensions.key]: RefMapExtensions,\n  [RefSetExtensions.key]: RefSetExtensions,\n  [SymkeysExtension.key]: SymkeysExtension,\n  [TypeExtensions.key]: TypeExtensions,\n}\n\nexport const Classes = {}\nfor (const extension of Object.values(Extensions)) {\n  const fnOrClass = extension.class || extension.function\n  Classes[fnOrClass.name] = fnOrClass\n}\n\n\nconst Controls = {}\n\nObject.assign(Controls, {\n  enableAll() {\n    Controls.enablePatches()\n    Controls.enableExtensions()\n  },\n\n  enablePatches() {\n    Patches.forEach((extension) => { extension.apply() })\n  },\n\n  enableStaticPatches(filter = ([owner, extension]) => true) {\n    const patches = StaticPatches.filter(toFilterFn(filter))\n    patches.forEach(([_, extension]) => extension.apply())\n    return patches\n  },\n\n  enableInstancePatches(filter = ([owner, extension]) => true) {\n    const patches = InstancePatches.filter(toFilterFn(filter))\n    patches.forEach(([_, extension]) => extension.apply())\n    return patches\n  },\n\n  enableExtensions() {\n    Object.values(Extensions).forEach((extension) => { extension.apply() })\n    GlobalFunctionsAndProps.apply()\n  },\n\n  disableAll() {\n    Controls.disablePatches()\n    Controls.disableExtensions()\n  },\n\n  disablePatches() {\n    Patches.forEach((extension) => { extension.revert() })\n  },\n\n  disableStaticPatches(filter = ([owner, extension]) => true) {\n    const patches = StaticPatches.filter(toFilterFn(filter))\n    patches.forEach(([_, extension]) => extension.revert())\n    return patches\n  },\n\n  disableInstancePatches(filter = ([owner, extension]) => true) {\n    const patches = InstancePatches.filter(toFilterFn(filter))\n    patches.forEach(([_, extension]) => extension.revert())\n    return patches\n  },\n\n  disableExtensions() {\n    Object.values(Extensions).forEach((extension) => { extension.revert() })\n    GlobalFunctionsAndProps.revert()\n  },\n})\n\nexport const all = (() => {\n  const dest = {\n    patches: {},\n    classes: {},\n    global: {},\n  };\n\n  const entriesReducer = (accumulator, [key, entry]) => {\n    const descriptor = new Descriptor(entry.descriptor, entry.owner)\n\n    descriptor.applyTo(accumulator, key, true)\n\n    return accumulator\n  }\n\n  const staticPatchReducer = (accumulator, [_, patch, ownerName]) => {\n    if (!accumulator?.[ownerName]) {\n      accumulator[ownerName] = {}\n    }\n\n    [...patch].reduce(entriesReducer, accumulator[ownerName])\n    return accumulator\n  };\n\n  const instancePatchReducer = (accumulator, [_, patch, ownerName]) => {\n    if (!accumulator?.[ownerName])\n      accumulator[ownerName] = {};\n\n    if (!accumulator[ownerName]?.prototype)\n      accumulator[ownerName].prototype = {};\n\n      [...patch].reduce(entriesReducer, accumulator[ownerName].prototype)\n    return accumulator\n  }\n\n  StaticPatches.reduce(staticPatchReducer, dest.patches);\n  InstancePatches.reduce(instancePatchReducer, dest.patches);\n  (Object.values(Extensions)\n    .flatMap(extension => [...extension])\n    .reduce(entriesReducer, dest.classes)\n  )\n\n  for (const [key, entry] of GlobalFunctionsAndProps) {\n    const descriptor = new Descriptor(entry.descriptor, entry.owner)\n    Object.defineProperty(dest.global, key, descriptor.toObject(true))\n  }\n\n  return dest\n})()\n\nconst results = {\n  ...Controls,\n  Extensions,\n  Patches,\n  GlobalFunctionsAndProps,\n  StaticPatches,\n  InstancePatches,\n  Controls,\n  extensions: Extensions,\n  patches: Patches,\n  all,\n}\n\nexport default results\n\nexport {\n  Extensions,\n  Patches,\n  StaticPatches,\n  InstancePatches,\n  Controls,\n  GlobalFunctionsAndProps,\n}\n\nfunction toFilterFn(filter = ([owner, extension]) => true) {\n  let filterFn = filter\n\n  if (typeof filterFn !== 'function') {\n    const elements = Array.isArray(filter) ? filter : [filter]\n    filterFn = ([owner, _]) => {\n      for (const element of elements) {\n        const elementStr = String(element)\n        if (elementStr.startsWith('^')) {\n          if ((owner?.name ?? owner) != elementStr.substring(1)) {\n            return true\n          }\n        }\n        if ((owner?.name ?? owner) == elementStr) {\n          return true\n        }\n      }\n      return false\n    }\n  }\n\n  return filterFn\n}", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when there is an attempt to extend a\n * restricted part of the code. This error is specifically used to signal\n * violations of extension constraints, such as tampering with certain keys\n * or properties of an object. The error message constructed will include the\n * details of the owner (the restricted part) and the key that was attempted to\n * be tampered with.\n */\nexport class CannotBeExtendedError extends Error {\n  /**\n   * Constructs a new CannotBeExtendedError instance.\n   *\n   * @param {string} owner The name or identifier of the restricted part\n   * that is disallowing extension or tampering.\n   * @param {string} key The key or property that was attempted to be\n   * modified or extended.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} disallows tampering with ${key}.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when a property is missing from a specified\n * owner object. This error is used to indicate that a specific key or property\n * expected to be present on the owner is not found, highlighting potential issues\n * in property access or data integrity.\n */\nexport class MissingOwnerValue extends Error {\n  /**\n   * Constructs a new MissingOwnerValue instance.\n   *\n   * @param {string} owner The object or entity that is supposed to contain the\n   * property.\n   * @param {string} key The name of the property that is missing from the owner.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} does not have a property named '${key}'.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   *\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "import { Patch } from \"./patch.js\";\n\n/**\n * Early usage of the Patch and Extension classes made it clear that it was\n * cumbersome to use a Patch temporarily for a block of code and excessive\n * amounts of if/else statements were required. This simple wrapper makes that\n * process easier.\n */\nexport class PatchToggle {\n  /**\n   * Wraps an instance of a Patch. It allows low-code clean-readability to\n   * start and stop the underlying patch regardless of whether or not the\n   * patch has been already applied.\n   *\n   * @param {Patch} patch instance of `Patch` to wrap with this toggle\n   * @param {boolean} preventRevert prevents the call to `.revert()` on the\n   * supplied patch when stop() is called.\n   */\n  constructor(patch, preventRevert = false) {\n    this.started = false\n    this.preventRevert = preventRevert\n    this.patch = patch\n    this.patchName = (\n      patch.owner?.name ??\n      patch.owner?.constructor?.name ??\n      /(\\w+)]/.exec(Object.prototype.toString.call(patch.owner))[1]\n    )\n    this.state = {\n      needsApplication: false,\n      needsReversion: false,\n    }\n  }\n\n  /**\n   * If the usage of the wrapped Patch hasn't been started yet, the code checks\n   * whether or not the patch has been applied by checking for signs of it in\n   * the owning object.\n   *\n   * If the patch needs to be applied, it will be applied at this time.\n   *\n   * @returns {PatchToggle} returns `this` to allow for chaining\n   */\n  start() {\n    if (!this.started) {\n      this.state.needsApplication = !this.patch.applied\n      this.state.needsReversion = this.patch.applied\n      this.started = true\n\n      if (this.state.needsApplication) {\n        this.patch.apply()\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Performs a task with the wrapped patch. If the patch hasn't been\n   * started, it will be started. If the patch doesn't need to be\n   * reverted, it will be stopped after the task is complete.\n   *\n   * @param {Function} task a function that takes the `PatchToggle`\n   * instance and the wrapped `Patch` instance as parameters. By\n   * default, this is an empty function.\n   * @returns {*} the result of the `task` function\n   *\n   * @example\n   * const result = toggle.perform((toggle, patch) => {\n   *   // do something with `toggle` and `patch`\n   *   return \"done\"\n   * })\n   * console.log(result) // outputs: \"done\"\n   */\n  perform(task = (toggle, patch) => {}) {\n    if (!this.state.needsApplication) {\n      this.start()\n    }\n\n    const result = task(this, this.patch)\n\n    if (!this.state.needsReversion) {\n      this.stop()\n    }\n\n    return result\n  }\n\n  /**\n   * Checks to see if the toggle has been started. If so, the patch is reverted\n   * if it needed to be applied previously. After stopping, the state of the instance\n   * is reverted to allow for clean subsequent calls to start.\n   *\n   * @returns {PatchToggle} returns `this` to allow further chaining\n   */\n  stop() {\n    if (this.started) {\n      if (this.preventRevert || this.patch.applied) {\n        this.patch.revert()\n      }\n\n      this.state.needsApplication = false\n      this.state.needsReversion = false\n      this.started = false\n    }\n\n    return this\n  }\n\n  /**\n   * When the string tag for this class instance is inspected, it will\n   * reflect the string `PatchToggle:PatchName`\n   */\n  get [Symbol.toStringTag]() {\n    return `${this.constructor.name}:${this.patchName}`\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the PatchToggle instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the PatchEntry instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const objName = this[Symbol.toStringTag]\n    const status = `(started: ${this.started} needed: ${this.state.needsApplication})`\n\n    return inspect(`${objName} ${status}`, {...options, depth})\n  }\n}", "/**\n * A PatchEntry class is a wrapper that maps the descriptor, key and owning\n * object in a single instance. When a Patch or Extension are created, one\n * of these for each patch is created so that the patch can be applied and\n * reverted.\n */\nexport class PatchEntry {\n\n  /**\n   * Constructs a new PatchEntry instance, encapsulating the logic for\n   * patching a property onto an object with optional conditions and\n   * descriptor overrides.\n   *\n   * This constructor validates the provided property and owningObject,\n   * constructs a property descriptor by merging the existing descriptor\n   * (if any) with any provided overrides, and initializes the PatchEntry\n   * instance with these details.\n   *\n   * @param {string|symbol} property The property key to patch. Must be a\n   * non-null string or symbol.\n   * @param {object} [owningObject=globalThis] The object to which the\n   * property will be patched. Defaults to the global object.\n   * @param {Function} [condition=undefined] An optional function that\n   * determines if the patch should be applied. If undefined, the patch\n   * is always applied.\n   * @param {object} [descriptorOverrides={}] Optional overrides for the\n   * property descriptor of the patch.\n   * @throws {TypeError} If `property` is not a string or symbol, or if\n   * `owningObject` is not an object.\n   */\n  constructor(\n    property,\n    owningObject = globalThis,\n    condition = undefined,\n    descriptorOverrides = {}\n  ) {\n    const isNullish = (value) => (value === null || value === undefined)\n    const isKey = (value, types = ['string', 'symbol']) =>\n      !isNullish(value) && (!!types.find(f => f === (typeof value)))\n    const isObject = value => isKey(value, ['object'])\n\n    if (!isKey(property)) {\n      console.error(\n        'Property', property, `(type: ${typeof property})`,\n        'owningObject', owningObject, `(type: ${typeof owningObject})`,\n        'condition', condition, `(type: ${typeof condition})`,\n      )\n      throw new TypeError(\n        'Property must be non-null and either a string or symbol'\n      )\n    }\n\n    if (!isObject(owningObject)) {\n      throw new TypeError(\n        'Cannot create Patch entry as owning object is invalid'\n      )\n    }\n\n    const descriptor = {\n      ...Object.getOwnPropertyDescriptor(owningObject, property),\n      ...Object(descriptorOverrides)\n    }\n\n    Object.assign(this, {\n      key: property,\n      descriptor,\n      owner: owningObject,\n      condition: (typeof condition === 'function') ? condition : undefined\n    })\n  }\n\n  /**\n   * Computes and returns the current value of the patch, based on its type\n   * (data or accessor).\n   *\n   * @returns {any} The current value of the patch.\n   */\n  get computed() {\n    if (this.isAccessor) {\n      return this.descriptor.get.bind(this.owner).call()\n    }\n    else {\n      return this.descriptor.value\n    }\n  }\n\n  /**\n   * Checks if the patch is a data property (has a value).\n   *\n   * @returns {boolean} True if the patch is a data property, false otherwise.\n   */\n  get isData() {\n    return Reflect.has(this.descriptor, 'value')\n  }\n\n  /**\n   * Checks if the patch is an accessor property (has a getter).\n   *\n   * @returns {boolean} True if the patch is an accessor property, false otherwise.\n   */\n  get isAccessor() {\n    return Reflect.has(this.descriptor, 'get')\n  }\n\n  /**\n   * Checks if the patch is read-only (not configurable or not writable).\n   *\n   * @returns {boolean} True if the patch is read-only, false otherwise.\n   */\n  get isReadOnly() {\n    return (\n      (Reflect.has(this.descriptor, 'configurable') && !this.descriptor.configurable) ||\n      (Reflect.has(this.descriptor, 'writable') && !this.descriptor.writable)\n    )\n  }\n\n  /**\n   * If a `condition` is associated with this specific patch entry, then it will\n   * run and its result will be returned. Otherwise `true` is returned allowing\n   * all non-conditional `PatchEntry` instances to be applied every time.\n   *\n   * @returns {boolean} `true` if the condition is true or there is no condition\n   * applied to this instance. `false` if the condition fails.\n   */\n  get isAllowed() {\n    const validAndPresent = (\n      this.condition &&\n      typeof this.condition === 'function'\n    )\n\n    return validAndPresent ? this.condition() : true\n  }\n\n  /**\n   * Applies the patch entry to a given object. This method takes the\n   * descriptor from the current patch entry and defines it on the target\n   * object. If `bindAccessors` is true and the descriptor contains accessor\n   * methods (getters/setters), they will be bound to the original owner of\n   * the patch before being applied to ensure the correct `this` context.\n   *\n   * @param {object} anotherObject - The object to which the patch will be\n   * applied.\n   * @param {boolean} [bindAccessors=false] - Whether to bind accessor methods\n   * to the patch's owner.\n   */\n  applyTo(anotherObject, bindAccessors = false) {\n    const descriptor = { ...this.descriptor }\n\n    if (bindAccessors) {\n      if (typeof descriptor.get === 'function') {\n        descriptor.get = descriptor.get.bind(this.owner);\n      }\n      if (typeof descriptor.set === 'function') {\n        descriptor.set = descriptor.set.bind(this.owner);\n      }\n    }\n\n    Object.defineProperty(anotherObject, this.key, descriptor);\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Provides the class name of\n   * the PatchEntry instance.\n   *\n   * @returns {string} The class name of the PatchEntry instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the PatchEntry instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the PatchEntry instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const name = `\\x1b[33m${this.key}\\x1b[39m`\n    const type = this.isData ? ' Data' : ' Accessor'\n    const writable = this.isReadOnly ? ' [\\x1b[2;3mReadOnly\\x1b[22;23m]' : ''\n\n    return `PatchEntry<${name}${type}${writable}>`\n  }\n}\n", "import { PatchToggle } from './patchtoggle.js'\nimport { PatchEntry } from './patchentry.js'\n\n/**\n * The Patch class provides a mechanism to apply patches to properties or\n * methods of an object (the owner). It keeps track of the original state of\n * these properties and allows for the application and reversion of patches.\n */\nexport class Patch {\n  /**\n   * A record of conflicts between existing and patched properties or methods.\n   * This object maps property names to their respective PatchEntry instances,\n   * which contain information about the original and patched values.\n   *\n   * @type {object}\n   */\n  patchConflicts = Object.create(null)\n\n  /**\n   * An object to store patch entries. Each key corresponds to a property or\n   * method name on the owner object, and the value is the associated\n   * PatchEntry instance which contains the patched and original values.\n   *\n   * @type {object}\n   */\n  patchEntries = Object.create(null)\n\n  /**\n   * The object containing the patches to be applied to the owner. It is\n   * initially undefined and will be populated with the patches passed to the\n   * constructor.\n   *\n   * @type {object}\n   */\n  patchesOwner = undefined\n\n  /**\n   * The count of patches that have been applied. This is incremented\n   * each time a patch is applied and decremented when a patch is\n   * reverted.\n   *\n   * @type {number}\n   */\n  patchCount = 0\n\n  /**\n   * The number of patches that have been successfully applied. This count\n   * is incremented after each successful patch application and decremented\n   * when a patch is reverted.\n   *\n   * @type {number}\n   */\n  patchesApplied = 0\n\n\n  /**\n   * The `displayName` property is used to store a human-readable name for the\n   * Patch instance. This name can be used for logging or debugging purposes to\n   * easily identify the patch in a more meaningful way than a generic identifier\n   * or memory reference. It is initially set to `undefined` and can be updated\n   * to any string value as needed.\n   *\n   * @type {string|undefined}\n   */\n  ownerDisplayName = undefined\n\n  /**\n   * Constructs a new Patch instance. Supported options for Patch instances\n   * include either a global condition for the Patch to be applied or\n   * specific property conditions subjecting only a subset of the patches\n   * to conditional application.\n   *\n   * @example\n   * ```\n   * const custom = Symbol.for('nodejs.util.inspect.custom')\n   * const patch = new Patch(\n   *   Object,\n   *   {\n   *     property: 'value',\n   *     [custom](depth, options, inspect) {\n   *       // ... custom return string for nodejs\n   *     }\n   *   },\n   *   {\n   *     conditions: {\n   *       [custom]() { return process?.versions?.node !== null },\n   *     },\n   *   }\n   * )\n   * patch.apply() // applies `property` but only applies the `custom`\n   *               // property if the JavaScript is running in NodeJS\n   * ```\n   *\n   * @param {object} owner The object to which patches will be applied.\n   * @param {object} patches An object containing properties or methods to\n   *                         be patched onto the owner.\n   * @param {object} [options=Object.create(null)] Additional options for\n   * patching behavior.\n   */\n  constructor(owner, patches, options = Object.create(null)) {\n    Object.assign(this, {\n      owner,\n      options,\n    })\n\n    this.ownerDisplayName = options?.displayName ?? Patch.extractName(owner)\n    this.patchesOwner = Patch.constructWithStore(patches, this)\n    this.generatePatchEntries(this.patchesOwner)\n\n    if (!Patch.patches.has(owner)) {\n      Patch.patches.set(owner, [])\n    }\n\n    Patch.patches.get(owner).push(this)\n  }\n\n  /**\n   * Iterates over the properties of `patchesOwner` and attempts to generate\n   * patches based on the provided conditions and overrides. This method\n   * supports conditional patching, allowing patches to be applied only if\n   * certain conditions are met. It also handles descriptor overrides for\n   * patch symbols, enabling custom behavior for patched properties.\n   *\n   * @param {object} patchesOwner The object containing the patches to be\n   * applied. Each key in this object represents a property to be patched.\n   * @param {object} [overrides] Optional. An object containing descriptor\n   * overrides for the properties to be patched. If not provided, overrides\n   * will be determined based on patch symbols.\n   */\n  generatePatchEntries(patchesOwner, overrides = undefined) {\n    const globalCondition = this?.options.condition\n\n    Reflect.ownKeys(patchesOwner).forEach(key => {\n      const condition = this?.options?.conditions?.[key] ?? globalCondition\n\n      try {\n        const useOverrides = (\n          overrides ??\n          Patch.getDescriptorOverridesFromSymbol(key)\n        );\n        let useOwner = patchesOwner;\n\n        if (Patch.isKnownPatchSymbol(key)) {\n          useOwner = Patch.constructWithStore(patchesOwner[key], this, key)\n          patchesOwner[key] = useOwner\n          this.generatePatchEntries(useOwner, useOverrides);\n          return;\n        }\n\n        this.patchEntries[key] = new PatchEntry(\n          key, patchesOwner, condition, overrides\n        )\n        this.patchCount += 1\n      }\n      catch (error) {\n        console.error(`Failed to process patch for ${String(key)}\\n`, error)\n      }\n\n      if (Reflect.has(this.owner, key)) {\n        try {\n          this.patchConflicts[key] = new PatchEntry(key, this.owner)\n        }\n        catch (error) {\n          console.error(`Cannot capture conflicting patch key ${key}\\n`, error)\n        }\n      }\n    })\n  }\n\n  /**\n   * Retrieves the patch entries as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get entries() {\n    return Reflect.ownKeys(this.patchEntries).map(key => {\n      return [key, this.patchEntries[key]]\n    })\n  }\n\n  /**\n   * Retrieves an array of patch entries that have been successfully applied.\n   * Each entry is a key-value pair array where the key is the patch identifier\n   * and the value is the corresponding `PatchEntry` object. Only patches with\n   * a state of `true` in `patchState` are included, indicating they are\n   * currently applied to the owner object.\n   *\n   * @returns {Array} An array of [key, patchEntry]\n   * pairs representing the applied patches.\n   */\n  get appliedEntries() {\n    return Reflect.\n      ownKeys(this.patchEntries).\n      filter(key => this.patchState.get(key) === true).\n      map(key => {\n        return [key, this.patchEntries[key]]\n      })\n  }\n\n  /**\n   * Retrieves an array of patch entries that have not been applied. Each entry\n   * is a key-value pair array where the key is the patch identifier and the\n   * value is the corresponding `PatchEntry` object. Only patches with a state\n   * of `false` in `patchState` are included, indicating they are not currently\n   * applied to the owner object.\n   *\n   * @returns {Array} An array of [key, patchEntry]\n   * pairs representing the unapplied patches.\n   */\n  get unappliedEntries() {\n    return Reflect.\n      ownKeys(this.patchEntries).\n      filter(key => this.patchState.get(key) === false).\n      map(key => {\n        return [key, this.patchEntries[key]]\n      })\n  }\n\n  /**\n   * Depending on how the PatchEntry is configured, accessing the patch\n   * by name can be somewhat irritating, so this provides an object with\n   * the actual current patch value at the time patchValues is requested.\n   *\n   * @example let { patch1, patch2 } = patch.patchValues\n   * @returns {object} an object with the patchName mapped to the current\n   * computed patchEntry value.\n   */\n  get patches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      acc[key] = patchEntry.computed\n      return acc\n    }, Object.create(null))\n  }\n\n  /**\n   * Retrieves an object containing all patches that have been successfully\n   * applied. The object's keys are the patch keys, and the values are the\n   * computed values of the corresponding patch entries. Only patches with\n   * a state of `true` in `patchState` are considered applied.\n   *\n   * @returns {object} An object mapping each applied patch key to its\n   * computed value.\n   */\n  get appliedPatches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      if (this.patchState.get(key) === true) {\n        acc[key] = patchEntry.computed\n      }\n      return acc\n    }, Object.create(null))\n  }\n\n  /**\n   * Retrieves an object containing all patches that have not been applied.\n   * The object's keys are the patch keys, and the values are the computed\n   * values of the corresponding patch entries. Only patches with a state\n   * of `false` in `patchState` are considered unapplied.\n   *\n   * @example\n   * // Assuming `patch` is an instance of `Patch` and `patch1` is unapplied:\n   * let unapplied = patch.unappliedPatches;\n   * console.log(unapplied); // { patch1: computedValueOfPatch1 }\n   *\n   * @returns {object} An object mapping each unapplied patch key to its\n   * computed value.\n   */\n  get unappliedPatches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      if (this.patchState.get(key) === false) {\n        acc[key] = patchEntry.computed\n      }\n      return acc\n    }, Object.create(null))\n  }\n\n  /**\n   * Retrieves an array of patch keys.\n   *\n   * This getter returns an array containing only the keys of the patch entries,\n   * which can be useful for iterating over the patches or checking for the\n   * existence of specific patches by key.\n   *\n   * @returns {string[]} An array of patch keys.\n   */\n  get patchKeys() {\n    return this.entries.map(([key, _]) => key)\n  }\n\n  /**\n   * Generates a list of entries with enhanced string representations. This\n   * getter iterates over the `entries` property, transforming each [key, value]\n   * pair into a more informative string object. This is particularly useful\n   * for debugging or logging, as it provides a clear, readable format for\n   * each entry. The string representation includes the entry's key and value,\n   * with the key being converted to a string using its `Symbol.toStringTag`,\n   * `name` property, or a direct string conversion as fallback.\n   *\n   * Each value in the resultant array additionally has '.key', `.value`,\n   * `.entry` and `.entries` accessors. The `.key` is the `owner` object, the\n   * `.value` is the `PatchEntry` instance. The entry accessor provides the\n   * key and value in an array as one might expect to find the\n   * `Object.entries()` array and `.entries` is the same as `[stringRef.entry]`\n   * or `[[key, value]]`.\n   *\n   * @returns {Array} An array of string objects, each representing an entry\n   * from the `entries` property. Each string object is enhanced with additional\n   * properties and methods for improved usability and debugging.\n   */\n  get prettyEntries() {\n    const prettyEntries = this.entries.map(([key, value]) => Patch.stringRef(\n      Patch.extractName(key),\n      key,\n      value\n    ))\n\n    Object.defineProperty(prettyEntries, 'asEntries', {\n      get() { return this.map(pe => pe.entry) },\n      enumerable: false,\n      configurable: true,\n    })\n\n    return prettyEntries\n  }\n\n  /**\n   * Retrieves the conflict entries (existing properties on the owner that\n   * will be overridden by patches) as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get conflicts() {\n    return Reflect.ownKeys(this.patchConflicts).map(key => {\n      return [key, this.patchConflicts[key]]\n    })\n  }\n\n  /**\n   * Checks to see if the tracked number of applied patches is greater than 0\n   *\n   * @returns {boolean} true if at least one patch has been applied\n   */\n  get applied() {\n    return this.patchesApplied > 0\n  }\n\n  /**\n   * Provided for semantics, but this method is synonymous with {@link applied}.\n   *\n   * @returns {boolean} true if at least one patch has been applied\n   */\n  get isPartiallyPatched() {\n    return this.applied\n  }\n\n  /**\n   * Returns true only when the number of tracked patches matches the number\n   * of applied patches.\n   *\n   * @returns {boolean} true if applied patches is equal to the count of patches\n   */\n  get isFullyPatched() {\n    return this.patchCount == this.patchesApplied\n  }\n\n  /**\n   * Applies all patches to the owner object. If a property with the same key\n   * already exists on the owner, it will be overridden. Optionally a callback\n   * can be supplied to the call to revert. If the callback is a valid function,\n   * it will be invoked with an object containing the results of the reversion\n   * of the patch. The callback receives a single parameter which is an object\n   * of counts. It has the signature:\n   *\n   * ```\n   * type counts = {\n   *   patches: number;\n   *   applied: number;\n   *   errors: Array<PatchEntry,Error>;\n   *   notApplied: number;\n   * }\n   * ```\n   *\n   * While the keys may be obvious to some, `patches` is the count of patches\n   * this instance tracks. `applied` is the number of patches that were applied\n   * 'errors' is an array of arrays where the first element is the `PatchEntry`\n   * and the second element is an `Error` indicating the problem. An error will\n   * only be generated if `isAllowed` is `true` and the patch still failed to\n   * apply Lastly `notApplied` is the number of patches that were unable to\n   * be applied.\n   *\n   * Additional logic that should track\n   * ```\n   *   \u2022 patches should === applied when done\n   *   \u2022 errors.length should be 0 when done\n   *   \u2022 notApplied should be 0 when done\n   * ```\n   *\n   * @param {function} metrics - a callback which receives a status of the\n   * `revert` action if supplied. This callback will not be invoked, nor will\n   * any of the other logic be captured, if {@link applied} returns false\n   */\n  apply(metrics) {\n    const entries = this.entries\n    const counts = {\n      patches: entries.length,\n      applied: 0,\n      errors: [],\n      notApplied: entries.length,\n    }\n\n    this.patchState.clear()\n\n    entries.forEach(([,patch]) => {\n      if (patch.isAllowed) {\n        // Patch\n        Object.defineProperty(this.owner, patch.key, patch.descriptor)\n\n        // Verify\n        let oDesc = Object.getOwnPropertyDescriptor(this.owner, patch.key)\n        if (this.#equalDescriptors(oDesc, patch.descriptor)) {\n          counts.applied += 1\n          counts.notApplied -= 1\n\n          this.patchState.set(patch, true)\n\n        }\n        else {\n          counts.errors.push([patch, new Error(\n            `Could not apply patch for key ${patch.key}`\n          )])\n          this.patchState.set(patch, false)\n        }\n      }\n      else {\n        this.patchState.set(patch, false)\n      }\n    })\n\n    this.patchesApplied = counts.applied\n\n    if (typeof metrics === 'function') {\n      metrics(counts)\n    }\n  }\n\n  /**\n   * Creates an easy to use toggle for working with `Patch` classes\n   *\n   * @param {boolean} preventRevert true if calling stop() on the toggle does not\n   * revert the patch. false, the default, if it should.\n   * @returns {PatchToggle} an instance of PatchToggle wrapped around this instance\n   * of `Patch`\n   * @example const toggle = ObjectExtensions.createToggle().start()\n   */\n  createToggle(preventRevert = false) {\n    return new PatchToggle(this, preventRevert)\n  }\n\n  /**\n   * Reverts all applied patches on the owner object, restoring any overridden\n   * properties to their original state. Optionally a callback can be supplied to\n   * the call to revert. If the callback is a valid function, it will be invoked\n   * with an object containing the results of the reversion of the patch. The\n   * callback receives a single parameter which is an object of counts. It has\n   * the signature:\n   *\n   * ```\n   * type counts = {\n   *   patches: number;\n   *   reverted: number;\n   *   restored: number;\n   *   conflicts: number;\n   *   errors: Array<PatchEntry,Error>;\n   *   stillApplied: number;\n   * }\n   * ```\n   *\n   * While the keys may be obvious to some, `patches` is the count of patches\n   * this instance tracks. `reverted` is the number of patches that were removed'\n   * `restored` is the number of originally conflicting keys that were restored.\n   * `conflicts` is the total number of conflicts expected. `errors` is an array of\n   * arrays where the first element is the `PatchEntry` and the second element\n   * is an `Error` indicating the problem. Lastly `stillApplied` is the number of\n   * patchesApplied still tracked. If this is greater than zero, you can assume\n   * something went wrong.\n   *\n   * Additional logic that should track\n   * ```\n   *   \u2022 patches should === reverted when done\n   *   \u2022 restored should === conflicts when done\n   *   \u2022 errors.length should be 0 when done\n   *   \u2022 stillApplied should be 0 when done\n   * ```\n   *\n   * @param {function} metrics - a callback which receives a status of the\n   * `revert` action if supplied. This callback will not be invoked, nor will\n   * any of the other logic be captured, if {@link applied} returns false\n   */\n  revert(metrics) {\n    if (!this.applied) {\n      return\n    }\n\n    const entries = this.entries\n    const conflicts = this.conflicts\n\n    const counts = {\n      patches: entries.length,\n      reverted: 0,\n      restored: 0,\n      conflicts: conflicts.length,\n      errors: [],\n      stillApplied: 0,\n    }\n\n    entries.forEach(([,patch]) => {\n      const successful = delete this.owner[patch.key]\n      if (successful) {\n        this.patchesApplied -= 1\n        counts.reverted += 1\n        this.patchState.set(patch, false)\n      }\n      else {\n        counts.errors.push([patch, new Error(\n          `Failed to revert patch ${patch.key}`\n        )])\n      }\n    })\n\n    conflicts.forEach(([,patch]) => {\n      Object.defineProperty(this.owner, patch.key, patch.descriptor)\n      const appliedDescriptor = Object.getOwnPropertyDescriptor(this.owner, patch.key)\n      if (this.#equalDescriptors(patch.descriptor, appliedDescriptor)) {\n        counts.restored += 1\n      }\n      else {\n        counts.errors.push([patch, new Error(\n          `Failed to restore original ${patch.key}`\n        )])\n      }\n    })\n\n    counts.stillApplied = this.patchesApplied\n    if (typeof metrics === 'function') {\n      metrics(counts)\n    }\n  }\n\n  /**\n   * Removes this Patch instance from being tracked amongst all the tracked Patch\n   * instances. The JavaScript virtual machine will clean this instance up once\n   * nothing else is holding a reference to it.\n   */\n  release() {\n    const patches = Patch.patches.get(this.owner)\n    patches.splice(patches.find(e => e === this), 1)\n  }\n\n  /**\n   * The object to which the patches are applied.\n   */\n  owner = null;\n\n  /**\n   * Additional options for patching behavior.\n   */\n  options = null;\n\n  /**\n   * Patches that are currently live and active will have true as their\n   * value and inert or non-applied patches will have false as their\n   * value. The key is always the associated {@link PatchEntry}.\n   */\n  patchState = new Map();\n\n  /**\n   * Creates an iterator for the patch entries, allowing the `Patch` instance to\n   * be directly iterable using a `for...of` loop. Each iteration will yield a\n   * `[key, patchEntry]` pair, where `key` is the property name and `patchEntry`\n   * is the corresponding `PatchEntry` instance.\n   *\n   * @returns {Iterator} An iterator that yields `[key, patchEntry]` pairs.\n   */\n  [Symbol.iterator]() {\n    return this.entries.values()\n  }\n\n  /**\n   * Compares two property descriptor objects to determine if they are equivalent.\n   *\n   * This method checks if both descriptors have the same value for the\n   * `configurable`, `enumerable`, `value`, `writable`, `get`, and `set`\n   * properties. If any of these properties differ between the two descriptors,\n   * the descriptors are considered not equivalent.\n   *\n   * @param {PropertyDescriptor} left - The first descriptor to compare.\n   * @param {PropertyDescriptor} right - The second descriptor to compare.\n   * @returns {boolean} - True if the descriptors are equivalent, false otherwise.\n   * @private\n   */\n  #equalDescriptors(left, right) {\n    if (!left || !right) {\n      return false;\n    }\n\n    return (\n      left.configurable === right.configurable &&\n      left.enumerable === right.enumerable &&\n      left.value === right.value &&\n      left.writable === right.writable &&\n      left.get === right.get &&\n      left.set === right.set\n    )\n  }\n\n  /**\n   * Custom inspection function for Node.js that is called when `util.inspect`\n   * is used to convert the instance to a string. This allows for customizing\n   * the output of `util.inspect` for objects of this class.\n   *\n   * @param {number} depth The current depth of the inspection. If the depth\n   * is less than the recurse times set, it will return the object itself,\n   * otherwise it will return the inspected result.\n   * @param {object} options An object containing options for the inspection.\n   * @param {function} inspect The inspection function provided by Node.js\n   * that can be called to inspect other properties with the same options as\n   * the original call.\n   * @returns {string} A string representation of the instance tailored for\n   * Node.js' `util.inspect`.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const type = this.ownerDisplayName ?? ''\n    const name = (type.length\n      ? `[\\x1b[32m${type}\\x1b[39m]`\n      : ''\n    )\n    const keys = (this.prettyEntries\n      .map(entry => {\n        return `\\x1b[2;33m${entry}\\x1b[22;39m`\n      })\n      .join(', ')\n    )\n\n    return `${this.constructor.name}${name} { ${keys} }`;\n  }\n\n  /**\n   * A global mapping of all patches in play\n   */\n  static patches = new Map()\n\n  /**\n   * Applies all patches associated with a given owner object. This method\n   * is used to enable all patches for a specific owner if they have been\n   * previously registered.\n   *\n   * @param {object} owner The object whose patches are to be applied.\n   */\n  static enableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.apply()\n      }\n    }\n  }\n\n  /**\n   * Enables patches for all static members registered in the system. This\n   * method iterates over all registered owners, identifying those represented\n   * by functions (typically static members or classes) and enables patches\n   * specifically for them. It's particularly useful for activating patches\n   * that are meant to modify or enhance static properties or methods of\n   * classes.\n   */\n  static enableProbableStatics() {\n    for (const owner of Patch.patches.keys()) {\n      if (typeof owner !== 'function') {\n        continue;\n      }\n\n      Patch.enableFor(owner);\n    }\n  }\n\n  /**\n   * Iterates over all registered owners and enables patches for those\n   * identified as instance entities (non-functions). This method is\n   * particularly useful for activating patches on instance-level properties\n   * or methods of classes, without affecting static-level patches. It ensures\n   * that only owners not represented by functions, typically instance members,\n   * are targeted for patch enabling.\n   */\n  static enableProbableInstances() {\n    for (const owner of Patch.patches.keys()) {\n      if (typeof owner === 'function') {\n        continue;\n      }\n\n      Patch.enableFor(owner);\n    }\n  }\n\n  /**\n   * Enables all patches for every owner currently registered in the system.\n   * This static method iterates over all owners that have patches registered\n   * and applies those patches by invoking `enableFor` on each owner. This\n   * method is particularly useful when a global application of all patches\n   * is required, without the need to manually enable them for each owner\n   * individually.\n   */\n  static enableAll() {\n    for (const owner of Patch.patches.keys()) {\n      Patch.enableFor(owner);\n    }\n  }\n\n  /**\n   * Reverts all patches associated with a given owner object. This method\n   * is used to disable all patches for a specific owner if they have been\n   * previously applied.\n   *\n   * @param {object} owner The object whose patches are to be reverted.\n   */\n  static disableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.revert()\n      }\n    }\n  }\n\n  /**\n   * Disables all patches for every owner currently registered in the system.\n   * This method iterates over all owners that have patches registered and\n   * reverts those patches by invoking `disableFor` on each owner. It is\n   * particularly useful when a global reversion of all patches is required,\n   * without the need to manually disable them for each owner individually.\n   */\n  static disableAll() {\n    for (const owner of Patch.patches.keys()) {\n      Patch.disableFor(owner);\n    }\n  }\n\n  /**\n   * Iterates over all registered owners and disables patches for those\n   * identified as static entities (functions). This method is particularly\n   * useful for reverting patches to static methods or properties of classes,\n   * without affecting instance-level patches. It ensures that only owners\n   * represented by functions, typically static members, are targeted for\n   * patch disabling.\n   */\n  static disableProbableStatics() {\n    for (const owner of Patch.patches.keys()) {\n      if (typeof owner !== 'function') {\n        continue;\n      }\n\n      Patch.disableFor(owner);\n    }\n  }\n\n  /**\n   * Iterates over all registered owners and disables patches for those\n   * not identified as static entities (functions). This method is\n   * particularly useful for reverting patches applied to instance-level\n   * properties or methods, ensuring that patches on static members remain\n   * unaffected. It targets only owners not represented by functions,\n   * typically instance members, for patch disabling.\n   */\n  static disableProbableInstances() {\n    for (const owner of Patch.patches.keys()) {\n      if (typeof owner === 'function') {\n        continue;\n      }\n\n      Patch.disableFor(owner);\n    }\n  }\n\n\n  /**\n   * A static getter that provides a proxy to manage and interact with the\n   * patches that have been applied globally. This proxy abstracts the\n   * underlying details and presents a simplified interface for querying and\n   * manipulating applied patches. It is particularly useful in IDEs, as it\n   * allows developers to access the state of applied patches without needing\n   * to delve into the source code.\n   *\n   * @returns {Object} An object showing all the keys known to be patched for\n   * the default owner, `globalThis`\n   */\n  static get applied() {\n    return this.#allPatchesForOwner(globalThis, true)\n  }\n\n  /**\n   * A static getter that provides access to a proxy representing all known\n   * patches, whether applied or not. This is useful for inspecting the\n   * complete set of patches that have been registered in the system, without\n   * limiting the view to only those that are currently active. The proxy\n   * abstracts the underlying details and presents a simplified interface for\n   * querying and manipulating the patches.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of all\n   * registered patches, allowing for operations like checking if a patch is\n   * known and retrieving patch values.\n   */\n  static get known() {\n    return this.#allPatchesForOwner(globalThis, false)\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with a toggle functionality. This proxy allows the temporary\n   * application of patches within a certain scope, and automatically reverts\n   * them after the scope ends. It is useful for applying patches in a\n   * controlled manner, ensuring that they do not remain active beyond the\n   * intended usage.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with toggle functionality, allowing for temporary application\n   * and automatic reversion of patches.\n   */\n  static get use() {\n    return this.#allPatchesForOwner(globalThis, false, true)\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with lazy initialization. This proxy defers the creation and\n   * application of patches until they are explicitly requested. It is\n   * beneficial for performance optimization, as it avoids the overhead of\n   * initializing patches that may not be used.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with lazy initialization, allowing patches to be created and\n   * applied only when needed.\n   */\n  static get lazy() {\n    return this.#allPatchesForOwner(globalThis, false, false, true)\n  }\n\n  /**\n   * Returns an object with getters to access different proxy views of patches\n   * scoped to a specific owner. This allows for interaction with patches\n   * that are either applied, known, or used within a certain scope, providing\n   * a controlled environment for patch management.\n   *\n   * @param {object} owner - The object to scope the patch proxies to.\n   * @returns {object} An object containing getters for `applied`, `known`,\n   * and `use` proxies:\n   * - `applied`: Proxy for patches applied to the owner.\n   * - `known`: Proxy for all patches known to the owner, applied or not.\n   * - `use`: Proxy that allows temporary application of patches.\n   */\n  static scopedTo(owner) {\n    const allForOwner = (\n      owner,\n      appliedOnly,\n      wrapInToggle = false,\n      applyOnRequest = false\n    ) => {\n      return this.#allPatchesForOwner(\n        owner,\n        appliedOnly,\n        wrapInToggle,\n        applyOnRequest\n      )\n    }\n\n    return {\n      /**\n       * Getter for a proxy that represents patches applied to the owner.\n       * This proxy provides a simplified interface for interacting with\n       * applied patches, such as checking their status or retrieving values.\n       *\n       * @returns {Proxy} A proxy to the applied patches.\n       */\n      get applied() {\n        return allForOwner(owner, true, false)\n      },\n\n      /**\n       * Getter for a proxy that represents all patches known to the owner,\n       * whether they are applied or not. This proxy allows for querying\n       * and manipulation of the patches without directly accessing them.\n       *\n       * @returns {Proxy} A proxy to all known patches.\n       */\n      get known() {\n        return allForOwner(owner, false, false)\n      },\n\n      /**\n       * Getter for a proxy that enables temporary application of patches\n       * within a certain scope. The patches are automatically reverted\n       * after the scope ends, ensuring controlled usage.\n       *\n       * @returns {Proxy} A proxy to patches with toggle functionality.\n       */\n      get use() {\n        return allForOwner(owner, false, true)\n      },\n\n      /**\n       * Getter for a proxy that represents patches that are not immediately\n       * applied but are applied on request. This allows for patches to be\n       * applied only when they are explicitly needed, potentially improving\n       * performance by deferring the application of patches until necessary.\n       *\n       * @returns {Proxy} A proxy to patches that are applied on request.\n       */\n      get lazy() {\n        return allForOwner(owner, false, false, true)\n      },\n    }\n  }\n\n  /**\n   * Aggregates patches for a given owner into a single object, optionally\n   * filtering by applied status and wrapping in a toggle function.\n   *\n   * This method collects all patches associated with the specified owner\n   * and constructs an object where each patch is represented by its key.\n   * If `onlyApplied` is true, only patches that are currently applied will\n   * be included. If `wrapInToggle` is true, each patch will be represented\n   * as a function that temporarily applies the patch when called.\n   *\n   * @param {object} owner - The owner object whose patches are to be\n   * aggregated.\n   * @param {boolean} onlyApplied - If true, only include patches that\n   * are applied.\n   * @param {boolean} [wrapInToggle=false] - If true, wrap patches in a\n   * toggle function for temporary application.\n   * @returns {object} An object representing the aggregated patches, with\n   * each patch keyed by its property name.\n   * @private\n   */\n  static #allPatchesForOwner(\n    owner,\n    onlyApplied,\n    wrapInToggle = false,\n    applyOnRequest = false\n  ) {\n    return [...Patch.patches.values()].\n      flat().\n      filter(patch => patch.owner === owner).\n      reduce((accumulator, patch) => {\n        for (const [,patchEntry] of patch.entries) {\n          if (onlyApplied && patch.patchState.get(patchEntry) !== true) {\n            continue\n          }\n\n          if (wrapInToggle) {\n            accumulator[patchEntry.key] = async (usage) => {\n              if (typeof usage !== 'function') {\n                return\n              }\n\n              const type = Object.prototype.toString.call(usage)\n              const toggle = patch.createToggle()\n\n              toggle.start()\n              if('[object AsyncFunction]' === type) {\n                await usage(patchEntry.computed, patchEntry)\n              }\n              else {\n                usage(patchEntry.computed, patchEntry)\n              }\n              toggle.stop()\n            }\n\n            continue\n          }\n\n          if (applyOnRequest) {\n            Object.defineProperty(accumulator, patchEntry.key, {\n              get() {\n                patch.apply()\n                return patchEntry.computed\n              },\n              enumerable: true,\n              configurable: true,\n            });\n\n            continue;\n          }\n\n\n          if (patchEntry.isAccessor) {\n            let dynName = `applyAccessorFor_${String(patchEntry.key)}`\n            let dynNameContainer = {\n              [dynName](applyTo) {\n                patchEntry.applyTo(applyTo)\n                return applyTo\n              }\n            };\n\n            accumulator[patchEntry.key] = dynNameContainer[dynName]\n          }\n          else {\n            patchEntry.applyTo(accumulator)\n          }\n        }\n\n        return accumulator\n      }, Object.create(null))\n  }\n\n  /**\n   * A getter for the custom inspect symbol used by Node.js.\n   *\n   * @returns {symbol} The custom inspect symbol.\n   */\n  static get CustomInspect() {\n    return Symbol.for('nodejs.util.inspect.custom')\n  }\n\n  /**\n   * Strips leading and trailing control characters, brackets, braces, and\n   * quotes from a string. This is typically used to clean strings that may\n   * have special characters or escape sequences that are not desired in the\n   * output.\n   *\n   * @param {string} fromString The string to be stripped of extras.\n   * @returns {string} The cleaned string with extras stripped.\n   */\n  static stripExtras(fromString) {\n    return fromString\n      .replaceAll(\n        /^(\\x1B\\[\\d+m)?[\\[\\{]\\s?|\\s?[\\]\\}](\\x1B\\[\\d+m)?$/gm,\n        '$1$2'\n      )\n      .replaceAll(\n        /['\"](.*?)['\"]/gm,\n        '$1'\n      )\n  }\n\n  /**\n   * Accessor for a Symbol uniquely representing properties that are\n   * non-enumerable but configurable. This symbol can be used to tag\n   * properties with these characteristics in a consistent manner across\n   * different parts of the application.\n   *\n   * @returns {symbol} A Symbol for properties that are non-enumerable\n   * but configurable.\n   */\n  static get kMutablyHidden() {\n    return Symbol.for('{\"enumerable\":false,\"configurable\":true}')\n  }\n\n  /**\n   * Applies a custom descriptor patch to an instance, marking properties as\n   * non-enumerable but configurable. This method utilizes the `kMutablyHidden`\n   * symbol to tag properties accordingly. It's useful for hiding properties\n   * in a way that they remain configurable for future changes.\n   *\n   * @param {object} instance The object instance to apply the patch to.\n   * @param {object} [store=Object.create(null)] An optional store object to\n   * hold patched properties' original values and descriptors.\n   * @returns {object} The result of applying the custom descriptor patch,\n   * typically a modified version of the `store` object containing the patched\n   * properties' descriptors.\n   */\n  static mutablyHidden(instance, store = Object.create(null)) {\n    return this.customDescriptorPatch(instance, this.kMutablyHidden, store);\n  }\n\n  /**\n   * Accessor for a Symbol uniquely representing properties that are both\n   * enumerable and configurable. This symbol can be used to tag properties\n   * with these characteristics in a consistent manner across different parts\n   * of the application. The symbol is created or retrieved based on a\n   * standardized JSON string, ensuring consistency in its representation.\n   *\n   * @returns {symbol} A Symbol for properties that are both enumerable and\n   * configurable, allowing them to be listed in object property enumerations\n   * and reconfigured or deleted.\n   */\n  static get kMutablyVisible() {\n    return Symbol.for('{\"enumerable\":true,\"configurable\":true}')\n  }\n\n  /**\n   * Applies a custom descriptor patch to an instance, marking properties as\n   * both enumerable and configurable. This method leverages the `kMutablyVisible`\n   * symbol to tag properties, making them visible in enumerations and allowing\n   * them to be reconfigured or deleted. This is particularly useful for\n   * properties that need to be exposed for iteration or manipulation while\n   * maintaining the ability to modify their descriptors in the future.\n   *\n   * @param {object} instance The object instance to apply the patch to.\n   * @param {object} [store=Object.create(null)] An optional store object to\n   * hold patched properties' original values and descriptors. If not provided,\n   * a new object will be used to store this information.\n   * @returns {object} The result of applying the custom descriptor patch,\n   * typically a modified version of the `store` object containing the patched\n   * properties' descriptors.\n   */\n  static mutablyVisible(instance, store = Object.create(null)) {\n    return this.customDescriptorPatch(instance, this.kMutablyVisible, store)\n  }\n\n  /**\n   * Accessor for a Symbol uniquely identifying properties that are neither\n   * enumerable nor configurable. This symbol is used to tag properties to\n   * ensure they are hidden from enumeration and cannot be reconfigured or\n   * deleted, providing a level of immutability. The symbol is generated or\n   * retrieved based on a standardized JSON string, ensuring consistency\n   * across different parts of the application.\n   *\n   * @returns {symbol} A Symbol for properties that are neither enumerable\n   * nor configurable, effectively making them immutable and hidden from\n   * property enumerations.\n   */\n  static get kImmutablyHidden() {\n    return Symbol.for('{\"enumerable\":false,\"configurable\":false}')\n  }\n\n  /**\n   * Applies a descriptor patch to an object instance, marking properties as\n   * neither enumerable nor configurable. This method uses the `kImmutablyHidden`\n   * symbol to tag properties, ensuring they remain hidden from enumerations\n   * and cannot be reconfigured or deleted. This enhances property immutability\n   * and privacy within an object. It's particularly useful for securing\n   * properties that should not be exposed or altered.\n   *\n   * @param {object} instance The object instance to apply the patch to.\n   * @param {object} [store=Object.create(null)] An optional store object to\n   * hold patched properties' original values and descriptors. If not provided,\n   * a new object will be used to store this information.\n   * @returns {object} The result of applying the descriptor patch, typically\n   * a modified version of the `store` object containing the patched properties'\n   * descriptors.\n   */\n  static immutablyHidden(instance, store = Object.create(null)) {\n    return this.customDescriptorPatch(instance, this.kImmutablyHidden, store)\n  }\n\n  /**\n   * Accessor for a Symbol uniquely identifying properties that are visible\n   * (enumerable) but not configurable. This symbol is used to tag properties\n   * to ensure they are included in enumerations such as loops and object\n   * keys retrievals, yet cannot be reconfigured or deleted. This provides a\n   * balance between visibility and immutability. The symbol is generated or\n   * retrieved based on a standardized JSON string, ensuring consistency\n   * across different parts of the application.\n   *\n   * @returns {symbol} A Symbol for properties that are enumerable but not\n   * configurable, making them visible in enumerations while preventing\n   * modifications to their descriptors.\n   */\n  static get kImmutablyVisible() {\n    return Symbol.for('{\"enumerable\":true,\"configurable\":false}')\n  }\n\n  /**\n   * Applies a descriptor patch to an object instance, marking properties as\n   * enumerable but not configurable. This method leverages the\n   * `kImmutablyVisible` symbol to tag properties, ensuring they are visible\n   * in property enumerations like loops and `Object.keys` retrievals, yet\n   * remain immutable by preventing reconfiguration or deletion. This method\n   * is particularly useful for making properties visible while maintaining\n   * their immutability and preventing modifications.\n   *\n   * @param {object} instance The object instance to apply the patch to.\n   * @param {object} [store=Object.create(null)] An optional store object to\n   * hold patched\n   * properties' original values and descriptors. If not provided, a new\n   * object will be used to store this information.\n   * @returns {object} The result of applying the descriptor patch, typically\n   * a modified version of the `store` object containing the patched properties'\n   * descriptors.\n   */\n  static immutablyVisible(instance, store = Object.create(null)) {\n    return this.customDescriptorPatch(instance, this.kImmutablyVisible, store)\n  }\n\n  /**\n   * Applies a custom descriptor patch to an object instance using a provided\n   * symbol to tag the patched properties. This method also ensures the instance\n   * is tracked for cleanup and stores the patch information in a WeakMap for\n   * future reference or rollback. It's designed to work with property\n   * descriptors that are either hidden or visible but immutable.\n   *\n   * @param {symbol} symbol The symbol used to tag the patched properties,\n   * indicating the nature of the patch (e.g., hidden or visible but immutable).\n   * @param {object} instance The object instance to which the patch is applied.\n   * @param {object} [store=Object.create(null)] An optional object to store\n   * the original property descriptors before the patch is applied. If not\n   * provided, an empty object will be used.\n   * @returns {object} The store object associated with the instance in the\n   * WeakMap, containing the patched properties' descriptors.\n   */\n  static customDescriptorPatch(instance, symbol, store = Object.create(null)) {\n    if (!this.stores.has(instance)) {\n      this.stores.set(instance, store);\n\n      if (Patch.isKnownPatchSymbol(symbol)) {\n        store[symbol] = Object.create(null);\n        return this.stores.get(instance)[symbol];\n      }\n    }\n\n    return this.stores.get(instance);\n  }\n\n  /**\n   * Determines if a given symbol is recognized as a patch symbol within the\n   * system. Patch symbols are predefined symbols used to tag properties with\n   * specific visibility and mutability characteristics. This method checks\n   * if the provided symbol matches any of the known patch symbols.\n   *\n   * @param {symbol} maybeSymbol The symbol to check against known patch symbols.\n   * @returns {boolean} True if the symbol is a known patch symbol, false otherwise.\n   */\n  static isKnownPatchSymbol(maybeSymbol) {\n    if (typeof maybeSymbol === 'symbol') {\n      return [\n        this.kImmutablyHidden,\n        this.kImmutablyVisible,\n        this.kMutablyHidden,\n        this.kMutablyVisible\n      ].some(symbol => symbol === maybeSymbol)\n    }\n\n    return false\n  }\n\n  /**\n   * Constructs an object or executes a function based on the `patchesOwner`\n   * parameter, utilizing a custom descriptor patch. This method is intended\n   * for advanced manipulation of object properties or function behaviors\n   * through patching mechanisms defined by symbols. It applies a custom\n   * descriptor patch to the `instance` using the provided `symbol` and\n   * `store`, then either returns the `patchesOwner` directly if it's not a\n   * function, or invokes it with the patched store.\n   *\n   * @param {Function|Object} patchesOwner The target function to be invoked\n   * or the object to be returned directly. If a function, it is called with\n   * the patched store.\n   * @param {Object} instance The object instance to which the patch is applied.\n   * @param {Symbol} symbol A symbol indicating the nature of the patch to be\n   * applied, typically representing specific property behaviors.\n   * @param {Object} [store=Object.create(null)] An optional object to store\n   * the original property descriptors before the patch is applied. Defaults\n   * to an empty object if not provided.\n   * @returns {Function|Object} The result of calling `patchesOwner` with the\n   * patched store if `patchesOwner` is a function, or `patchesOwner` itself\n   * if it is not a function.\n   */\n  static constructWithStore(\n    patchesOwner,\n    instance,\n    symbol,\n    store = Object.create(null)\n  ) {\n    if (typeof patchesOwner !== 'function') {\n      return patchesOwner;\n    }\n\n    try {\n      const useStore = Patch.customDescriptorPatch(instance, symbol, store);\n      return patchesOwner(useStore);\n    }\n    catch (ignored) {\n      console.error(ignored);\n      return patchesOwner;\n    }\n  }\n\n  /**\n   * Retrieves descriptor overrides from a symbol if it is recognized as a\n   * known patch symbol. This method is crucial for dynamically adjusting\n   * property descriptors based on predefined symbols, facilitating the\n   * application of specific property behaviors (e.g., visibility, mutability)\n   * without direct manipulation of the descriptors. It parses the symbol's\n   * description, which is expected to be a JSON string representing the\n   * descriptor overrides, and returns these overrides as an object.\n   *\n   * @param {symbol} symbol The symbol whose description contains JSON\n   * stringified descriptor overrides.\n   * @returns {object} An object representing the descriptor overrides if the\n   * symbol is recognized; otherwise, an empty object.\n   */\n  static getDescriptorOverridesFromSymbol(symbol) {\n    let overrides = Object.create(null)\n\n    if (this.isKnownPatchSymbol(symbol)) {\n      overrides = JSON.parse(symbol.description)\n    }\n\n    return overrides;\n  }\n\n  /**\n   * A WeakMap to store patch information for object instances. This map\n   * associates each patched object instance with its corresponding store\n   * object, which contains the original property descriptors before the\n   * patch was applied. The use of a WeakMap ensures that the memory used\n   * to store this information can be reclaimed once the object instances\n   * are no longer in use, preventing memory leaks.\n   */\n  static stores = new WeakMap();\n\n  /**\n   * Creates and returns an object that wraps a string with additional\n   * properties and methods, making it more informative and useful for\n   * debugging purposes. This method enhances a string by associating it\n   * with a key-value pair and providing custom inspection functionality\n   * for Node.js environments.\n   *\n   * @param {string} string The base string to be wrapped and enhanced.\n   * @param {string} key The key associated with the string, accessible via the\n   * `key` property of the returned object.\n   * @param {any} value The value associated with the key, accessible via the\n   * `value` property of the returned object.\n   * @returns {object} An object that wraps the original string and includes\n   * additional properties (`key`, `value`, `entry`, `entries`) and methods\n   * (`valueOf`, custom inspection method for Node.js) for enhanced usability\n   * and debugging.\n   */\n  static stringRef(string, key, value) {\n    const stringObj = Object.assign(Object(string), {\n      get key() { return key },\n      get value() { return value },\n      get entry() { return [key, value] },\n      get entries() { return [this.entry] },\n      valueOf() { return String(this) },\n      [Symbol.toStringTag]: 'String',\n      [Symbol.for('nodejs.util.inspect.custom')](_, __, inspect) {\n        return inspect(String(this), { colors: true })\n      }\n    });\n\n    return stringObj\n  }\n\n  /**\n   * Checks if all own property names of an instance are also present as own\n   * property names in a given prototype or the instance's constructor\n   * prototype. This method is useful for determining if an instance shares\n   * all its own property names with a prototype, which can be helpful in\n   * various forms of type or structure validation.\n   *\n   * @param {object} instance The object instance whose own property names are\n   * to be checked.\n   * @param {object} [prototype] The prototype object to compare against. If not\n   * provided, the method uses the instance's constructor prototype.\n   * @returns {boolean} Returns true if all own property names of the instance\n   * are also own property names in the given prototype or the instance's\n   * constructor prototype. Otherwise, returns false.\n   */\n  static shareOwnPropertyNames(instance, prototype) {\n    const ownPropNames = o => Object.getOwnPropertyNames(Object(o))\n\n    return ownPropNames(instance).every(key =>\n      ownPropNames(prototype ?? instance?.constructor?.prototype).\n      some(innerKey => innerKey == key)\n    )\n  }\n\n\n  /**\n   * Extracts a descriptive name for a given object or function. This method\n   * attempts to identify the most appropriate name based on the object's\n   * characteristics or its constructor's name. If no specific name can be\n   * determined, it falls back to a provided default name or generates a\n   * unique identifier.\n   *\n   * The method first checks if the object is a non-function or an exception\n   * like `Function.prototype`, and if it shares all the same own property\n   * names as its constructor's prototype, it returns the constructor's name\n   * with `.prototype` appended. If this check fails, it looks for a\n   * `Symbol.toStringTag` property, then for a function's `name` property,\n   * and then evaluates `defaultName` if it's a function or uses its string\n   * value. If all these checks fail, it looks for known exceptions like\n   * `Reflect` or generates a random string prefixed with `Unknown.`.\n   *\n   * @param {object|function} object The object or function to extract the name\n   * from.\n   * @param {string|function} defaultName A default name or a function that\n   * returns a default name to use if no specific name can be determined.\n   * @returns {string} The extracted name or the default/fallback name.\n   */\n  static extractName(object, defaultName) {\n    // Short-hand helper for Array.some(k => k === value)\n    const oneOf = (a,type) => a.some(value => value === type)\n\n    // Initially set valueOf to undefined\n    let valueOf = undefined\n\n    // Skipping known exceptions, check to see if the valueOf() exists\n    if (!oneOf([Symbol.prototype, Date.prototype, BigInt.prototype], object)) {\n      valueOf = object?.valueOf?.()\n    }\n\n    // Check to see if the result from valueOf() is a String\n    let valueOfAsString = (\n      (valueOf && (valueOf instanceof String || typeof valueOf === 'string'))\n        ? String(valueOf)\n        : undefined\n    )\n\n    return (\n      // If its a symbol, use its String() value\n      (typeof object === 'symbol' ? String(object) : undefined) ??\n      (typeof object === 'string' ? object : undefined) ??\n      (object instanceof String ? String(object) : undefined)\n    ) || (\n      // If we have a non-function (Function.prototype is the exception)\n      // and we do have a constructor property, we share all the same\n      // ownPropertyNames as the constructor's prototype (string instances\n      // do not have the same props for example) then we can probably\n      // assume we have a class/function prototype so return its name plus\n      // .prototype\n      (\n        (object === Function.prototype || typeof object !== 'function') &&\n        typeof object !== 'symbol'\n      ) &&\n      Patch.shareOwnPropertyNames(object) &&\n      object?.constructor?.name &&\n      `${object.constructor.name}.prototype`\n    ) || (\n      // Look for a Symbol.toStringTag first as this denotes a specified name\n      object?.[Symbol.toStringTag] ??\n\n      // Look for a function instance .name property next\n      object?.name ??\n\n      // Look for object.valueOf() and see if its a string\n      valueOfAsString ??\n\n      // If defaultName is a function, use its return value\n      (typeof defaultName === 'function' ? defaultName(object) : undefined) ??\n\n      // If defaultName is a string, use its value\n      (typeof defaultName === 'string' ? defaultName : undefined) ??\n\n      // Check for rare exceptions like Reflect (add more here as found)\n      Object.entries({\n        Reflect\n      }).find(([k,v]) => v === object)?.[0] ??\n\n      // Finally generate an Unknown.{randomString} value if nothing else works\n      `Unknown.${Math.random().toString(36).slice(2)}`\n    )\n  }\n}\n\n/**\n * Custom inspection function for Node.js `util.inspect` that formats the\n * entries of the Patch.patches Map for improved readability in console output.\n * This function is specifically designed to be used as a custom inspection\n * function within Node.js environments, enhancing the debugging experience\n * by providing a clear, formatted view of the Patch.patches Map's entries.\n *\n * @param {number} depth The depth to which the object should be formatted.\n * @param {object} options Formatting options provided by `util.inspect`.\n * @param {function} inspect The inspection function provided by Node.js\n * `util.inspect`, allowing for custom formatting of nested properties.\n * @returns {string} A formatted string representation of the Patch.patches\n * Map's entries, with each key-value pair on a new line and keys highlighted\n * for easy identification.\n */\nPatch.patches[Symbol.for('nodejs.util.inspect.custom')] = function(\n  depth,\n  options,\n  inspect\n) {\n  let parts = [\n    'Patches [',\n    ([...this.entries()]\n      .map(([key, value]) => {\n        const patches = (value\n          .map(patch => `${' '.repeat(2)}${inspect(patch, options)}`)\n          .toSorted()\n          .join('\\n')\n        )\n\n        return (\n          `\\x1b[22;1m${Patch.extractName(key)}\\x1b[22m =>\\n` +\n          `${patches}\\n`\n        );\n      })\n      .toSorted()\n      .join('\\n')\n    ),\n    ']'\n  ];\n\n  if (parts[1].includes('\\n')) {\n    // Indent each line of the body by two spaces\n    parts[1] = (parts[1]\n      .split('\\n')\n      .map(line => `${' '.repeat(2)}${line}`)\n      .join('\\n')\n    );\n\n    // Join the output with new lines surrounding the body\n    let output = parts.join('\\n');\n    return output.replace(/\\n\\s*\\n]$/m, '\\n]');\n  }\n\n  if (!parts[1]) {\n    parts[1] = '\\x1b[2;3mNo patches or extensions yet\\x1b[22;23m'\n  }\n\n  return parts.join('');\n}", "import { CannotBeExtendedError } from \"./errors/CannotBeExtendedError.js\"\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js'\nimport { Patch } from './patch.js'\n\n/** Shared array of primitive types for use with `isPrimitive` */\nconst primitives = ['number', 'boolean', 'bigint', 'string', 'symbol']\n\n/**\n * The Extension class, inheriting from the Patch class, is specifically designed\n * for extending properties or methods of a given object. It facilitates the\n * extension process by determining the target key and value for the extension and\n * ensuring the target property is writable and configurable. If these conditions\n * are not met, the class throws a CannotBeExtendedError. This class is useful\n * in scenarios like testing, dynamic behavior adjustments, or managing complex\n * object configurations.\n */\nexport class Extension extends Patch {\n  /**\n   * Constructs a new Extension instance. This constructor initializes the extension\n   * by determining the target key and value for the extension and ensuring that\n   * the property to be extended is configurable and writable. It throws an error\n   * if these conditions are not satisfied. The constructor leverages the Patch\n   * class's functionalities to manage the extension effectively.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function to be\n   * used for the extension. If a function or class is provided, its name is used\n   * as the key.\n   * @param {*} value - The value or method to be used for the extension.\n   * @param {object} [owner=globalThis] - The object to which the extension will\n   * be applied.\n   * @param {object} [options={}] - Additional options for the extension behavior.\n   * @throws {CannotBeExtendedError} If the target property is not writable or\n   * configurable.\n   * @throws {MissingOwnerValue} If the `keyClassOrFn` value is null or there\n   * is an error determining the key and extension values, MissingOwnerValue is\n   * thrown.\n   */\n  constructor(keyClassOrFn, value, owner = globalThis, options = {}) {\n    const metadata = Extension.determineInput(keyClassOrFn)\n    let { key, extension, valid } = metadata\n    extension = value || extension\n\n    if (!valid) {\n      throw new MissingOwnerValue(owner, key)\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(owner, key)\n    if (descriptor) {\n      if (\n        (Reflect.has(descriptor, 'writable') && !descriptor.writable) ||\n        (Reflect.has(descriptor, 'configurable') && !descriptor.configurable)\n      ) {\n        throw new CannotBeExtendedError(owner, key)\n      }\n    }\n\n    super(owner, { [key]: extension }, options)\n    this.key = key\n\n    this.class = metadata.class\n    this.function = metadata.function\n  }\n\n  /**\n   * Returns true if this `Extension` represents a `function`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a `function`, or\n   * `false` if it does not\n   */\n  get isFunction() { return !!(this.function) }\n\n  /**\n   * Returns true if this `Extension` represents a `class`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a `class`, or\n   * `false` if it does not\n   */\n  get isClass() { return !!(this.class) }\n\n  /**\n   * Returns true if this `Extension` represents a `primitive`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a\n   * primitive value or `false` if it does not.\n   */\n  get isPrimitive() {\n    return ~primitives.indexOf(typeof this.value)\n  }\n\n  /**\n   * Returns true if this `Extension` represents a value that is not\n   * coerced into an `Object` wrapper when wrapped with `Object(value)`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a value\n   * that is alrady an `object`, `false` otherwise.\n   */\n  get isObject() {\n    return Object(this.value) === this.value\n  }\n\n  /**\n   * A static getter that provides a proxy to manage and interact with the\n   * patches that have been applied globally. This proxy abstracts the\n   * underlying details and presents a simplified interface for querying and\n   * manipulating applied patches. It is particularly useful in IDEs, as it\n   * allows developers to access the state of applied patches without needing\n   * to delve into the source code.\n   *\n   * @returns {Object} An object showing all the keys known to be patched for\n   * the default owner, `globalThis`\n   */\n  static get applied() {\n    return Patch.applied;\n  }\n\n  /**\n   * A static getter that provides access to a proxy representing all known\n   * patches, whether applied or not. This is useful for inspecting the\n   * complete set of patches that have been registered in the system, without\n   * limiting the view to only those that are currently active. The proxy\n   * abstracts the underlying details and presents a simplified interface for\n   * querying and manipulating the patches.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of all\n   * registered patches, allowing for operations like checking if a patch is\n   * known and retrieving patch values.\n   */\n  static get known() {\n    return Patch.known;\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with a toggle functionality. This proxy allows the temporary\n   * application of patches within a certain scope, and automatically reverts\n   * them after the scope ends. It is useful for applying patches in a\n   * controlled manner, ensuring that they do not remain active beyond the\n   * intended usage.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with toggle functionality, allowing for temporary application\n   * and automatic reversion of patches.\n   */\n  static get use() {\n    return Patch.use;\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with lazy initialization. This proxy defers the creation and\n   * application of patches until they are explicitly requested. It is\n   * beneficial for performance optimization, as it avoids the overhead of\n   * initializing patches that may not be used.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with lazy initialization, allowing patches to be created and\n   * applied only when needed.\n   */\n  static get lazy() {\n    return Patch.lazy;\n  }\n\n\n  /**\n   * Returns an object with getters to access different proxy views of patches\n   * scoped to a specific owner. This allows for interaction with patches\n   * that are either applied, known, or used within a certain scope, providing\n   * a controlled environment for patch management.\n   *\n   * @param {object} owner - The object to scope the patch proxies to.\n   * @returns {object} An object containing getters for `applied`, `known`,\n   * and `use` proxies:\n   * - `applied`: Proxy for patches applied to the owner.\n   * - `known`: Proxy for all patches known to the owner, applied or not.\n   * - `use`: Proxy that allows temporary application of patches.\n   */\n  static scopedTo(owner) {\n    return Patch.scopedTo(owner);\n  }\n\n  /**\n   * Determines the input type for the extension. This method processes the input\n   * and identifies the key for the extension and the associated value or method.\n   * It supports inputs as either a string key or a function/class, providing\n   * flexibility in defining extensions.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function provided\n   * as input. If a function or class is provided, its name is used as the key.\n   * containing the determined key, the extension value/method, and a validity flag\n   * indicating whether the input is usable.\n   * @returns {{key: string|null, extension: *|null, valid: boolean}} An object\n   */\n  static determineInput(keyClassOrFn) {\n    let input = { key: null, extension: null, valid: false }\n\n    if (keyClassOrFn instanceof Function) {\n      input = {\n        key: keyClassOrFn.name,\n        extension: keyClassOrFn,\n        valid: true\n      }\n\n      if (/^class .*/.exec(keyClassOrFn.toString())) {\n        input.class = keyClassOrFn\n      }\n\n      if (/^(async )?function .*/.exec(keyClassOrFn.toString())) {\n        input.function = keyClassOrFn\n      }\n    }\n    else if (typeof keyClassOrFn === 'string' || keyClassOrFn instanceof String) {\n      input = { key: keyClassOrFn, extension: null, valid: true }\n    }\n\n    return input\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the Extension instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the Extension instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const exprs = {\n      get braces() { return /^(\\x1B\\[\\d+m)?[\\[\\{]|[\\]\\}](\\x1B\\[\\d+m)?$/g },\n    }\n\n    const val =\n      inspect(this.patches[this.key], options).replaceAll(exprs.braces, '$1$2')\n\n    return `Extension[${val}]`\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Provides the class name when the\n   * object is converted to a string, typically used for debugging and logging.\n   *\n   * @returns {string} The class name of the Extension instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Creates a new ExtensionSet with the provided name and extensions.\n   *\n   * @param {string} name - The name of the extension set.\n   * @param {...Extension|Function} extensions - A list of extensions or\n   * functions to include in the set.\n   * @returns {ExtensionSet} A new instance of ExtensionSet containing the\n   * given extensions.\n   */\n  static createSet(name, ...extensions) {\n    return new Extension.ExtensionSet(name, ...extensions)\n  }\n\n  /**\n   * Represents a set of extensions.\n   */\n  static ExtensionSet = class ExtensionSet {\n    /**\n     * Creates an instance of ExtensionSet.\n     *\n     * @param {string} name - The name of the extension set.\n     * @param {...(Extension|Function)} extensions - Extensions or functions to\n     * add to the set.\n     */\n    constructor(name, ...extensions) {\n      this.name = name;\n      this.extensionObjects = new Set();\n      this.extensions = new Set();\n\n      for (const extensionValue of extensions) {\n        if (extensionValue instanceof Extension) {\n          this.extensions.add(extensionValue);\n          this.extensionObjects.add(extensionValue.patches[extensionValue.key]);\n        } else if (extensionValue instanceof Function) {\n          this.extensionObjects.add(extensionValue);\n          this.extensions.add(new Extension(extensionValue));\n        }\n      }\n    }\n\n    /**\n     * Applies all extensions in the set.\n     */\n    apply() {\n      for (const extension of this.extensions) {\n        extension.apply();\n      }\n    }\n\n    /**\n     * Reverts all extensions in the set.\n     */\n    revert() {\n      for (const extension of this.extensions) {\n        extension.revert();\n      }\n    }\n  }\n}", "import { Patch } from '@nejs/extension'\n\n/**\n * `ArrayExtensions` is a constant that applies a patch to the global\n * `Array` constructor. This patch extends the `Array` with additional\n * methods and properties, enhancing its functionality.\n *\n * The `Patch` function takes two arguments: the target object to be patched\n * (in this case, `Array`), and an object containing the methods and\n * properties to be added to the target object.\n *\n * @example\n * // Using a method added by ArrayExtensions\n * const arr = [1, 2, 3];\n * console.log(Array.ifArray(arr, 'Array', 'Not Array')); // Output: 'Array'\n *\n * @const\n * @type {Patch}\n * @memberof module:array.extensions\n */\nexport const ArrayExtensions = new Patch(Array, {\n  /**\n   * Checks if the provided value is an array and returns one of two\n   * provided values based on the result. This function is a convenience\n   * method for performing conditional operations based on the type of\n   * the provided value.\n   *\n   * @name ifArray\n   * @type {function}\n   * @memberof ArrayExtensions\n   * @param {any} value - The value to be checked.\n   * @param {function | any} thenValue - The value to be returned if the\n   * provided value is an array.\n   * @param {function | any} elseValue - The value to be returned if the\n   * provided value is not an array.\n   * @returns {any} Returns `thenValue` if the provided value is an array,\n   * otherwise returns `elseValue`.\n   *\n   * @example\n   * const arr = [1, 2, 3];\n   * console.log(ArrayExtensions.ifArray(arr, 'Array', 'Not Array'));\n   * // Output: 'Array'\n   *\n   * const notArr = \"I'm not an array\";\n   * console.log(ArrayExtensions.ifArray(notArr, 'Array', 'Not Array'));\n   * // Output: 'Not Array'\n   */\n  ifArray(value, thenValue, elseValue) {\n    return isThenElse(Array.isArray(value), thenValue, elseValue)\n  },\n})\n\nconst { ifArray: pIfArray } = ArrayExtensions.patches\n\n/**\n * `ArrayPrototypeExtensions` is a constant that applies a patch to the\n * Array prototype. This patch extends the Array prototype with additional\n * methods and properties, enhancing its functionality.\n *\n * The `Patch` function takes two arguments: the target object to be patched\n * (in this case, `Array.prototype`), and an object containing the methods\n * and properties to be added to the target object.\n *\n * @example\n * // Using a method added by ArrayPrototypeExtensions\n * const arr = [1, 2, 3];\n * console.log(arr.ifArray('Array', 'Not Array')); // Output: 'Array'\n *\n * @const\n * @type {Patch}\n * @memberof module:array.extensions\n */\nexport const ArrayPrototypeExtensions = new Patch(Array.prototype, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Sometimes defining even a short function for the invocation of `find`\n     * can be troublesome. This helper function performs that job for you. If\n     * the specified element is in the array, `true` will be returned.\n     *\n     * @param {*} value the value to search for. This value must triple equals\n     * the array element in order to return true.\n     * @returns true if the exact element exists in the array, false otherwise\n     */\n    contains(value) {\n      return !!this.find(entry => entry === value)\n    },\n\n    /**\n     * The `findEntry` function searches the entries of the object and returns\n     * the `[index, value]` entry array for the first matching value found.\n     *\n     * @param {function} findFn a function that takes the element to be checked\n     * and returns a boolean value\n     * @returns if `findFn` returns `true`, an array with two elements, the first\n     * being the index, the second being the value, is returned.\n     */\n    findEntry(findFn) {\n      const entries = this.entries()\n      const VALUE = 1\n\n      for (let entry of entries) {\n        if (findFn(entry[VALUE])) {\n          return entry\n        }\n      }\n\n      return undefined\n    },\n\n    /**\n     * A getter property that returns the first element of the array. If the\n     * array is empty, it returns `undefined`. This property is useful for\n     * scenarios where you need to quickly access the first item of an array\n     * without the need for additional checks or method calls.\n     *\n     * @returns {*} The first element of the array or `undefined` if the array\n     * is empty.\n     */\n    get first() {\n      return this[0];\n    },\n\n    /**\n     * A getter property that checks if the current context (`this`) is an\n     * array. This is a convenience method that wraps the native\n     * `Array.isArray` function.\n     *\n     * @name isArray\n     * @type {function}\n     * @memberof Array.prototype\n     * @returns {boolean} `true` if the current context is an array,\n     * `false` otherwise.\n     *\n     * @example\n     * const arr = [1, 2, 3];\n     * console.log(arr.isArray); // Output: true\n     *\n     * const notArr = \"I'm not an array\";\n     * console.log(notArr.isArray); // Output: false\n     */\n    get isArray() {\n      return Array.isArray(this)\n    },\n\n    /**\n     * Checks if the current context (`this`) is an array and returns one of\n     * two provided values based on the result. This function is a convenience\n     * method for performing conditional operations based on the type of\n     * the current context.\n     *\n     * @name ifArray\n     * @type {function}\n     * @memberof Array.prototype\n     * @param {function | any} thenValue - The value to be returned if the\n     * current context is an array.\n     * @param {function | any} elseValue - The value to be returned if the\n     * current context is not an array.\n     * @returns {*} Returns `thenValue` if the current context is an array,\n     * otherwise returns `elseValue`.\n     *\n     * @example\n     * const arr = [1, 2, 3];\n     * console.log(arr.ifArray('Array', 'Not Array')); // Output: 'Array'\n     *\n     * const notArr = \"I'm not an array\";\n     * console.log(notArr.ifArray('Array', 'Not Array')); // Output: 'Not Array'\n     */\n    ifArray(thenValue, elseValue) {\n      return pIfArray(this, thenValue, elseValue)\n    },\n\n    /**\n     * Checks if at least one element in the array is equal to the provided\n     * value. This method uses the `Array.prototype.some` function to iterate\n     * over the array and compare each element with the provided value.\n     *\n     * @name oneIs\n     * @type {function}\n     * @memberof Array.prototype\n     * @param {*} value - The value to be compared with the array elements.\n     * @param {boolean} [doubleEqualsOkay=true] - A flag indicating whether to\n     * use loose equality (`==`) or strict equality (`===`) for the comparison.\n     * If `true`, loose equality is used. If `false`, strict equality is used.\n     * @returns {boolean} Returns `true` if at least one element in the array\n     * is equal to the provided value, otherwise `false`.\n     *\n     * @example\n     * const arr = [1, 2, 3];\n     * console.log(arr.oneIs(2)); // Output: true\n     *\n     * const arr2 = ['1', '2', '3'];\n     * console.log(arr2.oneIs(2, false)); // Output: false\n     */\n    oneIs(value, doubleEqualsOkay = true) {\n      return this.some(element => (\n        doubleEqualsOkay ? element == value : element === value\n      ))\n    },\n\n    /**\n     * Checks if some elements in the array are included in the provided values.\n     * This method uses the `Array.prototype.some` function to iterate over the\n     * array and checks if any of the elements are included in the provided values.\n     *\n     * @name someAre\n     * @type {function}\n     * @memberof Array.prototype\n     * @param {...*} values - The values to be checked against the array elements.\n     * @returns {boolean} Returns `true` if at least one element in the array\n     * is included in the provided values, otherwise `false`.\n     *\n     * @example\n     * const arr = [1, 2, 3];\n     * console.log(arr.someAre(2, 4)); // Output: true\n     *\n     * const arr2 = ['1', '2', '3'];\n     * console.log(arr2.someAre(4, 5)); // Output: false\n     */\n    someAre(...values) {\n      return this.some(element => !!~values.indexOf(element))\n    },\n\n    /**\n     * Checks if all elements in the array are equal to the provided value.\n     * This method uses the `Array.prototype.every` function to iterate over\n     * the array and compare each element with the provided value.\n     *\n     * @name allAre\n     * @type {function}\n     * @memberof Array.prototype\n     * @param {*} value - The value to be compared with the array elements.\n     * @param {boolean} [doubleEqualsOkay=true] - A flag indicating whether to\n     * use loose equality (`==`) or strict equality (`===`) for the comparison.\n     * If `true`, loose equality is used. If `false`, strict equality is used.\n     * @returns {boolean} Returns `true` if all elements in the array are equal\n     * to the provided value, otherwise `false`.\n     *\n     * @example\n     * const arr = [2, 2, 2];\n     * console.log(arr.allAre(2)); // Output: true\n     *\n     * const arr2 = ['2', '2', '2'];\n     * console.log(arr2.allAre(2, false)); // Output: false\n     */\n    allAre(value, doubleEqualsOkay = true) {\n      return this.every(element => (\n        doubleEqualsOkay ? element == value : element === value\n      ))\n    },\n\n   /**\n     * A getter property that returns the last element of the array. It\n     * calculates the last index based on the array's length. If the array is\n     * empty, it returns `undefined`. This property is beneficial when you need\n     * to access the last item in an array, improving code readability and\n     * avoiding manual index calculation.\n     *\n     * @returns {*} The last element of the array or `undefined` if the\n     * array is empty.\n     */\n    get last() {\n      return this[this.length - 1];\n    },\n\n    /**\n     * A getter that returns a new array containing only truthy elements.\n     * Filters out falsy values like null, undefined, 0, false, NaN, and ''.\n     * Useful for quickly removing falsy values from an array.\n     *\n     * @returns {Array} A new array with only truthy elements.\n     */\n    get onlyTruthy() {\n      return this.filter(truthy => !!truthy);\n    },\n\n    /**\n     * A getter that returns a new array containing only falsy elements.\n     * Keeps falsy values like null, undefined, 0, false, NaN, and ''.\n     * Useful for isolating falsy values in an array for further processing.\n     *\n     * @returns {Array} A new array with only falsy elements.\n     */\n    get onlyFalsy() {\n      return this.filter(falsy => !!!falsy);\n    },\n\n    // expected usage:\n    // function example(name, age) {\n    //   const variants = [{name}, {age}].variants()\n    //   if (typeof name === 'object')\n    // }\n    variants() {\n      const keys = this.map(o => Object.keys(o)?.[0])\n      const entries = this.map(o => Object.entries(o)?.[0])\n      const object = entries.reduce((acc,[key, value]) => {\n        acc[key] = value;\n        return acc;\n      }, {})\n\n      const result = {\n        order: keys,\n        entries: entries,\n        object: object,\n      }\n\n      Object.defineProperty(result, 'check', {\n        value(position) {\n          if (\n            typeof position !== 'number' &&\n            position >= 0 &&\n            position < this.order.length\n          ) {\n            return false\n          }\n\n          const value = this.entries[position][1]\n\n          if (typeof value === 'object' && value) {\n            if (Object.keys(value).every(key => ~this.order.indexOf(key))) {\n              return true\n            }\n          }\n\n          return false\n        },\n        enumerable: false,\n        configurable: true\n      })\n\n      return result\n    },\n  },\n})\n\n// NOTE to self; this is repeated here otherwise a circular reference from\n// Object<->Function<->Global occurs. See original source in global.this.js\n// {@see globalThis.isThenElse}\nfunction isThenElse(bv, tv, ev) {\n  if (arguments.length > 1) {\n    var _then = isFunction(tv) ? tv(bv) : tv; if (arguments.length > 2) {\n      var _else = isFunction(ev) ? tv(bv) : ev; return bv ? _then : _else\n    } return bv || _then;\n  } return bv\n}", "import { Patch } from '@nejs/extension'\n\n/**\n * `BigIntExtensions` is a patch for the JavaScript built-in `BigInt` class.\n * It adds utility methods to the `BigInt` class without modifying the global\n * namespace directly. This patch includes methods for checking if a value is\n * a `BigInt` and conditionally returning a value based on whether the supplied\n * value is a `BigInt` or not.\n *\n * @type {Patch}\n * @example\n * import { BigIntExtensions } from 'big.int.extension.js'\n *\n * BigIntExtensions.apply()\n * // Now the `BigInt` class has additional methods available\n */\nexport const BigIntExtensions = new Patch(BigInt, {\n  /**\n   * Determines if the supplied `value` is a `BigInt`. This check is\n   * performed by first checking the `typeof` the `value` and then\n   * checking to see if the `value` is an `instanceof` `BigInt`\n   *\n   * @param {*} value The value that needs to be checked to determine\n   * if it is a `BigInt` or not\n   * @returns {boolean} `true` if the supplied `value` is a `BigInt`,\n   * `false` otherwise\n   *\n   * @example\n   * const bigInt = 1234567890123456789012345678901234567890n\n   * isBigInt(bigInt) // true\n   * isBigInt(1234567890123456789012345678901234567890) // false\n   * isBigInt('1234567890123456789012345678901234567890') // false\n   * isBigInt(BigInt('1234567890123456789012345678901234567890')) // true\n   */\n  isBigInt(value) {\n    return typeof value === 'bigint' || value instanceof BigInt\n  },\n\n  /**\n   * Conditionally returns a value based on whether the supplied\n   * `value` is a `BigInt` or not. If the `value` is a `BigInt`,\n   * the `thenValue` will be returned. If it is not a `BigInt`,\n   * the `elseValue` will be returned instead.\n   *\n   * @param {any} value The value to check to determine if it is a\n   * `BigInt`\n   * @param {any} thenValue The value to return if the supplied\n   * `value` is a `BigInt`\n   * @param {any} elseValue The value to return if the supplied\n   * `value` is not a `BigInt`\n   * @returns {any} Either the `thenValue` or `elseValue` depending\n   * on if the supplied `value` is a `BigInt`\n   *\n   * @example\n   * const bigInt = 1234567890123456789012345678901234567890n\n   * const num = 42\n   * ifBigInt(bigInt, 'is a BigInt', 'not a BigInt')\n   * // 'is a BigInt'\n   * ifBigInt(num, 'is a BigInt', 'not a BigInt')\n   * // 'not a BigInt'\n   */\n  ifBigInt(value, thenValue, elseValue) {\n    return isThenElse(this.isBigInt(value), thenValue, elseValue)\n  },\n})\n\nconst { isBigInt: pIsBigInt, ifBigInt: pIfBigInt } = BigIntExtensions.patches\n\n/**\n * `BigIntPrototypeExtensions` is a patch for the JavaScript built-in\n * `BigInt.prototype`. It adds utility methods to the `BigInt` prototype\n * without modifying the global namespace directly. This patch includes\n * methods for checking if a value is a BigInt and conditionally returning\n * a value based on whether the supplied value is a BigInt or not.\n *\n * @type {Patch}\n * @example\n * import { BigIntPrototypeExtensions } from 'big.int.extension.js'\n *\n * BigIntPrototypeExtensions.apply()\n * // Now the `BigInt` prototype has additional methods available\n */\nexport const BigIntPrototypeExtensions = new Patch(BigInt.prototype, {\n  /**\n   * A getter method that returns an object representation of the BigInt\n   * instance.\n   *\n   * This method wraps the BigInt instance in an object, allowing it to be\n   * treated as an object. The returned object is created using the `Object()`\n   * constructor, which takes the BigInt instance as its argument.\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @example\n   * const bigInt = 1234567890123456789012345678901234567890n\n   * console.log(typeof bigInt)           // 'bigint'\n   * console.log(typeof bigInt.instance)  // 'object'\n   */\n  get instance() {\n    return Object(this)\n  },\n\n  /**\n   * A getter method that checks if the current instance is a BigInt.\n   *\n   * This method uses the `pIsBigInt` function from the `BigIntExtensions`\n   * patch to determine if the current instance (`this`) is a BigInt.\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @example\n   * const bigInt = 1234567890123456789012345678901234567890n\n   * console.log(bigInt.isBigInt) // Output: true\n   *\n   * const notBigInt = 42\n   * console.log(notBigInt.isBigInt) // Output: false\n   */\n  get isBigInt() {\n    return pIsBigInt(this)\n  },\n\n  /**\n   * Checks if the current object is a BigInt and returns the corresponding\n   * value based on the result.\n   *\n   * This method uses the `pIfBigInt` function from the `BigIntExtensions`\n   * patch to determine if the current object (`this`) is a BigInt. If it is\n   * a BigInt, the `thenValue` is returned. Otherwise, the `elseValue` is\n   * returned.\n   *\n   * @param {any} thenValue - The value to return if the current object\n   * is a BigInt.\n   * @param {any} elseValue - The value to return if the current object\n   * is not a BigInt.\n   * @returns {any} The `thenValue` if the current object is a BigInt, or\n   * the `elseValue` if it is not a BigInt.\n   *\n   * @example\n   * const bigInt = 1234567890123456789012345678901234567890n\n   * // 'Is a BigInt'\n   * console.log(bigInt.ifBigInt('Is a BigInt', 'Not a BigInt'))\n   *\n   * const notBigInt = 42\n   * // 'Not a BigInt'\n   * console.log(notBigInt.ifBigInt('Is a BigInt', 'Not a BigInt'))\n   */\n  ifBigInt(thenValue, elseValue) {\n    return pIfBigInt(this, thenValue, elseValue)\n  },\n})\n\n// NOTE to self; this is repeated here otherwise a circular reference from\n// Object<->Function<->Global occurs. See original source in global.this.js\n// {@see globalThis.isThenElse}\nfunction isThenElse(bv, tv, ev) {\n  if (arguments.length > 1) {\n    var _then = isFunction(tv) ? tv(bv) : tv; if (arguments.length > 2) {\n      var _else = isFunction(ev) ? tv(bv) : ev; return bv ? _then : _else\n    } return bv || _then;\n  } return bv\n}", "import { Patch } from '@nejs/extension'\n\n/**\n * The `FunctionExtensions` class is a patch applied to the built-in JavaScript\n * `Function` constructor. It extends `Function` with additional utility methods\n * for determining the specific type or nature of function-like objects. These\n * methods allow developers to distinguish between classes, regular functions,\n * async functions, and arrow functions in a more intuitive and straightforward\n * manner. This class is part of the `@nejs/extension` library and enhances the\n * capabilities of function handling and introspection in JavaScript.\n */\nexport const FunctionExtensions = new Patch(Function, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Retrieves the properties of a function and its prototype.\n     *\n     * This method uses the `Reflect.ownKeys` function to get all the keys\n     * (including non-enumerable and symbol keys) of the function and its\n     * prototype. It then uses `Object.getOwnPropertyDescriptor` to get the\n     * property descriptors for each key. The descriptors include information\n     * about the property's value, writability, enumerability, and\n     * configurability.\n     *\n     * @param {Function} fn - The function whose properties are to be retrieved.\n     * @returns {Array} An array containing the function itself, its property\n     * descriptors, its prototype, and the prototype's property descriptors.\n     *\n     * @example\n     * function MyFunction() {}\n     * MyFunction.myProp = 'hello';\n     * MyFunction.prototype.myProtoProp = 'world';\n     *\n     * const result = getClassProperties(MyFunction);\n     * console.log(result);\n     * // Output: [MyFunction, { myProp: { value: 'hello', writable: true,\n     * // enumerable: true, configurable: true } }, MyFunction.prototype,\n     * // { myProtoProp: { value: 'world', writable: true, enumerable: true,\n     * // configurable: true } }]\n     */\n    getClassProperties(fn) {\n      const descriptors = Reflect.ownKeys(fn).reduce((acc, key) => {\n        acc[key] = Object.getOwnPropertyDescriptor(fn, key)\n        return acc\n      }, {})\n\n      const prototypeDescriptors = Reflect.ownKeys(fn.prototype).reduce(\n        (acc, key) => {\n          acc[key] = Object.getOwnPropertyDescriptor(fn.prototype, key)\n          return acc\n        }, {}\n      )\n\n      return [fn, descriptors, fn.prototype, prototypeDescriptors]\n    },\n\n    /**\n     * Determines if a given value is an asynchronous function. It checks if the\n     * value is an instance of `Function` and if its string representation\n     * includes the keyword 'Async'. This method is particularly useful for\n     * identifying async functions.\n     *\n     * @param {*} value - The value to be checked.\n     * @returns {boolean} Returns `true` if the value is an async function,\n     * otherwise `false`.\n     */\n    isAsync(value) {\n      const stringTag = /(\\w+)]/g.exec(Object.prototype.toString.call(value))[1]\n      return (\n        value instanceof Function &&\n        stringTag.includes('Async')\n      )\n    },\n\n    /**\n     * The `ifAsync` function checks if a given value is an async function and\n     * returns one of two provided values based on the result. This function is\n     * a convenience method for performing conditional operations based on the\n     * type of a value.\n     *\n     * @param {*} value - The value to be checked. If this is an async function,\n     * `thenValue` is returned, otherwise `elseValue` is returned.\n     * @param {*} thenValue - The value to be returned if `value` is an async\n     * function.\n     * @param {*} elseValue - The value to be returned if `value` is not an\n     * async function.\n     * @returns {*} Returns `thenValue` if `value` is an async function,\n     * otherwise returns `elseValue`.\n     * @see {@link isThenElse}\n     *\n     * @example\n     * // Suppose we have an async function and a regular function\n     * async function asyncFunc() { return 'I am async'; }\n     * function regularFunc() { return 'I am regular'; }\n     *\n     * // Using ifAsync\n     * console.log(Function.ifAsync(asyncFunc, 'Async', 'Not Async'));\n     * // Output: 'Async'\n     * console.log(Function.ifAsync(regularFunc, 'Async', 'Not Async'));\n     * // Output: 'Not Async'\n     */\n    ifAsync(value, thenValue, elseValue) {\n      return isThenElse(this.isAsync(value), thenValue, elseValue)\n    },\n\n    /**\n     * The function checks if a given value is an async generator function\n     *\n     * @param {any} value - The `value` parameter is the value that we want to\n     * check if it is a generator function.\n     * @returns {boolean} `true` if the value is an instance of a function and\n     * its string tag is 'AsyncGeneratorFunction', otherwise it returns `false`.\n     */\n    isAsyncGenerator(value) {\n      const stringTag = getStringTag(value)\n\n      return (\n        value instanceof Function &&\n        stringTag == 'AsyncGeneratorFunction'\n      )\n    },\n\n    /**\n     * The `ifAsyncGenerator` function checks if a given value is an async\n     * generator function and returns one of two provided values based on the\n     * result. This function is a convenience method for performing conditional\n     * operations based on the type of a value.\n     *\n     * @param {*} value - The value to be checked. If this is an async\n     * generator function, `thenValue` is returned, otherwise `elseValue` is\n     * returned.\n     * @param {*} thenValue - The value to be returned if `value` is an async\n     * generator function.\n     * @param {*} elseValue - The value to be returned if `value` is not an\n     * async generator function.\n     * @returns {*} Returns `thenValue` if `value` is an async generator\n     * function, otherwise returns `elseValue`.\n     *\n     * @example\n     * // Suppose we have an async generator function and a regular function\n     * async function* asyncGenFunc() { yield 'I am async'; }\n     * function regularFunc() { return 'I am regular'; }\n     *\n     * // Using ifAsyncGenerator\n     * console.log(Function.ifAsyncGenerator(asyncGenFunc, 'Async', 'Not Async'));\n     * // Output: 'Async'\n     * console.log(Function.ifAsyncGenerator(regularFunc, 'Async', 'Not Async'));\n     * // Output: 'Not Async'\n     */\n    ifAsyncGenerator(value, thenValue, elseValue) {\n      return isThenElse(this.isAsyncGenerator(value), thenValue, elseValue)\n    },\n\n    /**\n     * Checks if a given value is an arrow function. It verifies if the value is\n     * an instance of `Function`, if its string representation includes the '=>'\n     * symbol, and if it lacks a prototype, which is a characteristic of arrow\n     * functions in JavaScript.\n     *\n     * @param {*} value - The value to be checked.\n     * @returns {boolean} Returns `true` if the value is an arrow function,\n     * otherwise `false`.\n     */\n    isBigArrow(value) {\n      return (\n        value instanceof Function &&\n        String(value).includes('=>') &&\n        !String(value).startsWith('bound') &&\n        !Reflect.has(value, 'prototype')\n      );\n    },\n\n    /**\n     * The `ifBigArrow` function checks if a given value is an arrow function\n     * and returns one of two provided values based on the result. This function\n     * is a convenience method for performing conditional operations based on\n     * the type of a value.\n     *\n     * @param {*} value - The value to be checked. If this is an arrow function,\n     * `thenValue` is returned, otherwise `elseValue` is returned.\n     * @param {*} thenValue - The value to be returned if `value` is an arrow\n     * function.\n     * @param {*} elseValue - The value to be returned if `value` is not an\n     * arrow function.\n     * @returns {*} Returns `thenValue` if `value` is an arrow function,\n     * otherwise returns `elseValue`.\n     *\n     * @example\n     * // Suppose we have an arrow function and a regular function\n     * const arrowFunc = () => 'I am an arrow function';\n     * function regularFunc() { return 'I am a regular function'; }\n     *\n     * // Using ifBigArrow\n     * console.log(Function.ifBigArrow(arrowFunc, 'Arrow', 'Not Arrow'));\n     * // Output: 'Arrow'\n     * console.log(Function.ifBigArrow(regularFunc, 'Arrow', 'Not Arrow'));\n     * // Output: 'Not Arrow'\n     */\n    ifBigArrow(value, thenValue, elseValue) {\n      return isThenElse(this.isBigArrow(value), thenValue, elseValue)\n    },\n\n    /**\n     * Determines if a given value is a bound function. Bound functions are\n     * created using the `Function.prototype.bind` method, which allows setting\n     * the `this` value at the time of binding. This method checks if the value\n     * is an instance of `Function`, if its string representation starts with\n     * 'bound', and if it lacks a `prototype` property. These characteristics\n     * are indicative of bound functions in JavaScript.\n     *\n     * @param {*} value - The value to be checked, typically a function.\n     * @returns {boolean} Returns `true` if the value is a bound function,\n     * otherwise `false`. Bound functions have a specific format in their\n     * string representation and do not have their own `prototype` property.\n     */\n    isBound(value) {\n      return (\n        value instanceof Function &&\n        String(value).startsWith('bound') &&\n        !Reflect.has(value, 'prototype')\n      )\n    },\n\n    /**\n     * The `ifBound` function checks if a given value is a bound function and\n     * returns one of two provided values based on the result. This function\n     * is a convenience method for performing conditional operations based on\n     * the type of a value.\n     *\n     * @param {*} value - The value to be checked. If this is a bound function,\n     * `thenValue` is returned, otherwise `elseValue` is returned.\n     * @param {*} thenValue - The value to be returned if `value` is a bound\n     * function.\n     * @param {*} elseValue - The value to be returned if `value` is not a\n     * bound function.\n     * @returns {*} Returns `thenValue` if `value` is a bound function,\n     * otherwise returns `elseValue`.\n     *\n     * @example\n     * // Suppose we have a bound function and a regular function\n     * const boundFunc = function() { return this.x }.bind({x: 'I am bound'});\n     * function regularFunc() { return 'I am a regular function'; }\n     *\n     * // Using ifBound\n     * console.log(Function.ifBound(boundFunc, 'Bound', 'Not Bound'));\n     * // Output: 'Bound'\n     * console.log(Function.ifBound(regularFunc, 'Bound', 'Not Bound'));\n     * // Output: 'Not Bound'\n     */\n    ifBound(value, thenValue, elseValue) {\n      return isThenElse(this.isBound(value), thenValue, elseValue)\n    },\n\n    /**\n     * Determines if a given value is a class. It checks if the value is an\n     * instance of `Function` and if its string representation includes the\n     * keyword 'class'. This method is useful for distinguishing classes from\n     * other function types in JavaScript.\n     *\n     * @param {*} value - The value to be checked.\n     * @returns {boolean} Returns `true` if the value is a class, otherwise\n     * `false`.\n     */\n    isClass(value) {\n      return value instanceof Function && !!/^class\\s/.exec(String(value))\n    },\n\n    /**\n     * The `ifClass` function checks if a given value is a class and returns\n     * one of two provided values based on the result. This function is a\n     * convenience method for performing conditional operations based on the\n     * type of a value.\n     *\n     * @param {*} value - The value to be checked. If this is a class,\n     * `thenValue` is returned, otherwise `elseValue` is returned.\n     * @param {*} thenValue - The value to be returned if `value` is a class.\n     * @param {*} elseValue - The value to be returned if `value` is not a\n     * class.\n     * @returns {*} Returns `thenValue` if `value` is a class, otherwise returns\n     * `elseValue`.\n     *\n     * @example\n     * // Suppose we have a class and a regular function\n     * class MyClass {}\n     * function myFunction() {}\n     *\n     * // Using ifClass\n     * console.log(Function.ifClass(MyClass, 'Class', 'Not Class'));\n     * // Output: 'Class'\n     * console.log(Function.ifClass(myFunction, 'Class', 'Not Class'));\n     * // Output: 'Not Class'\n     */\n    ifClass(value, thenValue, elseValue) {\n      return isThenElse(this.isClass(value), thenValue, elseValue)\n    },\n\n    /**\n     * Checks if a given value is a regular function. This method verifies if\n     * the value is an instance of `Function`, which includes regular functions,\n     * classes, and async functions but excludes arrow functions.\n     *\n     * @param {*} value - The value to be checked.\n     * @returns {boolean} Returns `true` if the value is a regular function,\n     * otherwise `false`.\n     */\n    isFunction(value) {\n      return value instanceof Function && !Function.isClass(value);\n    },\n\n    /**\n     * The `ifFunction` method checks if a given value is a regular function\n     * and returns one of two provided values based on the result. This method\n     * is a convenience for performing conditional operations based on the\n     * type of a value.\n     *\n     * @param {*} value - The value to be checked. If this is a function,\n     * `thenValue` is returned, otherwise `elseValue` is returned.\n     * @param {*} thenValue - The value to be returned if `value` is a function.\n     * @param {*} elseValue - The value to be returned if `value` is not a\n     * function.\n     * @returns {*} Returns `thenValue` if `value` is a function, otherwise\n     * returns `elseValue`.\n     *\n     * @example\n     * // Suppose we have a function and a non-function value\n     * function myFunction() {}\n     * let notFunction = \"I'm not a function\";\n     *\n     * // Using ifFunction\n     * console.log(Function.ifFunction(myFunction, 'Function', 'Not Function'));\n     * // Output: 'Function'\n     * console.log(Function.ifFunction(notFunction, 'Function', 'Not Function'));\n     * // Output: 'Not Function'\n     */\n    ifFunction(value, thenValue, elseValue) {\n      return isThenElse(this.isFunction(value), thenValue, elseValue)\n    },\n\n    /**\n     * The function checks if a given value is a generator function\n     *\n     * @param {any} value - The `value` parameter is the value that we want to\n     * check if it is a generator function.\n     * @returns {boolean} `true` if the value is an instance of a function and\n     * its string tag is 'GeneratorFunction', otherwise it returns `false`.\n     */\n    isGenerator(value) {\n      const stringTag = getStringTag(value)\n\n      return (\n        value instanceof Function &&\n        stringTag == 'GeneratorFunction'\n      )\n    },\n\n    /**\n     * The `ifGenerator` method checks if a given value is a generator function\n     * and returns one of two provided values based on the result. This method\n     * is a convenience for performing conditional operations based on the\n     * type of a value.\n     *\n     * @param {*} value - The value to be checked. If this is a generator\n     * function, `thenValue` is returned, otherwise `elseValue` is returned.\n     * @param {*} thenValue - The value to be returned if `value` is a generator\n     * function.\n     * @param {*} elseValue - The value to be returned if `value` is not a\n     * generator function.\n     * @returns {*} Returns `thenValue` if `value` is a generator function,\n     * otherwise returns `elseValue`.\n     *\n     * @example\n     * // Suppose we have a generator function and a non-generator function\n     * function* myGenerator() {}\n     * function myFunction() {}\n     *\n     * // Using ifGenerator\n     * console.log(Function.ifGenerator(myGenerator, 'Generator', 'Not Generator'));\n     * // Output: 'Generator'\n     * console.log(Function.ifGenerator(myFunction, 'Generator', 'Not Generator'));\n     * // Output: 'Not Generator'\n     */\n    ifGenerator(value, thenValue, elseValue) {\n      return isThenElse(this.isGenerator(value), thenValue, elseValue)\n    },\n\n    /**\n     * This method modifies the behavior of the `instanceof` operator for a\n     * given class. It does this by defining a custom `Symbol.hasInstance`\n     * method on the class. The custom method checks if the string tag of the\n     * instance matches the name of the class or if the instance is part of\n     * the prototype chain of the class.\n     *\n     * @param {Function} Class - The class for which to modify the behavior\n     * of the `instanceof` operator.\n     *\n     * @example\n     * // Suppose we have a class `MyClass`\n     * class MyClass {}\n     *\n     * // And an instance of the class\n     * const myInstance = new MyClass();\n     *\n     * // Before applying `StringTagHasInstance`, `instanceof` works as usual\n     * console.log(myInstance instanceof MyClass); // Output: true\n     *\n     * // Now we apply `StringTagHasInstance` to `MyClass`\n     * FunctionExtensions.patches.StringTagHasInstance(MyClass);\n     *\n     * // `instanceof` now checks the string tag and the prototype chain\n     * console.log(myInstance instanceof MyClass); // Output: true\n     */\n    StringTagHasInstance(Class) {\n      Object.defineProperty(Class, Symbol.hasInstance, {\n        value: function stringTagAwareHasInstance(fn) {\n          const protoChain = getPrototypeChainEntries(fn)\n          return (\n            fn[Symbol.toStringTag] === this.name ||\n            fn instanceof this\n          )\n        }\n      })\n    },\n  },\n})\n\nconst {\n  isAsyncGenerator: pIsAsyncGenerator,  ifAsyncGenerator: pIfAsyncGenerator,\n  isAsync: pIsAsync,                    ifAsync: pIfAsync,\n  isBigArrow: pIsBigArrow,              ifBigArrow: pIfBigArrow,\n  isBound: pIsBound,                    ifBound: pIfBound,\n  isClass: pIsClass,                    ifClass: pIfClass,\n  isFunction: pIsFunction,              ifFunction: pIfFunction,\n  isGenerator: pIsGenerator,            ifGenerator: pIfGenerator,\n} = FunctionExtensions.patches\n\nexport const FunctionPrototypeExtensions = new Patch(Function.prototype, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Determines if a given value is an asynchronous function. It checks if the\n     * value is an instance of `Function` and if its string representation\n     * includes the keyword 'Async'. This method is particularly useful for\n     * identifying async functions.\n     *\n     * @returns {boolean} Returns `true` if the value is an async function,\n     * otherwise `false`.\n     */\n    get isAsync() {\n      return pIsAsync(this)\n    },\n\n    /**\n     * The `ifAsync` method checks if the current function is asynchronous and\n     * returns one of two provided values based on the result. This method is\n     * a convenience for performing conditional operations based on the\n     * type of a function.\n     *\n     * @param {*} thenValue - The value to be returned if the function is\n     * asynchronous.\n     * @param {*} elseValue - The value to be returned if the function is not\n     * asynchronous.\n     * @returns {*} Returns `thenValue` if the function is asynchronous,\n     * otherwise returns `elseValue`.\n     * @see {@link Function.ifAsync}\n     *\n     * @example\n     * // Suppose we have an async function and a non-async function\n     * async function myAsyncFunction() {}\n     * function myFunction() {}\n     *\n     * // Using ifAsync\n     * console.log(myAsyncFunction.ifAsync('Async', 'Not Async'));\n     * // Output: 'Async'\n     * console.log(myFunction.ifAsync('Async', 'Not Async'));\n     * // Output: 'Not Async'\n     */\n    ifAsync(thenValue, elseValue) {\n      return pIfAsync(this, thenValue, elseValue)\n    },\n\n    /**\n     * The function checks if a given value is an async generator function\n     *\n     * @returns {boolean} `true` if the value is an instance of a function and\n     * its string tag is 'AsyncGeneratorFunction', otherwise it returns `false`.\n     */\n    get isAsyncGenerator() {\n      return pIsAsyncGenerator(this)\n    },\n\n    /**\n     * The `ifAsyncGenerator` method checks if the current function is an\n     * asynchronous generator and returns one of two provided values based on\n     * the result. This method is a convenience for performing conditional\n     * operations based on the type of a function.\n     *\n     * @param {*} thenValue - The value to be returned if the function is an\n     * asynchronous generator.\n     * @param {*} elseValue - The value to be returned if the function is not\n     * an asynchronous generator.\n     * @returns {*} Returns `thenValue` if the function is an asynchronous\n     * generator, otherwise returns `elseValue`.\n     * @see {@link Function.ifAsyncGenerator}\n     *\n     * @example\n     * // Suppose we have an async generator function and a non-async function\n     * async function* myAsyncGeneratorFunction() {}\n     * function myFunction() {}\n     *\n     * // Using ifAsyncGenerator\n     * console.log(myAsyncGeneratorFunction.ifAsyncGenerator(\n     *   'Async Generator', 'Not Async Generator'\n     * ));\n     * // Output: 'Async Generator'\n     * console.log(myFunction.ifAsyncGenerator(\n     *   'Async Generator', 'Not Async Generator'\n     * ));\n     * // Output: 'Not Async Generator'\n     */\n    ifAsyncGenerator(thenValue, elseValue) {\n      return pIfAsyncGenerator(this, thenValue, elseValue)\n    },\n\n    /**\n     * Checks if a given value is an arrow function. It verifies if the value is\n     * an instance of `Function`, if its string representation includes the '=>'\n     * symbol, and if it lacks a prototype, which is a characteristic of arrow\n     * functions in JavaScript.\n     *\n     * @returns {boolean} Returns `true` if the value is an arrow function,\n     * otherwise `false`.\n     */\n    get isBigArrow() {\n      return pIsBigArrow(this)\n    },\n\n    /**\n     * Checks if the current function is a \"big arrow\" function and\n     * returns one of two provided values based on the result.\n     *\n     * A \"big arrow\" function is an arrow function that is not bound\n     * to a specific context and does not have its own `this` value.\n     *\n     * @param {*} thenValue - The value to be returned if the function\n     * is a \"big arrow\" function.\n     * @param {*} elseValue - The value to be returned if the function\n     * is not a \"big arrow\" function.\n     * @returns {*} Returns `thenValue` if the function is a \"big arrow\"\n     * function, otherwise returns `elseValue`.\n     *\n     * @example\n     * // Suppose we have a \"big arrow\" function and a regular function\n     * const bigArrowFn = () => {}\n     * function regularFn() {}\n     *\n     * // Using ifBigArrow\n     * console.log(bigArrowFn.ifBigArrow('Big Arrow', 'Not Big Arrow'))\n     * // Output: 'Big Arrow'\n     * console.log(regularFn.ifBigArrow('Big Arrow', 'Not Big Arrow'))\n     * // Output: 'Not Big Arrow'\n     */\n    ifBigArrow(thenValue, elseValue) {\n      return pIfBigArrow(this, thenValue, elseValue)\n    },\n\n    /**\n     * Determines if a given value is a bound function. Bound functions are\n     * created using the `Function.prototype.bind` method, which allows setting\n     * the `this` value at the time of binding. This method checks if the value\n     * is an instance of `Function`, if its string representation starts with\n     * 'bound', and if it lacks a `prototype` property. These characteristics\n     * are indicative of bound functions in JavaScript.\n     *\n     * @returns {boolean} Returns `true` if the value is a bound function,\n     * otherwise `false`. Bound functions have a specific format in their\n     * string representation and do not have their own `prototype` property.\n     */\n    get isBound() {\n      return pIsBound(this)\n    },\n\n    /**\n     * Checks if the current function is bound and returns one of two\n     * provided values based on the result.\n     *\n     * A bound function is a function that has a fixed `this` value and\n     * may have preset arguments. It is created using the\n     * `Function.prototype.bind` method.\n     *\n     * @param {*} thenValue - The value to be returned if the function\n     * is bound.\n     * @param {*} elseValue - The value to be returned if the function\n     * is not bound.\n     * @returns {*} Returns `thenValue` if the function is bound,\n     * otherwise returns `elseValue`.\n     *\n     * @example\n     * // Suppose we have a bound function and a regular function\n     * const boundFn = function() {}.bind(null)\n     * function regularFn() {}\n     *\n     * // Using ifBound\n     * console.log(boundFn.ifBound('Bound', 'Not Bound'))\n     * // Output: 'Bound'\n     * console.log(regularFn.ifBound('Bound', 'Not Bound'))\n     * // Output: 'Not Bound'\n     */\n    ifBound(thenValue, elseValue) {\n      return pIfBound(this, thenValue, elseValue)\n    },\n\n    /**\n     * Determines if a given value is a class. It checks if the value is an\n     * instance of `Function` and if its string representation includes the\n     * keyword 'class'. This method is useful for distinguishing classes from\n     * other function types in JavaScript.\n     *\n     * @returns {boolean} Returns `true` if the value is a class, otherwise\n     * `false`.\n     */\n    get isClass() {\n      return pIsClass(this)\n    },\n\n    /**\n     * Checks if the current function is a class and returns one of two\n     * provided values based on the result.\n     *\n     * A class is a special type of function in JavaScript that is\n     * defined using the `class` keyword. It serves as a blueprint for\n     * creating objects and encapsulates data and behavior.\n     *\n     * @param {any} thenValue - The value to be returned if the function\n     * is a class.\n     * @param {any} elseValue - The value to be returned if the function\n     * is not a class.\n     * @returns {any} Returns `thenValue` if the function is a class,\n     * otherwise returns `elseValue`.\n     *\n     * @example\n     * // Suppose we have a class and a regular function\n     * class MyClass {}\n     * function myFunction() {}\n     *\n     * // Using ifClass\n     * console.log(MyClass.ifClass('Class', 'Not Class'))\n     * // Output: 'Class'\n     * console.log(myFunction.ifClass('Class', 'Not Class'))\n     * // Output: 'Not Class'\n     */\n    ifClass(thenValue, elseValue) {\n      return pIfClass(this, thenValue, elseValue)\n    },\n\n    /**\n     * Checks if a given value is a regular function. This method verifies if\n     * the value is an instance of `Function`, which includes regular functions,\n     * classes, and async functions but excludes arrow functions.\n     *\n     * @returns {boolean} Returns `true` if the value is a regular function,\n     * otherwise `false`.\n     */\n    get isFunction() {\n      return pIsFunction(this)\n    },\n\n    /**\n     * Checks if the current function is a regular function and returns\n     * one of two provided values based on the result.\n     *\n     * A regular function is an instance of `Function`, which includes\n     * regular functions, classes, and async functions but excludes\n     * arrow functions.\n     *\n     * @param {any} thenValue - The value to be returned if the function\n     * is a regular function.\n     * @param {any} elseValue - The value to be returned if the function\n     * is not a regular function.\n     * @returns {any} Returns `thenValue` if the function is a regular\n     * function, otherwise returns `elseValue`.\n     *\n     * @example\n     * // Suppose we have a regular function and an arrow function\n     * function regularFunction() {}\n     * const arrowFunction = () => {}\n     *\n     * // Using ifFunction\n     * console.log(regularFunction.ifFunction('Regular', 'Not Regular'))\n     * // Output: 'Regular'\n     * console.log(arrowFunction.ifFunction('Regular', 'Not Regular'))\n     * // Output: 'Not Regular'\n     */\n    ifFunction(thenValue, elseValue) {\n      return pIfFunction(this, thenValue, elseValue)\n    },\n\n    /**\n     * The function checks if a given value is a generator function\n     *\n     * @returns {boolean} `true` if the value is an instance of a function and\n     * its string tag is 'GeneratorFunction', otherwise it returns `false`.\n     */\n    get isGenerator() {\n      return pIsGenerator(this)\n    },\n\n    /**\n     * Checks if the current function is a generator function and\n     * returns one of two provided values based on the result.\n     *\n     * A generator function is a special type of function that can be\n     * paused and resumed, allowing it to yield multiple values over\n     * time rather than returning a single value.\n     *\n     * @param {any} thenValue - The value to be returned if the\n     * function is a generator function.\n     * @param {any} elseValue - The value to be returned if the\n     * function is not a generator function.\n     * @returns {any} Returns `thenValue` if the function is a\n     * generator function, otherwise returns `elseValue`.\n     *\n     * @example\n     * // Suppose we have a generator function and a regular function\n     * function* generatorFunction() {\n     *   yield 1\n     *   yield 2\n     *   yield 3\n     * }\n     * function regularFunction() {}\n     *\n     * // Using ifGenerator\n     * console.log(generatorFunction.ifGenerator('Generator', 'Regular'))\n     * // Output: 'Generator'\n     * console.log(regularFunction.ifGenerator('Generator', 'Regular'))\n     * // Output: 'Regular'\n     */\n    ifGenerator(thenValue, elseValue) {\n      return pIfGenerator(this, thenValue, elseValue)\n    },\n\n    /**\n     * Retrieves the properties of the current function and its prototype.\n     *\n     * This method uses the `getClassProperties` function from the\n     * `FunctionExtensions.patches` object to get all the properties of the\n     * current function and its prototype. The properties include both\n     * enumerable and non-enumerable properties, as well as properties\n     * defined with symbols.\n     *\n     * @returns {Array} An array containing the function itself, its property\n     * descriptors, its prototype, and the prototype's property descriptors.\n     *\n     * @example\n     * // Suppose we have a function with a property and a prototype property\n     * function MyFunction() {}\n     * MyFunction.myProp = 'hello';\n     * MyFunction.prototype.myProtoProp = 'world';\n     *\n     * // Using getClassProperties\n     * const result = MyFunction.getClassProperties();\n     * console.log(result);\n     * // Output: [MyFunction, { myProp: { value: 'hello', writable: true,\n     * // enumerable: true, configurable: true } }, MyFunction.prototype,\n     * // { myProtoProp: { value: 'world', writable: true, enumerable: true,\n     * // configurable: true } }]\n     */\n    getClassProperties() {\n      return FunctionExtensions.patches.getClassProperties(this)\n    },\n  },\n})\n\n// NOTE to self; this is repeated here otherwise a circular reference from\n// Object<->Function<->Global occurs. See original source in global.this.js\n// {@see globalThis.isThenElse}\nfunction isThenElse(bv, tv, ev) {\n  if (arguments.length > 1) {\n    var _then = isFunction(tv) ? tv(bv) : tv; if (arguments.length > 2) {\n      var _else = isFunction(ev) ? tv(bv) : ev; return bv ? _then : _else\n    } return bv || _then;\n  } return bv\n}\n\nfunction hasStringTag(value) {\n  return Object.isObject(value) && Reflect.has(value, Symbol.toStringTag)\n}\n\nfunction getStringTag(value, strict = false) {\n  if (Object.hasStringTag(value)) {\n    return value[Symbol.toStringTag]\n  }\n\n  if (strict) {\n    return undefined\n  }\n\n  if (value && (typeof value === 'function')) {\n    return value.name\n  }\n\n  return /\\s(.+)]/.exec(Object.prototype.toString.call(value))[1];\n}\n\nfunction getPrototypeChainEntries(object) {\n  const entries = []\n\n  let prototype = Object.getPrototypeOf(object)\n  while (prototype) {\n    const descriptors = Reflect.ownKeys(prototype).reduce((acc, key) => {\n      acc[key] = Object.getOwnPropertyDescriptor(prototype, key)\n      return acc\n    }, {})\n\n    entries.push([prototype, descriptors])\n\n    prototype = Object.getPrototypeOf(prototype)\n  }\n\n  return entries\n}", "import { Patch } from '@nejs/extension'\nimport { FunctionExtensions } from './function.extensions.js'\n\nconst { isClass, isFunction } = FunctionExtensions.patches\nconst CustomInspect = Symbol.for('nodejs.util.inspect.custom')\n\nexport const GlobalFunctionsAndProps = new Patch(globalThis, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * The `isThenElse` function is a utility function that behaves like a\n     * ternary operator. It takes three arguments: `boolValue`, `thenValue`,\n     * and `elseValue`.\n     *\n     * It first checks the truthiness of `boolValue`.\n     *\n     * If `boolValue` is truthy, it returns `thenValue`; otherwise,\n     * it returns `elseValue`.\n     *\n     * If `thenValue` or `elseValue` is a function, it will be invoked with\n     * `boolValue` as an argument.\n     *\n     * If `elseValue` is not provided, it returns `boolValue` or `thenValue`\n     * depending on the truthiness of `boolValue`.\n     *\n     * If only `boolValue` is provided, it simply returns `boolValue`.\n     *\n     * @param {any} boolValue - Any object or value that is tested for\n     * truthiness.\n     * @param {function | any} [thenValue] - The value to return if `boolValue`\n     * is truthy. If a function, it's invoked with `boolValue`.\n     * @param {function | any} [elseValue] - The value to return if `boolValue`\n     * is falsy. If a function, it's invoked with `boolValue`.\n     * @returns {boolean | any} The result of the ternary operation.\n     *\n     * @example\n     * // Using values\n     * isThenElse(true, 'yes', 'no');  // Returns: 'yes'\n     * isThenElse(false, 'yes', 'no'); // Returns: 'no'\n     *\n     * // Using functions\n     * isThenElse(true, val => val ? 'yes' : 'no');  // Returns: 'yes'\n     * isThenElse(false, val => val ? 'yes' : 'no'); // Returns: 'no'\n     */\n    isThenElse(boolValue, thenValue, elseValue) {\n      if (arguments.length > 1) {\n        const _then = isFunction(thenValue) ? thenValue(boolValue) : thenValue\n\n        if (arguments.length > 2) {\n          const _else = isFunction(elseValue) ? thenValue(boolValue) : elseValue\n\n          return boolValue ? _then : _else\n        }\n\n        return boolValue || _then\n      }\n\n      return boolValue\n    },\n\n    /**\n     * Transforms an object to mimic a specified prototype, altering its type\n     * conversion and inspection behaviors. This function is especially useful\n     * for creating objects that need to behave like different primitive types\n     * under various operations.\n     *\n     * @param {Object} object - The object to be transformed.\n     * @param {Function|Object} [prototype=String.prototype] - The prototype or\n     * class to emulate. If a function is provided, its prototype is used.\n     * Defaults to String.prototype.\n     * @param {Function} [toPrimitive=(hint, val) => String(val)] - A function\n     * defining how the object should be converted to a primitive value. It\n     * receives a type hint ('number', 'string', or 'default') and the object,\n     * returning the primitive value.\n     * @returns {Object|null} The transformed object, or null if neither a class\n     * nor a prototype could be derived from the provided prototype parameter.\n     */\n    maskAs(object, classPrototype, options) {\n      const {\n        prototype,\n        toPrimitive\n      } = GenericMask({...options, prototype: classPrototype})\n\n      const base = { configurable: true, enumerable: false }\n      const proto = isFunction(prototype) ? prototype.prototype : prototype\n      const klass = isClass(prototype) ? prototype : proto?.constructor\n\n      if (!klass && !proto) {\n        return null\n      }\n\n      Object.setPrototypeOf(object, proto)\n      Object.defineProperties(object, {\n        valueOf: {\n          value() { return String(toPrimitive('default', object)) }, ...base },\n\n        [Symbol.toPrimitive]: {\n          value(hint) { return toPrimitive(hint, object) }, ...base\n        },\n        [Symbol.toStringTag]: { value: klass.name, ...base },\n        [Symbol.species]: { get() { return klass }, ...base },\n        [CustomInspect]: { ...base, value(depth, opts, inspect) {\n          return inspect(this[Symbol.toPrimitive](), { ...opts, depth })\n        }}\n      })\n\n      return object\n    },\n\n    /**\n     * Masks an object as a string-like object by setting its prototype to\n     * String and defining how it converts to primitive types. This is\n     * particularly useful when an object needs to behave like a string in\n     * certain contexts, such as type coercion or logging.\n     *\n     * @param {Object} object - The object to be masked as a string.\n     * @param {string} [stringKey='value'] - The object property key used for\n     * the string representation. Defaults to 'value'.\n     * @param {Function} [toPrimitive] - Optional custom function for primitive\n     * conversion. If omitted, a default function handling various conversion\n     * hints is used.\n     * @returns {Object|null} The string-masked object, or null if the object\n     * doesn't have the specified stringKey property.\n     */\n    maskAsString(\n      object,\n      stringKey,\n      toPrimitive\n    ) {\n      if (object && Reflect.has(object, stringKey)) {\n        return maskAs(object, StringMask(stringKey ?? 'value', toPrimitive))\n      }\n\n      return null\n    },\n\n    /**\n     * Masks an object as a number-like object. This allows the object to\n     * behave like a number in operations like arithmetic and type coercion.\n     * It sets the prototype to Number and defines custom conversion behavior.\n     *\n     * @param {Object} object - The object to be masked as a number\n     * representation. Defaults to 'value'.\n     * @param {Function} [toPrimitive] - Optional custom function for primitive\n     * conversion. If not provided, a default function handling different\n     * conversion hints is used.\n     * @returns {Object|null} The number-masked object, or null if the object\n     * doesn't have the specified numberKey property.\n     */\n    maskAsNumber(\n      object,\n      numberKey,\n      toPrimitive\n    ) {\n      if (object && Reflect.has(object, numberKey)) {\n        return maskAs(object, NumberMask(numberKey ?? 'value', toPrimitive))\n      }\n\n      return null\n    },\n\n    /**\n     * Generates options for generic masking of an object, providing defaults for\n     * prototype and toPrimitive function if not specified.\n     *\n     * @param {Object} options - The options object including prototype,\n     * targetKey, and toPrimitive function.\n     * @returns {Object} The options object with defaults applied as necessary.\n     */\n    GenericMask({ prototype, targetKey = 'value', toPrimitive }) {\n      const options = { targetKey, toPrimitive, prototype };\n\n      if (!isFunction(toPrimitive)) {\n        options.toPrimitive = (hint, object) => {\n          let property = object[targetKey];\n          let isNum = (\n            (typeof property === 'number' && Number.isFinite(property)) ||\n            (typeof property === 'string' &&\n              !isNaN(parseFloat(property)) && isFinite(property)\n            )\n          );\n\n          switch (hint) {\n            case 'string':\n              return isNum ? String(property) : (property ?? String(object));\n            case 'number':\n              return isNum ? Number(property) : NaN;\n            case 'default':\n            default:\n              return isNum ? Number(property) : property;\n          }\n        }\n      }\n\n      return options;\n    },\n\n    /**\n     * Generates options for string masking of an object, providing a default\n     * toPrimitive function if not specified.\n     *\n     * @param {string} targetKey - The object property key for string\n     * representation.\n     * @param {Function} toPrimitive - Custom function for primitive conversion.\n     * @returns {Object} Options for string masking.\n     */\n    StringMask(targetKey, toPrimitive) {\n      const options = { targetKey, toPrimitive, prototype: String.prototype }\n\n      if (!isFunction(toPrimitive)) {\n        options.toPrimitive = function toPrimitive(hint, object) {\n          switch (hint) {\n            case 'default': return object[targetKey]\n            case 'number': return parseInt(object[targetKey], 36)\n            case 'string': return String(object[targetKey])\n            default: return object\n          }\n        }\n      }\n\n      return options\n    },\n\n    /**\n     * Generates options for number masking of an object, providing a default\n     * toPrimitive function if not specified.\n     *\n     * @param {string} targetKey - The object property key for number\n     * representation.\n     * @param {Function} toPrimitive - Custom function for primitive conversion.\n     * @returns {Object} Options for number masking.\n     */\n    NumberMask(targetKey, toPrimitive) {\n      const options = { targetKey, toPrimitive, prototype: Number.prototype }\n\n      if (!isFunction(toPrimitive)) {\n        options.toPrimitive = function toPrimitive(hint, object) {\n          switch (hint) {\n            case 'default': return object[targetKey]\n            case 'number': return Number(object[targetKey])\n            case 'string': return String(object[targetKey])\n            default: return object\n          }\n        }\n      }\n\n      return options\n    },\n\n    /**\n     * Blends the properties of multiple objects into a new object. This\n     * function creates a new object that inherits the prototype from the\n     * root object and the properties of the other objects and their parent\n     * prototypes.\n     *\n     * @param {Object} root - The root object to blend prototypes into.\n     * @param {...Object} objects - The objects whose prototypes to blend.\n     * @returns {Object} The new object with blended prototypes.\n     *\n     * @example\n     * // Define some objects with properties\n     * const obj1 = { prop1: 'value1' }\n     * const obj2 = { prop2: 'value2' }\n     * const obj3 = { prop3: 'value3' }\n     *\n     * // Blend the prototypes of obj2 and obj3 into obj1\n     * const blended = blendProtos(obj1, obj2, obj3)\n     *\n     * // Now blended has properties from obj1, obj2, and obj3\n     * console.log(blended.prop1) // Outputs: 'value1'\n     * console.log(blended.prop2) // Outputs: 'value2'\n     * console.log(blended.prop3) // Outputs: 'value3'\n     */\n    blendProtos(root, ...objects) {\n      const descriptor = (o, k) => Object.getOwnPropertyDescriptor(o,k)\n      const parent = o => Object.getPrototypeOf(o)\n      const all = o => (Reflect\n        .ownKeys(o)\n        .reduce((a, k)=>({ ...a, [k]: descriptor(o,k) }), { })\n      )\n\n      const newRoot = Object.create(parent(root), objects.reduce)\n      const protos = objects.map(object => parent(object))\n\n      let descriptors = Object.create(null)\n      let uniques = new Set\n\n      for (let object of protos) {\n        let current = object\n\n        while (current) {\n          if (!uniques.has(current)) {\n            uniques.add(current)\n            descriptors = { ...descriptors, ...all(current) }\n          }\n          current = parent(current)\n        }\n      }\n\n      const blendedPrototype = Object.create(parent(root), descriptors)\n\n      return Object.setPrototypeOf(newRoot, blendedPrototype)\n    },\n  },\n})\n", "import { Patch } from '@nejs/extension'\n\nexport const JSONExtensions = new Patch(JSON, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * The `extractFrom` method attempts to extract a JSON object from a string.\n     * It uses a regular expression to identify potential JSON objects in the\n     * string and attempts to parse them. If a valid JSON object is found, it is\n     * returned. If no valid JSON object is found, the method returns undefined.\n     *\n     * NOTE: This method will only find JSON from an iterated upon start spot\n     * until the end of the string. So `'JSON follows {\"count\": 0}'` will\n     * return `{count: 0}` but `'JSON follows {\"count\": 0} and more'` will\n     * fail to locate any JSON in the String. You've been warned.\n     *\n     * @param {string} string - The string from which to extract a JSON object.\n     * @returns {Object|undefined} - The first valid JSON object found in the\n     * string, or undefined if no valid JSON object is found.\n     *\n     * @example\n     * // Suppose we have a string with embedded JSON\n     * const str1 = 'Hello {\"name\":\"John\", \"age\":30} World'\n     * const str2 = 'Hello {\"name\": \"John\", \"age\": 30}'\n     *\n     * // Using `extractFrom`\n     * console.log(JSON.extractFrom(str1))  // Output: undefined\n     * console.log(JSON.extractFrom(str2))  // Output: {name: 'John', age: 30}\n     */\n    extractFrom(string) {\n      const pattern = /([\\w\\{\\[\\\"]+) ?/g\n      const decoder = part => {\n        try { return JSON.parse(part) } catch (_) { return undefined }\n      }\n\n      for (\n        let part = pattern.exec(string);\n        part;\n        part = pattern.exec(string)\n      ) {\n        if (part && part?.index) {\n          const decoded = decoder(string.substring(part.index))\n          if (decoded) {\n            return decoded\n          }\n        }\n      }\n\n      return undefined\n    },\n\n    /**\n     * The `mightContain` method checks if a string might contain a JSON object.\n     * It uses the `JSONStartPattern` regular expression to search for potential\n     * JSON objects in the string. If a potential JSON object is found, the method\n     * returns true. If no potential JSON object is found, the method returns false.\n     *\n     * @param {string} string - The string to check for potential JSON objects.\n     * @returns {boolean} - Returns true if the string might contain a JSON object,\n     * false otherwise.\n     *\n     * @example\n     * // Suppose we have a string with embedded JSON\n     * const str = 'Hello {\"name\":\"John\", \"age\":30} World'\n     *\n     * // Using `mightContain`\n     * console.log(JSON.mightContain(str))  // Output: true\n     */\n    mightContain(string, detail = false) {\n      const results = this.JSONStartPattern.exec(string)\n      return detail ? [!!results, results?.index ?? -1, results] : !!results\n    },\n\n    /**\n     * Getter method for the JSONStartPattern.\n     *\n     * This method constructs a regular expression pattern that is used to\n     * identify potential JSON objects in a string. The pattern is designed\n     * to match various JSON data types including null, boolean, number,\n     * string, object, and array.\n     *\n     * The pattern is constructed using an array of strings, each representing\n     * a part of the pattern. The array is then joined into a single string\n     * and passed to the RegExp constructor to create the pattern.\n     *\n     * @returns {RegExp} - The constructed regular expression pattern.\n     *\n     * @example\n     * // Using `JSONStartPattern`\n     * const pattern = JSONStartPattern;\n     * const str = 'Hello {\"name\":\"John\", \"age\":30} World';\n     * const match = pattern.exec(str);\n     * console.log(match[0]);  // Output: '{\"name\":\"John\", \"age\":30}'\n     */\n    get JSONStartPattern() {\n      const pattern = new RegExp([\n        '(?:',                    // Start with a non-capturing group and match\n          '(null)|',              // ...a null\n          '(true|false)|',        // ...a bool\n          '(\\\\d+\\\\.?\\\\d*)|',      // ...a number (including floats)\n          '(\"[^\\\\\"]*(?:[^:])\")|', // ...a double quote (start of string)\n          '((?:\\\\{.*\\\\})+)|',     // ...an open curly brace (object)\n          '((?:\\\\[.*\\\\]+))',      // ...an open square bracket (array)\n        ')+',                     // End of the groups\n      ].join(''), 'gm')\n\n      return pattern\n    },\n  }\n})", "import { Patch } from '@nejs/extension'\n\nexport const MapExtensions = new Patch(Map, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Determines if the supplied `value` is a `Map` object. This check\n     * is performed by first looking for the `Symbol.toStringTag` on the\n     * `value` and checking to see if it is equal to the string \"Map\".\n     * If that check fails, `instanceof` is used as a fallback to check\n     * the prototype chain.\n     *\n     * @param {any} value the value that needs to be checked to determine\n     * if it is a `Map` object or not\n     * @returns {boolean} `true` if the supplied `value` is a `Map`\n     * object, `false` otherwise\n     *\n     * @example\n     * const map = new Map()\n     * isMap(map) // true\n     * isMap(new Set()) // false\n     * isMap([]) // false\n     * isMap({}) // false\n     */\n    isMap(value) {\n      return value?.[Symbol.toStringTag] === Map.name && value instanceof Map\n    },\n\n    /**\n     * Conditionally returns a value based on whether the supplied\n     * `value` is a `Map` object or not. If the `value` is a `Map`\n     * object, the `thenValue` will be returned. If it is not a `Map`\n     * object, the `elseValue` will be returned instead.\n     *\n     * @param {any} value the value to check to determine if it is a\n     * `Map` object\n     * @param {any} thenValue the value to return if the supplied\n     * `value` is a `Map` object\n     * @param {any} elseValue the value to return if the supplied\n     * `value` is not a `Map` object\n     * @returns {any} either the `thenValue` or `elseValue` depending\n     * on if the supplied `value` is a `Map` object\n     *\n     * @example\n     * const map = new Map()\n     * const set = new Set()\n     * ifMap(map, 'is a map', 'not a map') // 'is a map'\n     * ifMap(set, 'is a map', 'not a map') // 'not a map'\n     */\n    ifMap(value, thenValue, elseValue) {\n      return isThenElse(this.isMap(value), thenValue, elseValue)\n    },\n  }\n})\n\nconst { isMap: pIsMap, ifMap: pIfMap } = MapExtensions.patches\n\nexport const MapPrototypeExtensions = new Patch(Map.prototype, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Determines if the current object is a `Map` object\n     *\n     * This is a getter that uses the `isMap` function from the\n     * `MapExtensions` patch to check if the current object (`this`) is\n     * a `Map` object\n     *\n     * @type {boolean}\n     * @readonly\n     *\n     * @example\n     * const map = new Map()\n     * console.log(map.isMap) // Output: true\n     *\n     * const notMap = {}\n     * console.log(notMap.isMap) // Output: false\n     */\n    get isMap() {\n      return pIsMap(this)\n    },\n\n    /**\n     * Conditionally returns a value based on whether the current\n     * object is a `Map` object or not\n     *\n     * If the current object is a `Map` object, the `thenValue` will\n     * be returned. If it is not a `Map` object, the `elseValue` will\n     * be returned instead.\n     *\n     * @param {any} thenValue the value to return if the current\n     * object is a `Map` object\n     * @param {any} elseValue the value to return if the current\n     * object is not a `Map` object\n     * @returns {any} either the `thenValue` or `elseValue` depending\n     * on if the current object is a `Map` object\n     *\n     * @example\n     * const map = new Map()\n     * map.ifMap('is a map', 'not a map') // 'is a map'\n     *\n     * const notMap = {}\n     * notMap.ifMap('is a map', 'not a map') // 'not a map'\n     */\n    ifMap(thenValue, elseValue) {\n      return pIfMap(this, thenValue, elseValue)\n    },\n\n    /**\n     * The function `getKey` returns the key associated with a given value\n     * in a map.\n     *\n     * @param {any} value - The value parameter is the value that you want to\n     * find the corresponding key for in the map.\n     * @param [strict=true] - The \"strict\" parameter is a boolean value that\n     * determines whether strict equality (===) or loose equality (==) should\n     * be used when comparing the \"value\" parameter with the values in the\n     * entries of the object. If \"strict\" is set to true, strict equality will\n     * be used.\n     * @returns the key associated with the given value. If a matching key is\n     * found, it is returned. If no matching key is found, null is returned.\n     */\n    getKey(value, strict = true) {\n      for (const [key, entryValue] of this) {\n        if (\n          (strict && value === entryValue) &&\n          (!strict && value == entryValue)\n        ) {\n          return key\n        }\n\n        return null\n      }\n    },\n  },\n})\n\n// NOTE to self; this is repeated here otherwise a circular reference from\n// Object<->Function<->Global occurs. See original source in global.this.js\n// {@see globalThis.isThenElse}\nfunction isThenElse(bv, tv, ev) {\n  if (arguments.length > 1) {\n    var _then = isFunction(tv) ? tv(bv) : tv; if (arguments.length > 2) {\n      var _else = isFunction(ev) ? tv(bv) : ev; return bv ? _then : _else\n    } return bv || _then;\n  } return bv\n}", "import { Patch } from '@nejs/extension'\n\n/**\n * A patch for the JavaScript built-in `Number` class that adds utility\n * methods without modifying the global namespace directly\n *\n * This patch includes methods for checking if a value is a number and\n * conditionally returning a value based on whether the supplied value is\n * a number or not.\n *\n * @type {Patch}\n * @property {Object} [Patch.kMutablyHidden] An object containing methods\n * that are hidden from enumeration and mutation\n *\n * @example\n * import { NumberExtensions } from 'number.extension.js'\n *\n * NumberExtensions.apply()\n * // Now the `Number` class has additional methods available\n */\nexport const NumberExtensions = new Patch(Number, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Determines if the supplied `value` is a `Number`. This check is\n     * performed by first converting the `value` to a `Number` using the\n     * `Number()` constructor and checking to see if the result is not\n     * `NaN`. If that check passes, `typeof` is used to ensure that the\n     * original `value` is of type \"number\".\n     *\n     * @param {*} value The value that needs to be checked to determine if it\n     * is a `Number` or not\n     * @returns {boolean} `true` if the supplied `value` is a `Number`,\n     * `false` otherwise\n     *\n     * @example\n     * const num = 42\n     * isNumber(num) // true\n     * isNumber('42') // false\n     * isNumber(NaN) // false\n     * isNumber(Infinity) // true\n     */\n    isNumber(value) {\n      return !isNaN(value) && typeof value === 'number'\n    },\n\n    /**\n     * Checks if all or some of the supplied values are numbers.\n     *\n     * This method uses the `Array.prototype.every` or `Array.prototype.some`\n     * method to check if all or some of the supplied values are numbers,\n     * respectively. The method to use is determined by the `which` parameter.\n     *\n     * @param {string} [which='every'] - Determines the method to use for the\n     * check. Can be either 'every' or 'some'. Defaults to 'every'.\n     * @param {...*} values - The values to check.\n     * @returns {boolean} - Returns `true` if all or some of the values are\n     * numbers (based on the `which` parameter), `false` otherwise.\n     *\n     * @example\n     * areNumbers('every', 1, 2, 3) // true\n     * areNumbers('some', 1, '2', 3) // true\n     * areNumbers('every', 1, '2', 3) // false\n     */\n    areNumbers(which = ['every','some'][0], ...values) {\n      if (which !== 'every' && which !== 'some') {\n        return false\n      }\n\n      return values[which](num => this.isNumber(num))\n    },\n\n    /**\n     * Conditionally returns a value based on whether the supplied `value` is\n     * a `Number` or not. If the `value` is a `Number`, the `thenValue` will\n     * be returned. If it is not a `Number`, the `elseValue` will be\n     * returned instead.\n     *\n     * @param {*} value The value to check to determine if it is a `Number`\n     * @param {*} thenValue The value to return if the supplied `value` is\n     * a `Number`\n     * @param {*} elseValue The value to return if the supplied `value` is\n     * not a `Number`\n     * @returns {*} Either the `thenValue` or `elseValue` depending on if the\n     * supplied `value` is a `Number`\n     *\n     * @example\n     * const num = 42\n     * const str = 'hello'\n     * ifNumber(num, 'is a number', 'not a number') // 'is a number'\n     * ifNumber(str, 'is a number', 'not a number') // 'not a number'\n     */\n    ifNumber(value, thenValue, elseValue) {\n      return isThenElse(this.isNumber(value), thenValue, elseValue)\n    },\n\n    /**\n     * Conditionally returns a value based on whether all or some of the\n     * supplied values are numbers.\n     *\n     * This method uses the `areNumbers` method to check if all or some of\n     * the supplied values are numbers, based on the `which` parameter.\n     * If the condition is met, the `thenValue` is returned, otherwise\n     * the `elseValue` is returned.\n     *\n     * @param {*} thenValue - The value to return if the condition is met.\n     * @param {*} elseValue - The value to return if the condition is not met.\n     * @param {string} [which='every'] - Determines the method to use for the\n     * check. Can be either 'every' or 'some'. Defaults to 'every'.\n     * @param {...*} numbers - The values to check.\n     * @returns {*} Either the `thenValue` or `elseValue` depending on if all\n     * or some of the supplied values are numbers.\n     *\n     * @example\n     * ifNumbers('All are numbers', 'Not all are numbers', 'every', 1, 2, 3)\n     * // returns 'All are numbers'\n     * ifNumbers('At least one is a number', 'None are numbers', 'some', 1, '2', 3)\n     * // returns 'At least one is a number'\n     * ifNumbers('All are numbers', 'Not all are numbers', 'every', 1, '2', 3)\n     * // returns 'Not all are numbers'\n     */\n    ifNumbers(\n      thenValue,\n      elseValue,\n      which = ['every','some'][0],\n      ...numbers\n    ) {\n      return isThenElse(\n        this.areNumbers(which, ...numbers),\n        thenValue,\n        elseValue\n      )\n    },\n\n    /**\n     * Clamps a value between a minimum and maximum value.\n     *\n     * This method checks if the provided value and the min and max bounds are\n     * numbers. If they are not, it returns the original value. If they are,\n     * it ensures that the value does not go below the minimum value or above\n     * the maximum value.\n     *\n     * @param {*} value - The value to clamp.\n     * @param {number} [minValue=-Infinity] - The minimum value. Defaults\n     * to -Infinity.\n     * @param {number} [maxValue=Infinity] - The maximum value. Defaults\n     * to Infinity.\n     * @returns {*} - Returns the clamped value if all parameters are numbers,\n     * otherwise returns the original value.\n     *\n     * @example\n     * clamp(10, 1, 5) // returns 5\n     * clamp(-10, 1, 5) // returns 1\n     * clamp(3, 1, 5) // returns 3\n     * clamp('10', 1, 5) // returns '10'\n     */\n    clamp(value, minValue = -Infinity, maxValue = Infinity) {\n      if (!this.areNumbers('every', value, minValue, maxValue)) {\n        return value\n      }\n\n      return Math.max(minValue, Math.min(maxValue, value))\n    },\n  }\n})\n\nconst { isNumber: pIsNumber, ifNumber: pIfNumber } = NumberExtensions.patches\n\n/**\n * `NumberPrototypeExtensions` provides a set of utility methods that\n * are added to the `Number` prototype. This allows all number instances\n * to access new functionality directly, enhancing their capabilities\n * beyond the standard `Number` class methods.\n *\n * These extensions are applied using the `Patch` class from\n * '@nejs/extension', ensuring that they do not interfere with the\n * global namespace or existing properties.\n *\n * The extensions include methods for checking if a value is a number,\n * conditionally returning values based on whether a value is a number,\n * and more, making number-related tasks more convenient and expressive.\n *\n * @example\n * const num = 42\n * console.log(num.isNumber) // Output: true\n *\n * const notNum = \"123\"\n * console.log(notNum.isNumber) // Output: false\n *\n * @type {Patch}\n */\nexport const NumberPrototypeExtensions = new Patch(Number.prototype, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Returns an object representation of the number instance.\n     *\n     * This getter method creates and returns an object that wraps the number\n     * instance, allowing it to be treated as an object. The returned object\n     * is created using the `Object()` constructor, which takes the number\n     * instance as its argument.\n     *\n     * @type {Object}\n     * @readonly\n     *\n     * @example\n     * const num = 42\n     * console.log(typeof num)           // 'number'\n     * console.log(typeof num.instance)  // 'object'\n     */\n    get instance() {\n      return Object(this)\n    },\n\n    /**\n     * Determines if the current object is a number\n     *\n     * This getter uses the `pIsNumber` function from the `NumberExtensions`\n     * patch to check if the current object (`this`) is a number.\n     *\n     * @type {boolean}\n     * @readonly\n     *\n     * @example\n     * const num = 42\n     * console.log(num.isNumber) // Output: true\n     *\n     * const notNum = \"123\"\n     * console.log(notNum.isNumber) // Output: false\n     */\n    get isNumber() {\n      return pIsNumber(this)\n    },\n\n    /**\n     * Checks if the current object is a number and returns the corresponding\n     * value based on the result.\n     *\n     * This method uses the `pIfNumber` function from the `NumberExtensions`\n     * patch to determine if the current object (`this`) is a number. If it is\n     * a number, the `thenValue` is returned. Otherwise, the `elseValue` is\n     * returned.\n     *\n     * @param {any} thenValue The value to return if the current object is\n     * a number\n     * @param {any} elseValue The value to return if the current object is not\n     * a number\n     * @returns {any} The `thenValue` if the current object is a number, or\n     * the `elseValue` if it is not a number\n     *\n     * @example\n     * const num = 42\n     * console.log(num.ifNumber('Is a number', 'Not a number'))\n     * // Output: 'Is a number'\n     *\n     * const notNum = '123'\n     * console.log(notNum.ifNumber('Is a number', 'Not a number'))\n     * // Output: 'Not a number'\n     */\n    ifNumber(thenValue, elseValue) {\n      return pIfNumber(this, thenValue, elseValue)\n    },\n  }\n})\n\n// NOTE to self; this is repeated here otherwise a circular reference from\n// Object<->Function<->Global occurs. See original source in global.this.js\n// {@see globalThis.isThenElse}\nfunction isThenElse(bv, tv, ev) {\n  if (arguments.length > 1) {\n    var _then = isFunction(tv) ? tv(bv) : tv; if (arguments.length > 2) {\n      var _else = isFunction(ev) ? tv(bv) : ev; return bv ? _then : _else\n    } return bv || _then;\n  } return bv\n}", "import { Extension } from '@nejs/extension'\n\n/**\n * Represents a secure container for storing and retrieving unique symbols\n * associated with data. This class provides methods to add new symbols to\n * the Symkeys and to retrieve data associated with a particular symbol.\n *\n * @example\n* // Create a new Symkeys instance\n* const symkeys = new Symkeys();\n*\n* // Add a symbol with associated data to the Symkeys\n* const mySymbol = Symkeys.add('myIdentifier', { foo: 'bar' });\n*\n* // Retrieve the data using the symbol\n* const myData = Symkeys.dataFor(mySymbol);\n* console.log(myData); // Output: { foo: 'bar' }\n*/\nexport class Symkeys {\n  /**\n   * Adds a new entry to the Symkeys with a unique symbol based on the provided\n   * name and associates it with the given data.\n   *\n   * @param named - The base name for the symbol to be created.\n   * @param [associatedData={}] - The data to associate with the symbol.\n   * @returns The unique symbol created for the entry.\n   *\n   * @example\n   * // Add an entry with associated data\n   * const symbol = Symkeys.add('myEntry', { foo: 'bar' });\n   * // Retrieve the associated data using the symbol\n   * const data = Symkeys.dataFor(symbol);\n   * console.log(data); // Output: { foo: 'bar' }\n   */\n  add(named, associatedData = {}) {\n    // Generate a unique token for the symbol\n    const token = Symkeys.token;\n\n    // Calculate a name (optionally with domain and separator)\n    const symName = this.calculateName(named)\n\n    // Create a symbol using the provided name and the unique token\n    const symbol = Symbol.for(`@${symName} #${token}`);\n\n    // Store the symbol and associated data in the Symkeys's internal map\n    this[Symkeys.kDataKey].set(symbol, associatedData);\n\n    // Return the unique symbol for external use\n    return symbol;\n  }\n\n  /**\n   * Retrieves the data associated with a given symbol from the Symkeys.\n   *\n   * This method allows access to the data that has been associated with a\n   * particular symbol in the Symkeys. It is useful for retrieving stored\n   * information when only the symbol is known.\n   *\n   * @param symbol - The symbol whose associated data is to be\n   * retrieved.\n   * @returns The data associated with the symbol, or undefined if\n   *                   the symbol is not found in the Symkeys.\n   *\n   * @example\n   * // Assuming 'mySymbol' is a symbol that has been added to the Symkeys\n   * // with associated data\n   * const data = Symkeys.dataFor(mySymbol);\n   * console.log(data); // Output: The data associated with 'mySymbol'\n   */\n  data(forSymbol) {\n    return this[Symkeys.kDataKey].get(forSymbol)\n  }\n\n  /**\n   * Deletes the data associated with a given symbol from the Symkeys.\n   *\n   * This method allows removal of the data that has been associated with a\n   * particular symbol in the Symkeys. It is useful when you want to clean up\n   * or remove stored information associated with a symbol.\n   *\n   * @param {Symbol} forSymbol - The symbol whose associated data is to be\n   * deleted.\n   * @param {*} replaceWith - Optionally, if `replaceWith` is not `undefined`,\n   * a new value can be set after the original is deleted\n   * @returns {boolean} - Returns true if an element in the Symkeys existed and\n   * has been removed, or false if the element does not exist\n   *\n   * @example\n   * // Assuming 'mySymbol' is a symbol that has been added to the Symkeys\n   * // with associated data\n   * const isDeleted = Symkeys.deleteData(mySymbol);\n   * console.log(isDeleted); // Output: true if data was deleted, false otherwise\n   */\n  deleteData(forSymbol, replaceWith = undefined) {\n    if (this.hasData(forSymbol)) {\n      const result = this[Symkeys.kDataKey].delete(forSymbol)\n\n      if (replaceWith !== undefined) {\n        this[Symkeys.kDataKey].set(forSymbol, replaceWith)\n      }\n\n      return result\n    }\n\n    return false\n  }\n\n  /**\n   * Checks if the Symkeys instance has data associated with a given symbol.\n   *\n   * This method checks if the Symkeys instance has any data associated with\n   * the provided symbol. It is useful when you need to verify if data exists\n   * for a particular symbol before attempting to retrieve or manipulate it.\n   *\n   * @param {Symbol} forSymbol - The symbol to check for associated data.\n   * @returns {boolean} Returns true if data exists for the symbol, false otherwise.\n   *\n   * @example\n   * // Assuming 'mySymbol' is a symbol that has been added to the Symkeys\n   * // with associated data\n   * const hasData = Symkeys.hasData(mySymbol);\n   * console.log(hasData); // Output: true if data exists, false otherwise\n   */\n  hasData(forSymbol) {\n    return this[Symkeys.kDataKey].has(forSymbol)\n  }\n\n  /**\n   * Sets the data associated with a given symbol in the Symkeys.\n   *\n   * This method allows you to associate data with a particular symbol in the\n   * Symkeys. It is useful when you want to store information that can be\n   * retrieved later using the symbol.\n   *\n   * Note that setting only succeeds if the Symkey symbol has already been\n   * added via {@link Symkeys.add}\n   *\n   * @param {Symbol} forSymbol - The symbol with which the data is to be\n   * associated.\n   * @param {*} value - The data to be associated with the symbol.\n   * @returns {boolean} true if the value has been set, false if the key\n   * has not yet been added via {@link Symkeys.add}\n   *\n   * @example\n   * // Assuming 'mySymbol' is a symbol that has been added to the Symkeys\n   * // and 'myData' is the data to be associated with 'mySymbol'\n   * Symkeys.setData(mySymbol, myData);\n   */\n  setData(forSymbol, value) {\n    if (this.hasData(forSymbol)) {\n      this[Symkeys.kDataKey].set(forSymbol, value)\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Extracts the token part from a symbol created by the `add` method.\n   *\n   * This method parses the string representation of a symbol to retrieve\n   * the unique token that was appended to the symbol's name upon creation.\n   * It is useful for debugging or for operations that require knowledge of\n   * the token associated with a symbol.\n   *\n   * @param symbol - The symbol whose token is to be extracted.\n   * @returns The extracted token or undefined if the\n   * token cannot be extracted.\n   *\n   * @example\n   * // Assuming 'mySymbol' is a symbol created with the name 'myEntry'\n   * // and a token 'agftofxob6f'\n   * const token = Symkeys.tokenFor(mySymbol);\n   * console.log(token); // Output: 'agftofxob6f'\n   */\n  token(forSymbol) {\n    // Use a regular expression to match the token pattern in the symbol\n    // description exists on symbol but our JS output target is too old\n    return /^.* \\#(.*?)$/.exec(forSymbol)?.description?.[1];\n  }\n\n  /**\n   * Retrieves the separator used in the Symkeys instance.\n   *\n   * This getter method allows access to the separator that is used to\n   * distinguish between different parts of a symbol in the Symkeys instance.\n   * It is useful when you need to know the separator for parsing symbols or\n   * constructing new ones.\n   *\n   * @returns {string} The separator used in the Symkeys instance.\n   *\n   * @example\n   * // Assuming the Symkeys instance has a separator '.'\n   * const separator = Symkeys.separator;\n   * console.log(separator); // Output: '.'\n   */\n  get separator() {\n    return this[kSeparator]\n  }\n\n  /**\n   * Retrieves an iterator for the symbols stored in the Symkeys.\n   *\n   * This method provides access to the symbols that have been stored in\n   * the Symkeys. It returns an iterator which can be used to loop over\n   * all the symbols. This is particularly useful for iterating through\n   * all stored data without knowing the individual symbols in advance.\n   *\n   * @returns An iterator that yields all the symbols\n   * stored in the Symkeys.\n   *\n   * @example\n   * // Assuming the Symkeys has symbols stored\n   * for (const symbol of Symkeys.symbols()) {\n   *   console.log(symbol);\n   * }\n   */\n  symbols() {\n    // Retrieve the keys (symbols) from the Symkeys data map and return\n    // the iterator.\n    return this[Symkeys.kDataKey].keys();\n  }\n\n  /**\n   * Calculates a name by combining a provided name, domain, and separator.\n   *\n   * This method takes a provided name, domain, and separator as input and\n   * constructs a new name by combining these elements. If the domain or\n   * separator are not provided, it uses the default domain and separator\n   * stored in the Symkeys instance. If the provided name starts with the\n   * separator, it removes the leading separator from the name.\n   *\n   * If the domain ends with the separator, it removes the trailing separator\n   * from the domain. If the domain is empty, it sets the separator to an\n   * empty string.\n   *\n   * @param {string} providedName - The name to be used in the calculation.\n   * @param {string} [useDomain] - The domain to be used in the calculation.\n   * If not provided, the default domain of the Symkeys instance is used.\n   * @param {string} [useSeparator] - The separator to be used in the\n   * calculation. If not provided, the default separator of the Symkeys\n   * instance is used.\n   * @returns {string} The calculated name.\n   *\n   * @example\n   * // Assuming the Symkeys instance has a domain 'symkeys.internal'\n   * // and a separator '.'\n   * const name = Symkeys.calculateName('feature', 'symkeys.public', '/');\n   * console.log(name); // Output: 'symkeys.public/feature'\n   */\n  calculateName(providedName, useDomain, useSeparator) {\n    let domain = String(useDomain || this[Symkeys.kDomain])\n    let separator = String(useSeparator || this[Symkeys.kSeparator])\n    let postfix = (String(providedName).startsWith(separator)\n      ? providedName.substring(1)\n      : providedName\n    )\n\n    if (domain.length) {\n      if (domain.endsWith(separator)) {\n        domain = domain.substring(0, domain.length - 1)\n      }\n    }\n    else {\n      separator = ''\n    }\n\n    return `${domain}${separator}${postfix}`\n  }\n\n  /**\n   * Constructs a new instance of the Symkeys, setting up a proxy to\n   * intercept and manage access to properties.\n   *\n   * This constructor initializes the Symkeys with a proxy that\n   * overrides the default behavior for property access, checking, and\n   * enumeration. It allows the Symkeys to behave like a map for its\n   * own properties, while also maintaining the prototype chain.\n   *\n   * @param {string} domain an optional prefix string, to which the\n   * `separator` parameter value will be guaranteed to have in between\n   * the domain (if truthy) and the name of the added key.\n   * @param {string} separator defaults to a period. So if your domain\n   * is 'symkeys.internal' then calling {@link add()} with a name of\n   * `\"feature\"` will result in the full name being\n   * `\"symkeys.internal.feature\"`\n   *\n   * @example\n   * const Symkeys = new Symkeys();\n   * Symkeys[Symbol.for('myProperty')] = 'myValue';\n   * console.log(Symkeys[Symbol.for('myProperty')]); // 'myValue'\n   */\n  constructor(domain = '', separator = '.') {\n    // Create a prototype from the parent class to maintain the chain.\n    const prototype = Object.create(Object.getPrototypeOf(this))\n\n    // Store the original prototype for potential future use.\n    this[Symkeys.kPrototype] = prototype\n\n    // Create map for this instance\n    this[Symkeys.kDataKey] = new Map()\n\n    // Store the domain\n    this[Symkeys.kDomain] = (typeof domain === 'string' && domain)\n\n    // Store the separator\n    this[Symkeys.kSeparator] = separator\n\n    // Access the internal map that stores Symkeys data.\n    const map = this[Symkeys.kDataKey];\n\n    // Replace the instance's prototype with a proxy that manages\n    // property access and manipulation.\n    Object.setPrototypeOf(\n      this,\n      new Proxy(Object.create(prototype), {\n        // Return the stored prototype for the target.\n        getPrototypeOf(_) {\n          return prototype;\n        },\n\n        // Intercept property access.\n        get(target, property, receiver) {\n          // If the property exists in the Symkeys map, return its value.\n          if (map.has(property)) {\n            return map.get(property);\n          }\n          // Otherwise, perform the default behavior.\n          return Reflect.get(target, property, receiver);\n        },\n\n        // Check for property existence. Check both the Symkeys map and the target for\n        // the property.\n        has(target, property) {\n          return map.has(property) || Reflect.has(target, property);\n        },\n\n        // Retrieve all property keys. Combine keys from the Symkeys map and the target.\n        ownKeys(target) {\n          return [...Array.from(map.keys()), ...Reflect.ownKeys(target)];\n        },\n\n        // Intercept property assignment.\n        set(_, property, value, __) {\n          // If the property exists in the Symkeys map, set its value.\n          if (map.has(property)) {\n            map.set(property, value);\n            return true;\n          }\n          // If not, the operation is not allowed.\n          return false;\n        },\n\n        // Retrieve property descriptors.\n        getOwnPropertyDescriptor(_, property) {\n          // Convert the Symkeys map to an object to use with\n          // Object.getOwnPropertyDescriptor.\n          const object = [...map.entries()].reduce(\n            (a, e) => Object.assign(a, { [e[0]]: e[1] }),\n            {},\n          );\n          // Retrieve the descriptor from the object.\n          return Object.getOwnPropertyDescriptor(object, property);\n        },\n      }),\n    );\n  }\n\n  /**\n   * Checks if a given value is a Symkey.\n   *\n   * This method checks if the provided value is a Symkey. A Symkey is a\n   * symbol that matches a specific pattern. The pattern is defined as a\n   * symbol that starts with '@', followed by any characters, a space, a '#',\n   * and ends with one or more word characters.\n   *\n   * @param {Symbol} value - The value to check.\n   * @returns {boolean} Returns true if the value is a Symkey, false otherwise.\n   *\n   * @example\n   * // Check if a symbol is a Symkey:\n   * const sym = Symbol('@nejs.prototype #rwiy2o905d');\n   * console.log(Symkeys.isSymkey(sym)); // Outputs: true\n   */\n  static isSymkey(value) {\n    if (!(typeof value === 'symbol' || value instanceof Symbol)) {\n      return false\n    }\n\n    return !!/^@.*? #\\w+$/.exec(value?.description)\n  }\n\n  /**\n   * Generates a random token string.\n   *\n   * This method creates a pseudo-random token that can be used for various\n   * purposes within the library, such as generating unique identifiers or\n   * keys. The token is generated using a base 36 encoding, which includes\n   * numbers and lowercase letters.\n   *\n   * @returns A random token string.\n   *\n   * @example\n   * // Example of getting a random token:\n   * const token = MyClass.token;\n   * console.log(token); // Outputs a string like 'qg6k1zr0is'\n   */\n  static get token() {\n    return Math.random().toString(36).slice(2);\n  }\n\n  /**\n   * Reusable publicly static key for identifying where data is stored.\n   */\n  static get kDataKey() {\n    return Symbol.for('symkeys.data');\n  }\n\n  /**\n   * Reusable publicly static key for identifying where data is stored.\n   */\n  static get kPrototype() {\n    return Symbol.for('symkeys.prototype')\n  }\n\n  /**\n   * A static getter that returns a unique, reusable symbol for 'symkeys.domain'.\n   *\n   * This getter is used to create a unique symbol that can be used as a key\n   * for storing and retrieving domain-specific data in the Symkeys. The symbol\n   * is created using the `Symbol.for` method, which ensures that the same\n   * symbol is returned for a given key, in this case 'symkeys.domain'.\n   *\n   * @returns {Symbol} A unique symbol for 'symkeys.domain'.\n   *\n   * @example\n   * // Retrieve the 'symkeys.domain' symbol\n   * const domainSymbol = Symkeys.kDomain;\n   * console.log(domainSymbol); // Outputs: Symbol(symkeys.domain)\n   */\n  static get kDomain() {\n    return Symbol.for('symkeys.domain')\n  }\n\n  /**\n   * A static getter that returns a unique, reusable symbol for 'symkeys.separator'.\n   *\n   * This getter is used to create a unique symbol that can be used as a key\n   * for storing and retrieving separator-specific data in the Symkeys. The symbol\n   * is created using the `Symbol.for` method, which ensures that the same\n   * symbol is returned for a given key, in this case 'symkeys.separator'.\n   *\n   * @returns {Symbol} A unique symbol for 'symkeys.separator'.\n   *\n   * @example\n   * // Retrieve the 'symkeys.separator' symbol\n   * const separatorSymbol = Symkeys.kSeparator;\n   * console.log(separatorSymbol); // Outputs: Symbol(symkeys.separator)\n   */\n  static get kSeparator() {\n    return Symbol.for('symkeys.separator')\n  }\n}\n\nexport const SymkeysExtension = new Extension(Symkeys)", "import { Patch, PatchToggle } from '@nejs/extension';\n\nimport { Symkeys } from './classes/symkeys.js'\nimport { JSONExtensions } from './json.extensions.js'\n\nconst JSONToggle = new PatchToggle(JSONExtensions)\n\n/**\n * `SymbolExtensions` is a patch for the JavaScript built-in `Symbol` class. It\n * adds utility methods to the `Symbol` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `Symbol` class with additional\n * utility functions.\n */\nexport const SymbolExtensions = new Patch(Symbol, {\n  add(named, associatedData = {}) {\n    return this.keys.add(named, associatedData)\n  },\n\n  deleteData(forSymbol, replaceWith = undefined) {\n    return this.keys.deleteData(forSymbol, replaceWith)\n  },\n\n  hasData(forSymbol) {\n    return this.keys.hasData(forSymbol)\n  },\n\n  /**\n   * The `isSymbol` method does exactly what one would it expect. It returns\n   * true if the string matches typeof or instanceof as a symbol.\n   *\n   * @param {*} value checks to see if the `value` is a string\n   * @returns {boolean} `true` if it is a `Symbol`, `false` otherwise\n   */\n  isSymbol(value) {\n    return value && (typeof value === 'symbol');\n  },\n\n  /**\n   * Returns true if the supplied value is a Symbol created using\n   * `Symbol.for()`.\n   *\n   * @param {any} value assumption is that the supplied value is of type\n   * 'symbol' however, unless `allowOnlySymbols` is set to `true`, `false`\n   * will be returned for any non-symbol values.\n   * @param {boolean} allowOnlySymbols true if an error should be thrown\n   * if the supplied value is not of type 'symbol'\n   * @returns true if the symbol is registered, meaning, none of the spec\n   * static symbols (`toStringTag`, `iterator`, etc...), and no symbols\n   * created by passing a value directly to the Symbol function, such as\n   * `Symbol('name')`\n   */\n  isRegistered(value, allowOnlySymbols = false) {\n    if (!Symbol.isSymbol(value)) {\n      if (allowOnlySymbols) {\n        throw new TypeError('allowOnlySymbols specified; value is not a symbol')\n      }\n      return false\n    }\n\n    return Symbol.keyFor(value) !== undefined\n  },\n\n  /**\n   * A function that returns true if the symbol is not registered, meaning,\n   * any of the spec static symbols (`toStringTag`, `iterator`, etc...), and\n   * any symbols created by passing a value directly to the `Symbol` function,\n   * such as `Symbol('name')`.\n   *\n   * @param {any} value assumption is that the supplied value is of type\n   * 'symbol' however, unless allowOnlySymbols is set to true, false will\n   * be returned for any non-symbol values.\n   * @param {boolean} allowOnlySymbols true if an error should be thrown\n   * if the supplied value is not of type 'symbol'\n   * @returns true if the symbol is not registered, meaning, any of the\n   * spec static symbols (`toStringTag`, `iterator`, etc...), and any symbols\n   * created by passing a value directly to the `Symbol` function, such as\n   * `Symbol('name')`\n   * @returns true if the `value` in question is both a `symbol` and has\n   * returns `undefined` if passed to `Symbol.keyFor`\n   */\n  isNonRegistered(value, allowOnlySymbols = false) {\n    return !Symbol.isRegistered(value, allowOnlySymbols)\n  },\n\n  /**\n   * `keys` is an instance of the `Symkeys` class, initialized with the\n   * domain 'nejs'. The `Symkeys` class provides a way to easily generate\n   * Symbol.for elements that follow particular pattern. Symkeys also\n   * allows associated data storage with each generated key.\n   *\n   * @type {Symkeys}\n   * @see {@link SymKeys}\n   * @example\n   * // Returns something like Symbol.for('@nejs.prototype #rwiy2o905d')\n   * const kOriginal = Symbol.keys.add('prototypes')\n   *\n   * // Which can be used to retrieve and fetch data associated with that key\n   * // The value stored is an array by default, but can be anything. It can\n   * // be accessed one property at a time\n   * Symbol.keys[kOriginal].original = Object.prototype\n   * Symbol.keys[kOriginal].modified = Object.create(Object.prototype, ...)\n   *\n   * // Or wholesale replaced\n   * Symbol.keys[kOriginal] = [Object.prototype, Array.prototype]\n   *\n   * // But if all Symbol Extensions are in place, including prototype add-ons\n   * kOriginal.data.original = Object.prototype           // ...and...\n   * kOriginal.data = [Object.prototype, Array.prototype] // ...both work\n   */\n  keys: new Symkeys('nejs'),\n\n  setData(forSymbol, value) {\n    this.keys.setData(forSymbol, value)\n  },\n\n  /**\n   * Creates a new Symbol with the given name and optional data. If data\n   * is provided, it will be stringified and appended to the symbol's\n   * name. This method is useful for creating unique symbols that carry\n   * additional metadata.\n   *\n   * @param {string} name The name of the symbol.\n   * @param {*} [data] Optional data to be associated with the symbol.\n   * @returns {symbol} A new symbol created with Symbol.for(), using the\n   * provided name and stringified data (if provided).\n   *\n   * @example\n   * const symbolWithData = Symbol.withData('mySymbol', { foo: 'bar' })\n   * console.log(symbolWithData.toString())\n   * // Output: \"Symbol(mySymbol {\"foo\":\"bar\"})\"\n   *\n   * @example\n   * const symbolWithoutData = Symbol.withData('mySymbol')\n   * console.log(symbolWithoutData.toString())\n   * // Output: \"Symbol(mySymbol)\"\n   */\n  withData(name, data) {\n    return data !== undefined\n      ? Symbol.for(`${name} ${JSON.stringify(data)}`)\n      : Symbol.for(name)\n  },\n});\n\nexport const SymbolPrototypeExtensions = new Patch(Symbol.prototype, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Returns an object representation of the symbol instance.\n     *\n     * This getter method creates and returns an object that wraps the\n     * symbol instance, allowing it to be treated as an object. The\n     * returned object is created using the `Object()` constructor,\n     * which takes the symbol instance as its argument.\n     *\n     * @type {Object}\n     * @readonly\n     *\n     * @example\n     * const sym = Symbol('example')\n     * console.log(typeof sym)        // 'symbol'\n     * console.log(typeof sym.instance) // 'object'\n     */\n    get instance() {\n      return Object(this)\n    },\n\n    /**\n     * Getter method for retrieving the data associated with a symbol.\n     *\n     * This method first checks if the symbol is a Symkey created symbol\n     * by checking the existence of Symbol.keys and if the symbol's\n     * description matches the Symkey pattern. If it is a Symkey symbol,\n     * it attempts to fetch its associated data.\n     *\n     * NOTE: Symkey data is returned as its value directly, this is because\n     * it is stored in a {@link Map}. Embedded JSON data might be expensive\n     * to parse and as such a function is returned when data is accessed that\n     * needs to be invoked in order to decode its contents. See\n     * `{@link mightHaveEmbeddedJSON}` for more information.\n     *\n     * If the symbol is not a Symkey symbol or if no data is associated\n     * with it, the method attempts to parse the symbol's description as\n     * JSON and returns the first valid JSON object found.\n     *\n     * If no valid JSON object is found in the description, the method\n     * returns undefined.\n     *\n     * @type {Object|Function}\n     * @readonly\n     *\n     * @example\n     * const keys = new Symkeys\n     * const key = keys.add('example', {count: 0})\n     * const data = key.data // note this isn't function!!\n     * const count = data.count\n     *\n     * @example\n     * const sym = Symbol.for('fun {\"name\":\"Brie\"}')\n     * let json = sym.data() // {name: 'Brie'} JS object\n     *\n     * @example\n     * const sym = Symbol('mySymbol')\n     * let data = sym.data() // undefined\n     */\n    get data() {\n      if (Symbol?.keys && Symkeys.isSymkey(this)) {\n        const possibleData = Symbol.keys[this]\n        if (possibleData) {\n          return possibleData\n        }\n      }\n\n      let result = undefined;\n      let revertToggle = false\n      if (!JSONExtensions.applied) {\n        JSONToggle.start()\n        revertToggle = true\n      }\n\n      if (JSON.mightContain(this.description)) {\n        try { result = JSON.extractFrom(this.description) }\n        catch (ignore) { }\n      }\n\n      if (revertToggle) {\n        JSONToggle.stop()\n      }\n\n      return result\n    },\n\n    /**\n     * Sets the data associated with a symbol.\n     *\n     * This setter method checks if the symbol is a Symkey and if it has\n     * associated data. If both conditions are met, it sets the data of the\n     * symbol to the provided value and returns true. If the conditions are\n     * not met, it simply returns false.\n     *\n     * While Symbols have been upgraded to also support embedded JSON data\n     * with this extension, symbol descriptions are static. Non Symkey symbols\n     * do not associated their data outside of a symbol, and cannot be changed,\n     * there new data cannot be set on them.\n     *\n     * @param {any} value - The value to be set as the symbol's data.\n     * @returns {boolean} - Returns true if the data was successfully set,\n     * false otherwise.\n     *\n     * @example\n     * const sym = Symbol.for('fun {\"name\":\"Brie\"}')\n     * Symkeys.isSymkey(sym) // false; not in Symkey format\n     * let json = sym.data() // {name: 'Brie'} JS object\n     * sym.data = JSON.stringify({name: 'Jane'}) // fails silently\n     * json = sym.data() // {name: 'Brie'} is hard-coded in description\n     *\n     * @example\n     * const sym = Symbol('mySymbol')\n     * Symkeys.isSymkey(sym) // false; not in Symkey format\n     * Symkeys.hasData(sym) // false\n     * sym.data = { name: 'John', age: 30 } // will fail silently\n     * Symkeys.hasData(sym) // still false\n     *\n     * // Now let's create a Symkey with data\n     * const symWithData = Symkeys.create('mySymbolWithData',\n     *                                    { name: 'Jane', age: 25 })\n     * Symkeys.isSymkey(symWithData) // true\n     * Symkeys.hasData(symWithData) // true\n     * symWithData.data = { name: 'Jane', age: 26 } // will succeed\n     * Symkeys.getData(symWithData) // returns { name: 'Jane', age: 26 }\n     */\n    set data(value) {\n      if (Symkeys.isSymkey(this) && Symkeys.hasData(this)) {\n        Symbol.keys.setData(this, value)\n      }\n    },\n\n    /**\n     * Checks if the symbol might have embedded JSON data.\n     *\n     * This getter method checks if the symbol's description might contain\n     * JSON data and if the data property of the symbol is a function. If both\n     * conditions are met, it returns true, otherwise it returns false.\n     *\n     * @returns {boolean} - Returns true if the symbol might have embedded\n     * JSON, false otherwise.\n     *\n     * @example\n     * const sym = Symbol.for('fun {\"name\":\"Brie\"}')\n     * console.log(sym.mightHaveEmbeddedJSON) // Output: true\n     *\n     * @example\n     * const sym = Symbol('mySymbol')\n     * console.log(sym.mightHaveEmbeddedJSON) // Output: false\n     */\n    get mightHaveEmbeddedJSON() {\n      return mightContain(this.description)\n    },\n\n    get sgrString() {\n      let revert = false\n      let detail = undefined\n\n      let { sgr } = String\n      if (!sgr) { sgr = (string, ...args) => string }\n\n      if (!JSONExtensions.applied) { JSONToggle.start(); revert = true }\n      if ((detail = JSON.mightContain(this.description, true))) {\n        let jsonText = detail[2][0]\n        let index = detail[1]\n\n        if (~index && jsonText && jsonText.length > 30) {\n          let desc = this.description\n          let newDescription = [\n            sgr(`Symbol.for(${desc.slice(0, index)}`, 'green'),\n            sgr(jsonText.slice(0, 10), 'di'),\n            '...',\n            sgr(jsonText.slice(-5), 'di'),\n            sgr(`${desc.slice(index + jsonText.length + 1)})`, 'green'),\n          ].join('')\n\n          if (revert) { JSONToggle.stop() }\n          return `${newDescription}`\n        }\n      }\n\n      if (revert) { JSONToggle.stop() }\n\n      return newDescription\n    },\n\n    /**\n     * Custom inspect method for Node.js util.inspect.\n     *\n     * NOTE: this will only apply if looking at an instance of Symbol,\n     * sadly; {@see SymbolPrototypeExtensions.instance}\n     *\n     * This method is used by Node.js util.inspect to provide a custom\n     * representation of the symbol when inspected. It checks if the\n     * symbol's description might contain JSON data and if so, it\n     * truncates the JSON data in the description to a maximum of 30\n     * characters and formats the output with colors using the `sgr`\n     * function from the `String` object.\n     *\n     * @param {number} depth - The current depth of the recursive\n     * inspection.\n     * @param {Object} options - The options object passed to\n     * util.inspect.\n     * @param {Function} inspect - The original util.inspect function.\n     *\n     * @returns {string} - The formatted representation of the symbol.\n     *\n     * @example\n     * const sym = Symbol.for('fun {\"name\":\"John Doe\"}')\n     * console.log(util.inspect(sym))\n     * // Output: Symbol.for(fun {\"name\":\"John ...hn Doe\"})\n     */\n    [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n      let revert = false\n      let detail = undefined\n\n      let { sgr } = String\n      if (!sgr) { sgr = (string, ...args) => string }\n\n      if (!JSONExtensions.applied) { JSONToggle.start(); revert = true }\n      if ((detail = JSON.mightContain(this.description, true))) {\n        let jsonText = detail[2][0]\n        let index = detail[1]\n\n        if (~index && jsonText && jsonText.length > 30) {\n          let desc = this.description\n          let newDescription = [\n            sgr(`Symbol.for(${desc.slice(0, index)}`, 'green'),\n            sgr(jsonText.slice(0, 10), 'di'),\n            '...',\n            sgr(jsonText.slice(-5), 'di'),\n            sgr(`${desc.slice(index + jsonText.length + 1)})`, 'green'),\n          ].join('')\n\n          if (revert) { JSONToggle.stop() }\n          return `${newDescription}`\n        }\n      }\n\n      if (revert) { JSONToggle.stop() }\n      return inspect(this, { colors: true })\n    },\n  },\n})\n", "import { Extension } from '@nejs/extension'\n\nexport class Descriptor {\n  /**\n   * The default private descriptor value is that of `enigmatic`\n   *\n   * @private\n   * @type {object}\n   */\n  #desc = undefined\n\n  /**\n   * An optionally associated object, usually the parent from which\n   * the descriptor was taken, or undefined if none was able to be\n   * derived.\n   *\n   * @type {object}\n   */\n  #object = undefined\n\n  /**\n   * Constructs a Descriptor instance which wraps and manages an object\n   * property descriptor. The constructor can handle an existing descriptor\n   * object or create a new one based on an object and a property key.\n   *\n   * @param {object|Descriptor} object - The target object or an existing\n   * Descriptor instance. If it's an object, it is used in conjunction with\n   * `key` to create a descriptor. If it's a Descriptor instance, it is used\n   * directly as the descriptor.\n   * @param {string|symbol} [key] - The property key for which the descriptor\n   * is to be created. This parameter is ignored if `object` is a Descriptor\n   * instance. If `key` is an object and `object` is a valid descriptor, `key`\n   * is treated as the associated object.\n   * @throws {Error} Throws an error if the constructed descriptor is not\n   * valid.\n   */\n  constructor(object, key) {\n    if ((object ?? key) === undefined) {\n      this.#desc = Descriptor.enigmatic\n    }\n    else if (Descriptor.isDescriptor(object)) {\n      this.#desc = object\n      this.#object = isObject(key) ? key : undefined\n    }\n    else if (isObject(object) && isValidKey(key)) {\n      this.#desc = Object.getOwnPropertyDescriptor(object, key)\n      this.#object = object\n    }\n\n    if (!this.isDescriptor) {\n      console.error(`\n      Descriptor(object,key) FAILED:\n        object:      ${object === globalThis ? '[GLOBAL]' : (typeof key === 'object' ? JSON.stringify(object) : String(object))}\n        key:         ${key === globalThis ? '[GLOBAL]' : (typeof key === 'object' ? JSON.stringify(key) : String(key))}\n        descriptor:  `, this.#desc\n      )\n      throw new Error(`Not a valid descriptor:`, this.#desc)\n    }\n  }\n\n  /**\n   * Detects whether or not this instance is an accessor object descriptor\n   *\n   * @returns {boolean} true if this object has a getter or setter and is not\n   * a data descriptor\n   */\n  get isAccessor() {\n    return Descriptor.isAccessor(this.#desc)\n  }\n\n  /**\n   * Detects whether or not this instance is an data object descriptor\n   *\n   * @returns {boolean} true if this object has a value property and is not\n   * an accessor descriptor\n   */\n  get isData() {\n    return Descriptor.isData(this.#desc)\n  }\n\n  /**\n   * Detects whether or not this instance is a valid object descriptor\n   *\n   * @returns {boolean} true if this descriptor store is a valid descriptor\n   */\n  get isDescriptor() {\n    return Descriptor.isDescriptor(this.#desc)\n  }\n\n  /**\n   * Getter around the `configurable` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {boolean} a boolean value or undefined if the internal\n   * descriptor store is invalid.\n   */\n  get configurable() {\n    return !!this.#desc?.configurable\n  }\n\n  /**\n   * Sets the `configurable` value of this object. If the internal descriptor\n   * store store is invalid, the value is thrown away\n   *\n   * @param {boolean} value the value to set for the `configurable` descriptor\n   * property. If this value is not a `boolean` it will be converted to one\n   */\n  set configurable(value) {\n    (this.#desc || {}).configurable = !!value\n  }\n\n  /**\n   * Getter around the `enumerable` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {boolean} a boolean value or undefined if the internal\n   * descriptor store is invalid.\n   */\n  get enumerable() {\n    return this.#desc?.enumerable\n  }\n\n  /**\n   * Sets the `enumerable` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {boolean} value the value to set for the `enumerable` descriptor\n   * property. If this value is not a `boolean` it will be converted to one\n   */\n  set enumerable(value) {\n    (this.#desc || {}).enumerable = value\n  }\n\n  /**\n   * Getter around the `writable` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {boolean} a boolean value or undefined if the internal\n   * descriptor store is invalid.\n   */\n  get writable() {\n    return this.#desc?.writable\n  }\n\n  /**\n   * Sets the `writable` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {boolean} value the value to set for the `writable` descriptor\n   * property. If this value is not a `boolean` it will be converted to one\n   */\n  set writable(value) {\n    (this.#desc || {}).writable = value\n  }\n\n  /**\n   * Getter around the `value` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {any} any value stored in this descriptor\n   */\n  get value() {\n    return this.#desc?.value\n  }\n\n  /**\n   * Sets the `value` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {any} value the value to set for the `value` descriptor\n   * property.\n   */\n  set value(value) {\n    (this.#desc || {}).value = value\n  }\n\n  /**\n   * Getter around the `get` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {function} a function if the getter for this descriptor is\n   * defined or `undefined` if the internal descriptor object or the getter\n   * is undefined.\n   */\n  get get() {\n    return this.#desc?.get\n  }\n\n  /**\n   * Retrieves the {@link get} function for this accessor and binds it to\n   * the object from which the descriptor was derived, if that value is set.\n   * Otherwise this method is identical to the {@link get} accessor.\n   *\n   * @returns {function} the getter if one is defined. If possible this\n   * getter will be bound the associated and previously set `object`.\n   */\n  get boundGet() {\n    return (isObject(this.#object) ? this.get?.bind(this.#object) : this.get)\n  }\n\n  /**\n   * Sets the `get` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {function} value the getter function for this descriptor\n   */\n  set get(value) {\n    (this.#desc || {}).get = value\n  }\n\n  /**\n   * Getter around the `set` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {function} a function if the setter for this descriptor is\n   * defined or `undefined` if the internal descriptor object or the setter\n   * is undefined.\n   */\n  get set() {\n    return (this.#desc || {}).set\n  }\n\n  /**\n   * Retrieves the {@link set} function for this accessor and binds it to\n   * the object from which the descriptor was derived, if that value is set.\n   * Otherwise this method is identical to the {@link set} accessor.\n   *\n   * @returns {function} the setter if one is defined. If possible this\n   * setter will be bound the associated and previously set `object`.\n   */\n  get boundSet() {\n    return (isObject(this.#object) ? this.set?.bind(this.#object) : this.set)\n  }\n\n  /**\n   * Sets the `set` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {function} value the setter function for this descriptor\n   */\n  set set(value) {\n    (this.#desc || {}).set = value\n  }\n\n  /**\n   * The function checks the descriptor's associated object has been set on this\n   * instance of `Descriptor`.\n   *\n   * @returns {boolean} `true` if the `object` property has been set,\n   * `false` otherwise\n   */\n  get hasObject() { return isObject(this.#object) }\n\n  /**\n   * Returns the descriptor's associated `object` value. This is usually the\n   * parent object from which the descriptor was derived. If the value is preset\n   * it will be returned. Undefined will be returned otherwise\n   *\n   * @returns {object} the associated object for this descriptor or undefined\n   * if it has not yet been set.\n   */\n  get object() { return this.#object }\n\n  /**\n   * Sets the descriptor's associated `object` value. This is usually the\n   * parent object from which the descriptor was derived.\n   *\n   * @param {object} value sets the object for which this descriptor is to\n   * be associated with.\n   */\n  set object(value) { this.#object = Object(value) }\n\n  /**\n   * The function returns a string representation of a descriptor object with\n   * additional information about its type when used in the NodeJS repl.\n   *\n   * @param {number} depth - The `depth` parameter is used to specify the\n   * maximum depth to which nested objects and arrays will be formatted. If\n   * the depth is exceeded, the output will be truncated with ellipses.\n   * @param {object} options - The `options` parameter is an object that\n   * contains various configuration options for the `inspect` function.\n   * These options can be used to customize the output of the inspection.\n   * @param {function} inspect - The `inspect` parameter is a function that\n   * is used to convert an object into a string representation. It is\n   * typically used for debugging purposes or when displaying an object's\n   * properties.\n   * @returns a string that represents a descriptor. The string includes the\n   * type of the descriptor (either \"Accessor\" or \"Data\") and the result of\n   * inspecting the descriptor object using the provided options and depth.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const type = this.isAccessor ? ' (Accessor)' : this.isData ? ' (Data)' : ''\n    return `Descriptor${type} ${inspect(this.#desc, {...options, depth})}`\n  }\n\n  /**\n   * Shorthand for Object.getOwnPropertyDescriptor()\n   *\n   * @param {object} object a non-null object instance\n   * @param {string|symbol} key a symbol or string referencing which key on the\n   * object to return a descriptor for.\n   * @returns an object descriptor for the requested field or null\n   */\n  static for(object, key, wrap = false) {\n    if (!isObject(object) || !isValidKey(key) || !Reflect.has(object, key)) {\n      return null\n    }\n\n    return (wrap\n      ? new Descriptor(Object.getOwnPropertyDescriptor(object, key))\n      : Object.getOwnPropertyDescriptor(object, key)\n    )\n  }\n\n  /**\n   * Take the descriptor defined by this objects values and apply them to\n   * the specified object using the specified key.\n   *\n   * @param {object} object the object to apply this descriptor to\n   * @param {string|symbol} forKey the string or symbol for which this\n   * descriptor will abe applied\n   */\n  applyTo(object, forKey, bindAccessors = false) {\n    if (!isObject(object) || !isValidKey(forKey)) {\n      throw new Error( `Cannot apply descriptor to non-object or invalid key`)\n    }\n\n    return Object.defineProperty(object, forKey, this.toObject(bindAccessors))\n  }\n\n  /**\n   * Converts this Descriptor class instance into a basic object descriptor\n   * that is accepted by all the standard JavaScript runtime methods that\n   * deal with object descriptors.\n   *\n   * @param {boolean|object} bindAccessors if `true`, a non-fatal attempt to\n   * bind accessor getter and setter methods is made before returning the\n   * object. If `bindAccessors` is truthy and is also an object, this is the\n   * object the accessors will be bound to. If the value is falsy or if the\n   * descriptor instance represents a data descriptor, nothing happens.\n   * @returns {object} the object instance's basic object representation as\n   * a descriptor.\n   */\n  toObject(bindAccessors = false) {\n    let descriptor = { ...this.#desc }\n\n    if (bindAccessors && this.isAccessor) {\n      if (this.hasObject) {\n        descriptor = {\n          ...descriptor,\n          get: this.boundGet,\n          set: this.boundSet\n        }\n      }\n      else if (isObject(bindAccessors)) {\n        descriptor = {\n          ...descriptor,\n          get: this.get?.bind(bindAccessors),\n          set: this.set?.bind(bindAccessors)\n        }\n      }\n    }\n\n    return descriptor\n  }\n\n  /**\n   * Converts this descriptor object into a base representation\n   *\n   * @param {string} hint one of `string`, `number` or default;\n   * @returns if the hint is 'string', then a string identifying the enum\n   * and its type is returned. `number` will always be NaN since it is incoret\n   */\n  [Symbol.toPrimitive](hint) {\n    switch (hint) {\n      case 'string':\n        if (this.isAccessor) {\n          const hasGetter = Reflect.has(this.#desc, 'get') ? `getter` : ''\n          const hasSetter = Reflect.has(this.#desc, 'set') ? `setter` : ''\n          const separator = hasGetter && hasSetter ? ', ' : ''\n\n          return `Accessor (${hasGetter}${separator}${hasSetter})`\n        }\n        else if (this.isData) {\n          const hasGetter = Reflect.has(this.#desc, 'value') ? `value` : ''\n          const hasSetter = Reflect.has(this.#desc, 'writable') ? `writable` : ''\n          const separator = hasGetter && hasSetter ? ', ' : ''\n\n          return `Data (${hasGetter}${separator}${hasSetter})`\n        }\n        break\n\n      case 'number':\n        return NaN\n\n      default:\n        return this.toObject()\n    }\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * The function `getData` retrieves the value of a property from an object\n   * if it exists and is a data property.\n   *\n   * @param {object} object - The \"object\" parameter is the object from which\n   * we want to retrieve data.\n   * @param {string|symbol} property - The `property` parameter is the name of\n   * the property that you want to retrieve the data from.\n   * @returns either the value of the specified property if it exists and is\n   * a data property, or undefined if the property does not exist or is not\n   * a data property.\n   */\n  static getData(object, property) {\n    if (!isObject(object) || !Reflect.has(object, property)) {\n      return undefined;\n    }\n\n    const descriptor = Descriptor.for(object, property, true)\n    if (!descriptor.isData) {\n      return null\n    }\n\n    return descriptor.value\n  }\n\n  /**\n   * The function `getAccessor` checks if an object has a getter/setter accessor\n   * for a given property and returns the accessor functions if found.\n   *\n   * @param object - The `object` parameter is the object from which we want to\n   * retrieve the accessor for a specific property.\n   * @param property - The `property` parameter is the name of the property for\n   * which we want to get the accessor.\n   * @returns an object that contains the getter and setter functions for the\n   * specified property of the given object. If the property is an accessor\n   * property (defined with a getter and/or setter), the returned object will\n   * also have additional properties such as \"accessor\" and \"descriptor\". If\n   * the property is not found or is not an accessor property, the function\n   * returns undefined.\n   */\n  static getAccessor(object, property) {\n    if (!isObject(object) || !Reflect.has(object, property)) {\n      return undefined;\n    }\n\n    const descriptor = Descriptor.for(object, property, true)\n    if (!descriptor.isAccessor) {\n      return null\n    }\n\n    return descriptor.get.bind(object)()\n  }\n\n  /**\n   * The function returns an object with enumerable and configurable properties\n   * based on the input parameters.\n   *\n   * @param [enumerable=false] - A boolean value indicating whether the property\n   * can be enumerated (listed) when iterating over the object's properties.\n   * @param [configurable=false] - The `configurable` parameter determines\n   * whether the property can be deleted or its attributes can be modified.\n   * If `configurable` is set to `true`, the property can be deleted and its\n   * attributes can be changed. If `configurable` is set to `false`, the\n   * property cannot be deleted and\n   * @returns An object with the properties `enumerable` and `configurable` is\n   * being returned. The values of these properties are determined by the\n   * arguments passed to the `base` function.\n   */\n  static base(enumerable = false, configurable = false) {\n    return {\n      enumerable,\n      configurable\n    }\n  }\n\n  /**\n   * The function \"newAccessor\" creates a new property descriptor object with a\n   * getter and setter function, along with optional enumerable and configurable\n   * flags.\n   *\n   * @param getter - The getter parameter is a function that will be used as the\n   * getter for the property. It will be called when the property is accessed.\n   * @param setter - The `setter` parameter is a function that will be used as\n   * the setter for the property. It will be called whenever the property is\n   * assigned a new value.\n   * @param [] - - `getter`: A function that will be used as the getter for the\n   * property.\n   * @returns an object with properties \"get\", \"set\", \"enumerable\", and\n   * \"configurable\".\n   */\n  static accessor(\n    getter,\n    setter,\n    { enumerable, configurable } = Descriptor.base()\n  ) {\n    return {\n      get: getter,\n      set: setter,\n      enumerable,\n      configurable\n    }\n  }\n\n  /**\n   * The function \"newData\" creates a new data object with customizable\n   * properties.\n   *\n   * @param value - The value parameter represents the value that will be\n   * assigned to the property.\n   * @param [writable=true] - The `writable` parameter determines whether the\n   * value of the property can be changed. If `writable` is set to `true`, the\n   * value can be changed. If `writable` is set to `false`, the value cannot be\n   * changed.\n   * @param [] - - `value`: The value to be assigned to the property.\n   * @returns an object with properties `value`, `enumerable`, `writable`, and\n   * `configurable`.\n   */\n  static data(\n    value,\n    writable = true,\n    { enumerable, configurable } = Descriptor.base()\n  ) {\n    return {\n      value,\n      enumerable,\n      writable,\n      configurable\n    }\n  }\n\n  /**\n   * The function checks if an object is a likely an object descriptor in\n   * JavaScript. This is determined as an object with some of the known\n   * descriptor keys (e.g. enumerable, configurable, value, writable, get,\n   * or set). Technically, any object could serve as a descriptor but this\n   * function only returns true if known descriptor keys are found.\n   *\n   * @param object - The `object` parameter is the object that we want to\n   * check if it is a descriptor.\n   * @returns a boolean value.\n   */\n  static isDescriptor(object) {\n    const knownKeys = [\n      ...Descriptor.SHARED_KEYS,\n      ...Descriptor.ACCESSOR_KEYS,\n      ...Descriptor.DATA_KEYS,\n    ]\n\n    return hasSome(object, knownKeys)\n  }\n\n  /**\n   * The function checks if a given property or descriptor is a data property.\n   *\n   * brie\n   *\n   * @param descriptor_orProp - The `descriptor_orProp` parameter can be\n   * either a descriptor or a property name.\n   * @param object - The `object` parameter is the object that you want to\n   * check for data properties.\n   * @returns a boolean value. It returns `true` if the `descriptor` object\n   * has any keys that match the `DATA_KEYS` array, otherwise it returns\n   * `false`.\n   */\n  static isData(object_orProp, property) {\n    const needsDescriptor = (\n      ((typeof object_orProp === 'object') || object_orProp instanceof Object) &&\n      property instanceof String\n    )\n\n    const descriptor = (needsDescriptor\n      ? Descriptor.for(object_orProp, property)\n      : object_orProp\n    )\n\n    const { DATA_KEYS } = this\n    let validData = false\n\n    if (hasSome(descriptor, DATA_KEYS)) {\n      validData = true\n    }\n\n    return validData\n  }\n\n  /**\n   * The function checks if a given property descriptor or property of an\n   * object is an accessor.\n   *\n   * @param object_orProp - The `descriptor_orProp` parameter can be either a\n   * descriptor object or a property name.\n   * @param property - The `object` parameter is the object that you want to\n   * check for accessor properties.\n   * @returns a boolean value. It returns true if the descriptor or property\n   * passed as an argument is an accessor descriptor, and false otherwise.\n   */\n  static isAccessor(object_orProp, property) {\n    const needsDescriptor = (\n      (object_orProp && property) &&\n      ((typeof object_orProp === 'object') || object_orProp instanceof Object) &&\n      (property instanceof String || (typeof property === 'symbol'))\n    )\n\n    const descriptor = (needsDescriptor\n      ? Descriptor.for(object_orProp, property)\n      : object_orProp)\n\n    const { ACCESSOR_KEYS } = this\n    let validAccessor = false\n\n    if (hasSome(descriptor, ACCESSOR_KEYS)) {\n      validAccessor = true\n    }\n\n    return validAccessor\n  }\n\n  /**\n   * A base descriptor (new for each read) that is both enumerable and\n   * configurable\n   *\n   * @returns The method `flexible` is returning the result of calling the\n   * `base` method with the arguments `true` and `true`.\n   */\n  static get flexible() {\n    return this.base(true, true)\n  }\n\n  /**\n   * A base descriptor (new for each read) that is not enumerable but is\n   * configurable\n   *\n   * @returns The method `enigmatic` is returning the result of calling\n   * the `base` method with the arguments `false` and `true`.\n   */\n  static get enigmatic() {\n    return this.base(false, true)\n  }\n\n  /**\n   * A base descriptor (new for each read) that is neither enumerable\n   * nor configurable\n   *\n   * @returns The code is returning the result of calling the `base` method with\n   * the arguments `false` and `false`.\n   */\n  static get intrinsic() {\n    return this.base(false, false)\n  }\n\n  /**\n   * A base descriptor (new for each read) that enumerable but not configurable\n   *\n   * @returns The method is returning the result of calling the `base`\n   * method with the arguments `true` and `false`.\n   */\n  static get transparent() {\n    return this.base(true, false)\n  }\n\n  /**\n   * The function returns an array of shared descriptor keys.\n   *\n   * @returns An array containing the strings 'configurable' and 'enumerable'.\n   */\n  static get SHARED_KEYS() {\n    return ['configurable', 'enumerable']\n  }\n\n  /**\n   * The function returns an array of accessor descriptor keys.\n   *\n   * @returns An array containing the strings 'get' and 'set' is being returned.\n   */\n  static get ACCESSOR_KEYS() {\n    return ['get', 'set']\n  }\n\n  /**\n   * The function returns an array of data descriptor keys.\n   *\n   * @returns An array containing the strings 'value' and 'writable' is being\n   * returned.\n   */\n  static get DATA_KEYS() {\n    return ['value', 'writable']\n  }\n}\n\nexport const DescriptorExtensions = new Extension(Descriptor)\n\nfunction isObject(o) { return o && typeof o === 'object' }\nfunction isValidKey(o) { return ['string','symbol'].some(t => typeof o === t) }\nfunction hasSome(object, ...keys) {\n  return isObject(object) && (keys.flat(Infinity)\n    .map(key => Reflect.has(object, key))\n    .some(has => has)\n  )\n}", "import { Extension } from '@nejs/extension'\n\nexport class Property {\n  constructor(key, descriptor) {\n    if (key.startsWith(':')) key = Symbol.for(key.slice(1))\n    if (typeof key !== 'string' && typeof key !== 'symbol') {\n      throw new TypeError('Key or symbol or :symbol must be supplied!');\n    }\n\n    this.key = key;\n\n    if (!Property.is.descriptor(descriptor)) {\n      this.descriptor = {\n        value: descriptor,\n        writable: true,\n        configurable: true,\n        enumerable: true,\n      }\n    }\n    else {\n      this.descriptor = descriptor;\n    }\n  }\n\n  apply(toObject, asKey) {\n    if (!toObject || !['object','function'].some(k => k == typeof toObject))\n      return;\n\n    return Object.defineProperty(toObject, asKey ?? this.key, this.descriptor)\n  }\n\n  get descriptor() {\n    const baseline = { configurable: true, enumerable: false };\n    const result = {\n      enumerable: this.meta.enumerable,\n      configurable: this.meta.configurable,\n    };\n\n    if (this.is.accessor) {\n      result.get = this.meta.accessor.get;\n      result.set = this.meta.accessor.set;\n    }\n    else {\n      result.value = this.meta.data.value;\n      result.writable = this.meta.data.writable;\n    }\n\n    return Object.defineProperties(result, {\n      make: {\n        ...baseline,\n        get() {\n          const self = this;\n\n          return {\n            get enumerable() {self.enumerable = true; return self},\n            get hidden() {self.enumerable = false; return self},\n\n            get writable() {self.writable = true; return self},\n            get readonly() {self.writable = false; return self},\n\n            get configurable() {self.configurable = true; return self},\n            get immutable() {self.configurable = false; return self},\n          }\n        }\n      },\n\n      is: {\n        ...baseline,\n        get() {\n          const self = this;\n\n          return {\n            get accessor() {return self.is.accssor},\n            get data() {return self.is.data}\n          }\n        }\n      },\n    })\n  }\n\n  set descriptor(descriptor) {\n    const { is } = this.constructor;\n\n    if (!is.descriptor(descriptor))\n      return;\n\n    this.meta.configurable = descriptor.configurable ?? true\n    this.meta.enumerable = descriptor.enumerable ?? true\n\n    if (Reflect.has(descriptor, 'get') || Reflect.has(descriptor, 'set')) {\n      const { get, set } = descriptor;\n\n      if (get !== undefined) this.meta.accessor.get = get;\n      if (set !== undefined) this.meta.accessor.set = set;\n    }\n    else {\n      const { value, writable } = descriptor;\n\n      this.meta.data.value = value;\n      this.meta.data.writable = writable ?? true;\n    }\n  }\n\n  get is() {\n    const self = this;\n\n    return {\n      get accessor() {\n        return !!(\n          self.meta.accessor.get ||\n          self.meta.accessor.set\n        );\n      },\n\n      get data() {\n        return !!!this.accessor\n      },\n    }\n  }\n\n  toString(colors = false, {key, descriptor} = {}) {\n    const bold = s => colors ? `\\x1b[1m${s}\\x1b[22m` : s;\n    const dim = s => colors ? `\\x1b[2m${s}\\x1b[22m` : s;\n    const red = s => colors ? `\\x1b[31m${s}\\x1b[39m` : s;\n    const green = s => colors ? `\\x1b[32m${s}\\x1b[39m` : s;\n    const blue = s => colors ? `\\x1b[34m${s}\\x1b[39m` : s;\n\n    if (!key) ({key} = this);\n    if (!descriptor || !Property.is.descriptor(descriptor))\n      ({descriptor} = this);\n\n    const buffer = [`${bold(key)} { `]\n    const keyPresent = (object) => (key) => Reflect.has(object, key)\n    const eqeq = (value, compare = (a,b) => a === b) =>\n      (element) => compare(element, value);\n\n    if (['get', 'set'].some(keyPresent(descriptor))) {\n      if (descriptor.get) {\n        buffer.push(blue('getter'))\n        if (descriptor.set) {\n          buffer.push(bold('|'))\n        }\n      }\n\n      if (descriptor.set) {\n        buffer.push(blue('setter'))\n      }\n    }\n    else {\n      buffer.push(green('value'))\n      buffer.push(bold('|'))\n      buffer.push(descriptor.writable ? green('writable') : red('readonly'))\n    }\n\n    buffer.push(' ')\n    buffer.push(descriptor.configurable ? green('mutable') : red('immuatable'))\n\n    buffer.push(' ')\n    buffer.push(descriptor.enumerable ? green('visible') : red('hidden'))\n\n    buffer.push(' }')\n\n    return buffer.join('')\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    return this.toString(true);\n  }\n\n  /**\n   * Creates an accessor property with customizable getter and setter functions.\n   *\n   * This method offers flexible ways to define accessor properties, including\n   * support for storage-based getters and setters. It can handle various input\n   * formats, making it versatile for different use cases.\n   *\n   * @param {string} name - The name of the accessor property.\n   * @param {Object} accessors - Object containing getter and/or setter functions.\n   * @param {Function} [accessors.get] - Getter function for the property.\n   * @param {Function} [accessors.set] - Setter function for the property.\n   * @param {Object} [accessors.prototype] - Prototype object for getter/setter.\n   * @param {Object} [options] - Additional options for the accessor property.\n   * @param {boolean} [options.configurable=true] - Whether property is configurable.\n   * @param {boolean} [options.enumerable=true] - Whether property is enumerable.\n   * @param {Object} [options.storage] - Storage object for getter/setter closures.\n   * @returns {Property} A new Property instance representing the accessor.\n   * @throws {TypeError} If no name, getter, or setter is provided.\n   *\n   * @example\n   * // Basic usage\n   * Property.accessor('color', {\n   *   get() { return this._color; },\n   *   set(value) { this._color = value; }\n   * });\n   *\n   * @example\n   * // Using storage\n   * Property.accessor('keyword', {\n   *   get(storage) { return () => storage.keyword; },\n   *   set(storage) { return (value) => { storage.keyword = value; } }\n   * }, { storage: { keyword: 'initial' } });\n   *\n   * @example\n   * // Using named getter function\n   * Property.accessor('color', function get() { return 'red' })\n   *\n   * @example\n   * // Using prototype\n   * const ColorAccessors = {\n   *   red: { get() { return this._red; } }\n   * };\n   * Property.accessor('red', ColorAccessors.red);\n   */\n  static accessor(\n    name,\n    {get, set, prototype},\n    {configurable, enumerable, storage} = {}\n  ) {\n    if (!get && !set && prototype) {\n      const constructor = prototype?.constructor;\n\n      if (constructor?.name === 'get') {\n        get = constructor;\n      }\n      else if (constructor?.name === 'set') {\n        set = constructor\n      }\n    }\n\n    if (get && storage && get.length == 1) {\n      get = get(storage);\n    }\n\n    if (set && storage && set.length == 1) {\n      set = set(storage);\n    }\n\n    if (!name && !get && !set) throw new TypeError('Cannot create accessor');\n\n    configurable ??= true\n    enumerable ??= true\n\n    return new Property(name, { get, set, configurable, enumerable });\n  }\n\n  static data(name, value, { writable, configurable, enumerable } = {}) {\n    if (!name) throw new TypeError('Cannot create data property without name')\n\n    writable ??= true\n    configurable ??= true\n    enumerable ??= true\n\n    return new Property(name, { value, writable, configurable, enumerable })\n  }\n\n  static from(object, name) {\n    const descriptor = Object.getOwnPropertyDescriptor(object, name);\n    return new Property(name, descriptor);\n  }\n\n  static get is() {\n    return {\n      object(value) {\n        return value && ['object','function'].some(k => k == typeof value);\n      },\n\n      descriptor(object) {\n        if (!Property.is.object(object)) {\n          return false;\n        }\n\n        const present = element => Reflect.has(object, element);\n        const props = {\n          base: ['configurable', 'enumerable'],\n          data: ['writable', 'value'],\n          accessor: ['get', 'set'],\n        };\n\n        if (Object.getOwnPropertyNames(object).length > 4)\n          return false;\n\n        if (props.data.some(present) && props.accessor.some(present))\n          return false;\n\n        if (props.base.some(present)) return true;\n        if (props.data.some(present)) return true;\n        if (props.accessor.some(present)) return true;\n\n        return false;\n      }\n    }\n  }\n\n  static {\n    const storage = Object.assign(Object.create(null), {\n      key: undefined,\n      meta: {\n        enumerable: true,\n        configurable: true,\n        accessor: {\n          get: undefined,\n          set: undefined\n        },\n        data: {\n          value: undefined,\n          writable: true\n        },\n      },\n    });\n\n    basic_accessor(this.prototype, 'key', storage.key, storage)\n    basic_accessor(this.prototype, 'meta', storage.meta, storage);\n  }\n}\n\nexport const PropertyExtensions = new Extension(Property);\n\nfunction basic_accessor(prototype, key, initialValue, storage = {}) {\n  storage[key] = initialValue;\n\n  Object.defineProperty(prototype, key, {\n    get() {\n      return storage[key]\n    },\n    set(value) {\n      storage[key] = value\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  return Object.getOwnPropertyDescriptor(prototype, key);\n}", "import { Patch } from '@nejs/extension'\n\nimport { SymbolExtensions } from './symbol.extensions.js';\nimport { Descriptor } from './classes/descriptor.js';\nimport { Property } from './classes/property.js';\n\nconst { keys: symkeys } = SymbolExtensions.patches\n\n// Avoid circular dependencies; rewrite here for brevity\nconst isFn = o => typeof o === 'function' || o instanceof Function\nconst isStr = o => typeof o === 'string' || o instanceof String\nconst isBool = o => typeof o === 'boolean'\nconst isTrue = o => isBool(o) && o === true\nconst isTruthy = o => isTrue(!!o)\nconst isFalse = o => isBool(o) && o === false\nconst isFalsy = o => isFalse(!!o)\n\n/**\n * `ObjectExtensions` is a constant that applies a patch to the global\n * `Object` constructor. This patch extends the `Object` with additional\n * methods and properties, enhancing its functionality.\n *\n * The `Patch` function takes two arguments: the target object to be patched\n * (in this case, `Object`), and an object containing the methods and\n * properties to be added to the target object.\n *\n * @type {Patch}\n * @memberof module:object.extensions\n */\nexport const ObjectExtensions = new Patch(Object, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Creates a shallow copy of the provided object(s).\n     *\n     * This method uses the `copyObject` function with the `deep` parameter\n     * set to `false`, indicating a shallow copy. It takes a destination\n     * object and any number of source objects, and copies the properties\n     * from the source objects to the destination object. If a property\n     * already exists on the destination object, it will be overwritten.\n     *\n     * Note: This method does not copy nested objects or arrays. They are\n     * copied by reference, not by value. To create a deep copy, use the\n     * `deepCopy` method instead.\n     *\n     * @param {object} destination - The object to which properties will be\n     * copied.\n     * @param {...object} sources - The source object(s) from which\n     * properties will be copied.\n     * @returns {object} The destination object with the copied properties.\n     *\n     * @example\n     * const obj1 = { a: 1, b: 2 };\n     * const obj2 = { b: 3, c: 4 };\n     * const result = ObjectExtensions.copy(obj1, obj2);\n     * console.log(result); // Output: { a: 1, b: 3, c: 4 }\n     */\n    copy(destination, ...sources) {\n      return copyObject(false, destination, ...sources)\n    },\n\n    /**\n     * Creates a deep copy of the provided object(s).\n     *\n     * This method uses the `copyObject` function with the `deep` parameter\n     * set to `true`, indicating a deep copy. It takes a destination\n     * object and any number of source objects, and copies the properties\n     * from the source objects to the destination object. If a property\n     * already exists on the destination object, it will be overwritten.\n     *\n     * Note: This method copies nested objects or arrays by value, not by\n     * reference. To create a shallow copy, use the `copy` method instead.\n     *\n     * @param {object} destination - The object to which properties will be\n     * copied.\n     * @param {...object} sources - The source object(s) from which\n     * properties will be copied.\n     * @returns {object} The destination object with the copied properties.\n     *\n     * @example\n     * const obj1 = { a: 1, b: { c: 2 } };\n     * const obj2 = { b: { d: 3 }, e: 4 };\n     * const result = ObjectExtensions.deepCopy(obj1, obj2);\n     * console.log(result); // Output: { a: 1, b: { d: 3 }, e: 4 }\n     */\n    deepCopy(destination, ...sources) {\n      return copyObject(true, destination, ...sources)\n    },\n\n    /**\n     * A getter property that provides access to the definition types used\n     * for object property definitions. These types are used to control the\n     * visibility and mutability of object properties.\n     *\n     * @returns {Object} An object with getter properties for each definition\n     * type. The properties are:\n     * - `mutablyHidden`: A symbol representing a mutably hidden property,\n     *   non-enumerable, but configurable.\n     * - `mutablyVisible`: A symbol representing a mutably visible property,\n     *   enumerable, configurable\n     * - `immutablyHidden`: A symbol representing an immutably hidden property,\n     *   non-enumerable, non-configurable.\n     * - `immutablyVisible`: A symbol representing an immutably visible\n     *   property, enumerable, non-configurable.\n     *\n     * @example\n     * // Get the symbol for a mutably hidden property\n     * const hiddenSymbol = Object.definitionType.mutablyHidden;\n     *\n     * // Define a new mutably hidden property on an object\n     * Object.define(myObject, 'myProperty', myValue, hiddenSymbol);\n     */\n    get definitionType() {\n      return {\n        get mutablyHidden() { return Patch.kMutablyHidden },\n        get mutablyVisible() { return Patch.kMutablyVisible },\n        get immutablyHidden() { return Patch.kImmutablyHidden },\n        get immutablyVisible() { return Patch.kImmutablyVisible },\n      }\n    },\n\n    /**\n     * Defines a new property on an object with a specified value and\n     * visibility/mutability flag. The flag determines the visibility and\n     * mutability of the property. By default, the property is defined as\n     * mutably hidden.\n     *\n     * @param {object} object - The object on which to define the property.\n     * @param {string} key - The name of the property to be defined.\n     * @param {any} value - The value of the property to be defined.\n     * @param {symbol} [flag=Object.definitionType.mutablyHidden] - The\n     * visibility/mutability flag for the property. This should be one of the\n     * symbols available in `ObjectExtensions.definitionType`.\n     * @returns {object} The object with the newly defined property.\n     *\n     * @example\n     * // Define a new mutably hidden property on an object\n     * const myObject = {};\n     * const myValue = 'Hello, world!';\n     * const hiddenSymbol = Object.definitionType.mutablyHidden;\n     * Object.define(myObject, 'myProperty', myValue, hiddenSymbol);\n     * // myObject now has a mutably hidden property 'myProperty' with value\n     * // 'Hello, world!'\n     */\n    define(object, key, value, flag = Object.definitionType.mutablyHidden) {\n      const properties = Patch.getDescriptorOverridesFromSymbol(flag)\n      return Object.defineProperty(object, key, { ...properties, value })\n    },\n\n    /**\n     * Defines a new accessor property on an object with specified getter and\n     * setter functions and a visibility/mutability flag. The flag determines\n     * the visibility and mutability of the property. By default, the property\n     * is defined as mutably hidden.\n     *\n     * @param {object} object - The object on which to define the property.\n     * @param {string} key - The name of the property to be defined.\n     * @param {function} get - The getter function for the property.\n     * @param {function} set - The setter function for the property.\n     * @param {symbol} [flag=Object.definitionType.mutablyHidden] - The\n     * visibility/mutability flag for the property. This should be one of the\n     * symbols available in `ObjectExtensions.definitionType`.\n     * @returns {object} The object with the newly defined property.\n     *\n     * @example\n     * // Define a new mutably hidden accessor property on an object\n     * const myObject = {};\n     * const hiddenSymbol = ObjectExtensions.definitionType.mutablyHidden;\n     * ObjectExtensions.defineAccessor(\n     *   myObject,\n     *   'myProperty',\n     *   () => 'Hello, world!',\n     *   (value) => console.log(`Setting value: ${value}`),\n     *   hiddenSymbol\n     * );\n     * // myObject now has a mutably hidden property 'myProperty' with getter\n     * // and setter functions\n     */\n    defineAccessor(\n      object, key, get, set, flag = Object.definitionType.mutablyHidden\n    ) {\n      const properties = Patch.getDescriptorOverridesFromSymbol(flag)\n      return Object.defineProperty(object, key, { ...properties, get, set })\n    },\n\n    addAccessor(to, key, getter, setter, storage) {\n      const store = storage ?? (!getter && !setter) ? true : undefined;\n      return this.add({ to, key, get: getter, set: setter, storage: store })\n    },\n\n    addData(to, key, value) {\n      return this.add({ to, key, value })\n    },\n\n    add(...args) {\n      const { isDescriptor } = Descriptor\n      const { isObject: isObj } = this\n      const { kDescriptorStore } = this\n\n      let obj, key, value, _get, _set, storage, storageKey\n      let _type, _flag, _desc\n\n      // Check to see if we received multiple arguments or an object\n      if (args.length && isObj(args[0])) {\n        ({\n          to: obj,\n          key,\n          value,\n          get: _get,\n          set: _set,\n          storage,\n          storageKey,\n          type: _type = ['accessor', 'data'][1],\n          flag: _flag = undefined,\n          descriptorBase: _desc = undefined,\n        } = args[0])\n      }\n      else if (args.length > 1) {\n        ([\n          to,\n          _type,\n          key,\n          getOrValue,\n          _set,\n          storage,\n          storageKey,\n          _flag,\n          _desc,\n        ] = args)\n\n        obj = to\n        _type = (\n          ['accessor', 'data'].includes(_type.toLowerCase())\n          ? _type.toLowerCase() : 'data'\n        )\n        _get = _type === 'accessor' ? getOrValue : undefined\n        _value = _type === 'data' ? getOrValue : undefined\n      }\n\n      if (!this.isObject(obj)) {\n        console.warn('Object.add() must receive an object for `toObject`')\n        return obj;\n      }\n\n      const more = isDescriptor(_desc) ? _desc : {}\n      const flag = _flag || Object.definitionType.mutablyVisible\n      const props = { ...Patch.getDescriptorOverridesFromSymbol(flag), ...more }\n      const type = (['accessor', 'data'].includes(_type)\n        ? String(_type).toLowerCase() : 'data'\n      )\n\n      switch (type) {\n        case 'accessor':\n          let store = storage;\n          let storeKey = storageKey || key\n          let makeStore = false\n          let get = _get;\n          let set = _set;\n\n          if (!isTruthy(get) && !isFn(get)) { get = undefined }\n          if (!isTruthy(set) && !isFn(set)) { set = undefined }\n\n          if (isObj(store) || isTrue(store) || isFn(store)) {\n            makeStore = isTrue(store)\n            store = isFn(store) ? store() : store\n            store = isObj(store) ? store : (makeStore && {} || undefined)\n          }\n          // store should be defined by here: object or undefined\n\n          if ((!get && !set) && makeStore) {\n            // being lazy here, someone has defined we make an accessor but\n            // wants the default accessor behaviors with an associated store\n            // made by us.\n            Object.defineProperty(obj, kDescriptorStore, {\n              value: symkeys.add('descriptor.store', store),\n              configurable: true,\n              enumerable: false,\n              writable: true,\n            })\n\n            get = () => this[kDescriptorStore]?.data?.[storeKey]\n            set = (value) => { this[kDescriptorStore].data[storeKey] = value }\n          }\n\n          else if (get?.length && set?.length > 1 && store) {\n            // if we received a get or set that takes more arguments than\n            // expected, assume the last argument should be the store variable\n            // so we execute the supplied function with the storage and its\n            // results or byproducts are the result to the get/set we define\n            const innerGet = get\n            const innerSet = set\n            get = () => innerGet(store)\n            set = (value) => innerSet(value, store)\n          }\n          // get and set should be in their final state by here\n\n          Object.defineProperty(obj, key, { ...props, get, set })\n          break\n\n        case 'data':\n          Object.defineProperty(obj, key, { ...props, value })\n          break\n      }\n\n      return obj\n    },\n\n    /**\n     * Creates a new object from an array of key-value pairs (entries), with an\n     * optional prototype and reducer function. If no prototype is provided,\n     * the default Object.prototype is used. If no reducer is provided, a\n     * default reducer is used that assigns each value to its corresponding key.\n     *\n     * @param {Array} entries - An array of key-value pairs. Each entry should\n     * be an array where the first element is the key and the second element is\n     * the value. Non-conforming entries are ignored.\n     * @param {object} [prototype=Object.prototype] - The prototype to use for\n     * the new object. If not provided, Object.prototype is used.\n     * @param {Function} [reducer] - An optional reducer function to use when\n     * creating the new object. If not provided, a default reducer is used that\n     * assigns each value to its corresponding key.\n     * @returns {object|undefined} - The new object created from the entries, or\n     * undefined if the entries array is not valid or contains no valid entries.\n     *\n     * @example\n     * // Create an object with a custom prototype and reducer\n     * const myPrototype = { foo: 'bar' };\n     * const myReducer = (obj, [key, value]) => {\n     *   obj[key] = value.toUpperCase();\n     *   return obj;\n     * };\n     *\n     * const myEntries = [['name', 'John'], ['age', '30']];\n     * const myObject = Object.fromEntriesUsing(\n     *   myEntries, myPrototype, myReducer\n     * );\n     *\n     * // myObject is now { name: 'JOHN', age: '30' }\n     * // with prototype { foo: 'bar' }\n     */\n    fromEntriesUsing(entries, prototype = Object.prototype, reducer = undefined) {\n      if (!Array.isArray(entries)) {\n        return undefined;\n      }\n\n      const entriesToUse = entries.filter(\n        entry => Array.isArray(entry) && entry.length >= 2\n      );\n\n      if (!entriesToUse.length) {\n        return undefined;\n      }\n\n      const useReducer = reducer instanceof Function\n        ? reducer\n        : (accumulator, [key, value]) => {\n          accumulator[key] = value;\n          return accumulator;\n        };\n\n      return entriesToUse.reduce(\n        useReducer, Object.create(prototype ?? Object.prototype)\n      );\n    },\n\n    /**\n     * Retrieves the prototype chain entries of a given object.\n     *\n     * This method traverses the prototype chain of the provided object and\n     * collects an array of entries. Each entry is a pair consisting of the\n     * prototype object and its property descriptors.\n     *\n     * The property descriptors are obtained using the `Reflect.ownKeys`\n     * method and the `Object.getOwnPropertyDescriptor` function.\n     *\n     * @param {Object} object - The object whose prototype chain entries are\n     * to be retrieved.\n     * @returns {Array} An array of entries, where each entry is a pair\n     * consisting of a prototype object and its property descriptors.\n     *\n     * @example\n     * const obj = Object.create({ foo: 'bar' });\n     * console.log(getPrototypeChainEntries(obj));\n     * // Output: [[{ foo: 'bar' }, { foo: { value: 'bar', writable: true,\n     * // enumerable: true, configurable: true } }], [Object.prototype, { ... }]]\n     */\n    getPrototypeChainEntries(object) {\n      const entries = []\n\n      let prototype = Object.getPrototypeOf(object)\n      while (prototype) {\n        const descriptors = Reflect.ownKeys(prototype).reduce((acc, key) => {\n          acc[key] = Object.getOwnPropertyDescriptor(prototype, key)\n          return acc\n        }, {})\n\n        entries.push([prototype, descriptors])\n\n        prototype = Object.getPrototypeOf(prototype)\n      }\n\n      return entries\n    },\n\n    /**\n     * Retrieves the string tag of an object. The string tag is a representation\n     * of the object's type, as defined by its `Object.prototype.toString`\n     * method. This utility method is helpful for getting a more descriptive\n     * type of an object than what is returned by the `typeof` operator,\n     * especially for custom objects.\n     *\n     * @param {*} value - The object whose string tag is to be retrieved.\n     * @param {boolean} strict - if this is set to true, undefined will be\n     * returned whenever a supplied object does not have a\n     * `Symbol.toStringTag` defined, period. if false, the default,\n     * @returns {string} - The string tag of the object, indicating its type.\n     */\n    getStringTag(value, strict = false) {\n      if (Object.hasStringTag(value)) {\n        return value[Symbol.toStringTag]\n      }\n\n      if (strict) {\n        return undefined\n      }\n\n      if (value && (typeof value === 'function')) {\n        return value.name\n      }\n\n      return /\\s(.+)]/.exec(Object.prototype.toString.call(value))[1];\n    },\n\n    /**\n     * Determines the type of the given value based on its string tag. This method\n     * uses `Object.getStringTag` to obtain the string tag of the value, which\n     * represents its more specific type (e.g., Array, Map, Set) rather than just\n     * 'object'. The method then maps this string tag to the corresponding type\n     * present in the provided `owner` object, which defaults to `globalThis`.\n     * This utility method is especially useful for identifying the specific\n     * constructor or class of an object, beyond the basic types identified by\n     * the `typeof` operator.\n     *\n     * @param {any} value - The value whose type is to be determined.\n     * @param {object} [owner=globalThis] - The object in which to look up the\n     * constructor corresponding to the string tag. Defaults to `globalThis`,\n     * which covers global constructors like `Array`, `Object`, etc.\n     * @returns {Function|object|null|undefined} - Returns the constructor or\n     * type of the value based on its string tag. For 'Null' and 'Undefined',\n     * it returns `null` and `undefined`, respectively. For other types, it\n     * returns the corresponding constructor (e.g., `Array` for arrays) if\n     * available in the `owner` object.\n     */\n    getType(value, owner = globalThis) {\n      const stringTag = Object.getStringTag(value)\n\n      switch (stringTag) {\n        case 'Null': return null\n        case 'Undefined': return undefined\n        default:\n          return owner[stringTag]\n      }\n    },\n\n    /**\n     * Checks to see if the supplied `value` is both an object, and has the\n     * appropriate symbol defined.\n     *\n     * @param {any} value the value to determine if it contains a defined\n     * `Symbol.toStringTag` defined.\n     * @returns true if the symbol is defined, false otherwise\n     */\n    hasStringTag(value) {\n      return Object.isObject(value) && Reflect.has(value, Symbol.toStringTag)\n    },\n\n    /**\n     * The function checks if a value is either `undefined` or `null`.\n     *\n     * @param {any} value - The parameter \"value\" is a variable that can hold\n     * any value.\n     * @returns {boolean} `true` if the value is either `undefined` or `null`,\n     * and `false` otherwise.\n     */\n    isNullDefined(value) {\n      return value === undefined || value === null\n    },\n\n    /**\n     * The `ifNullDefined` function checks if a given value is either `null` or\n     * `undefined` and returns one of two provided values based on the result.\n     * This function is a convenience method for performing conditional\n     * operations based on the type of a value.\n     *\n     * @param {any} value - The value to be checked. If this is either `null`\n     * or `undefined`, `thenValue` is returned, otherwise `elseValue`\n     * is returned.\n     * @param {function | any} thenValue - The value to be returned if `value`\n     * is either `null` or `undefined`.\n     * @param {function | any} elseValue - The value to be returned if `value`\n     * is not either `null` or `undefined`.\n     * @returns {*} Returns `thenValue` if `value` is either `null` or\n     * `undefined`, otherwise returns `elseValue`.\n     *\n     * @example\n     * // Suppose we have a null value and a defined value\n     * let nullValue = null;\n     * let definedValue = \"I'm defined\";\n     *\n     * // Using ifNullDefined\n     * // Output: 'Null or Undefined'\n     * console.log(\n     *   Object.ifNullDefined(nullValue, 'Null or Undefined', 'Defined')\n     * );\n     *\n     * // Output: 'Defined'\n     * console.log(\n     *   Object.ifNullDefined(definedValue, 'Null or Undefined', 'Defined')\n     * );\n     */\n    ifNullDefined(value, thenValue, elseValue) {\n      return isThenElse(this.isNullDefined(value), thenValue, elseValue);\n    },\n\n    /**\n     * Checks if the provided value is an object.\n     *\n     * This function checks if the provided value is an instance of an Object\n     * or if the value is truthy and its type is 'object'. This is used to\n     * determine if a value can have properties and methods like an object.\n     *\n     * @param {any} value - The value to be checked.\n     * @returns {boolean} Returns `true` if the value is an object, `false`\n     * otherwise.\n     *\n     * @example\n     * // Using a string\n     * console.log(isObject('Hello, world!')); // Output: false\n     *\n     * // Using an object\n     * console.log(isObject({ key: 'value' })); // Output: true\n     *\n     * // Using null\n     * console.log(isObject(null)); // Output: false\n     */\n    isObject(value) {\n      return value instanceof Object || value && typeof value === 'object'\n    },\n\n    /**\n     * Determines if the provided value is an object. This method checks whether\n     * the value is an instance of `Object` or if its type is 'object'. It's a\n     * utility method for type-checking, ensuring that a value is an object\n     * before performing operations that are specific to objects.\n     *\n     * @param {*} value - The value to be checked.\n     * @returns {boolean} - Returns `true` if the value is an object,\n     * otherwise `false`.\n    },\n    isObject(value) {\n      return value && (value instanceof Object || typeof value === 'object');\n    },\n\n    /**\n     * Checks to see if the supplied value is a primitive value.\n     *\n     * @param {any} value the value to test to see if it is a primitive value type\n     * @returns true if the object is considered widely to be a primitive value,\n     * false otherwise.\n     */\n    isPrimitive(value) {\n      // Check for null as a special case because typeof null\n      // is 'object'\n      if (value === null) {\n        return true;\n      }\n\n      // Check for other primitives\n      switch (typeof value) {\n        case 'string':\n        case 'number':\n        case 'bigint':\n        case 'boolean':\n        case 'undefined':\n        case 'symbol':\n          return true;\n        default:\n          return false;\n      }\n    },\n\n    /**\n     * Executes a conditional function based on whether the provided value is\n     * primitive or not. This method first checks if the value is primitive\n     * using the `isPrimitive` method. If it is, it returns the `thenValue`,\n     * otherwise it returns the `elseValue`.\n     *\n     * @param {any} value - The value to be checked.\n     * @param {function | any} thenValue - The value to return if `value` is\n     * primitive.\n     * @param {function | any} elseValue - The value to return if `value` is\n     * not primitive.\n     * @returns {*} - Returns `thenValue` if the value is primitive, otherwise\n     * `elseValue`.\n     *\n     * @example\n     * // returns 1\n     * ifPrimitive('hello', 1, 2)\n     * // returns 2\n     * ifPrimitive({a: 'hello'}, 1, 2)\n     */\n    ifPrimitive(value, thenValue, elseValue) {\n      return isThenElse(this.isPrimitive(value), thenValue, elseValue)\n    },\n\n    /**\n     * Checks if the given value is a valid key for an object. In JavaScript, a\n     * valid key can be either a string or a symbol. This method is useful for\n     * validating object keys before using them in operations like setting or\n     * getting object properties.\n     *\n     * @param {*} value - The value to be checked.\n     * @returns {boolean} - Returns `true` if the value is a valid object key\n     * (string or symbol), otherwise `false`.\n     */\n    isValidKey(value) {\n      return (typeof value === 'string' || typeof value === 'symbol');\n    },\n\n    /**\n     * Executes a conditional function based on whether the provided\n     * value is a valid key for an object. This method first checks if\n     * the value is a valid key using the `isValidKey` method. If it is,\n     * it returns the `thenValue`, otherwise it returns the `elseValue`.\n     *\n     * @param {any} value - The value to be checked.\n     * @param {function | any} thenValue - The value to return if\n     * `value` is a valid key.\n     * @param {function | any} elseValue - The value to return if\n     * `value` is not a valid key.\n     * @returns {any} - Returns `thenValue` if the value is a valid key,\n     * otherwise `elseValue`.\n     *\n     * @example\n     * // returns 1\n     * ifValidKey('name', 1, 2)\n     * // returns 2\n     * ifValidKey(123, 1, 2)\n     */\n    ifValidKey(value, thenValue, elseValue) {\n      return isThenElse(this.isValidKey(value), thenValue, elseValue)\n    },\n\n    /**\n     * A symbol constant defined on Object that can be used to reference\n     * storage for an accessor descriptor created with Object.add() or\n     * other descriptor assigning and creation methods used by this extension.\n     *\n     * The value assigned here is actually another symbol but one generated\n     * by {@link Symkeys} for uniqueness and has access to data storage.\n     *\n     * @returns {Symbol} - Returns a symbol for the descriptor storage.\n     *\n     * @example\n     * // returns Symbol(@nejs.object.descriptor.storage)\n     * kDescriptorStore\n     *\n     * // add descriptor value to an object\n     * const object = {}\n     * Object.add({object, key: 'name', type: 'accessor'})\n     * object.name = 'Jane Doe'\n     *\n     * // Value assigned here is another symbol with its own storage generated\n     * // by Symkeys. Description might be '@nejs.descriptor.store #234sdafj'\n     * object[Object.kDescriptorStore]\n     *\n     * // But its nested data can be accessed using the '.data' getter\n     * object[Object.kDescriptorStore].data // { name: 'Jane Doe' }\n     */\n    get kDescriptorStore() {\n      return Symbol.for('@nejs.object.descriptor.storage')\n    },\n\n    /**\n     * Creates an object with predefined keys and descriptors. This method is\n     * useful for creating objects with specific properties and behaviors.\n     *\n     * @param {Array|Object} keys - An array of keys or an object where keys\n     * are the object's own properties. If an array is provided, each key will\n     * be assigned the `defaultValue`. If an object is provided, its own\n     * properties will be used as keys and their corresponding values as values.\n     * @param {*} [defaultValue=undefined] - The default value for each key.\n     * @param {string} [definedAs='data'] - Defines how the properties are\n     * defined. If 'data', properties are defined with a value. If 'accessor',\n     * properties are defined with get and set accessors.\n     * @param {Object} [accessorMeta={ get: undefined, set: undefined,\n     * thisArg: undefined }] - An object containing the get and set accessors\n     * and the `thisArg` to bind to the accessors.\n     * @param {Object} [descriptorBase={ enumerable: true, configurable: true }]\n     * - The base descriptor for the properties.\n     * @param {Object} [extraDescriptors=undefined] - Extra descriptors to be\n     * added to the object.\n     * @param {Object} [prototype=Object.prototype] - The prototype of the\n     * created object.\n     * @returns {Object} - Returns the created object.\n     *\n     * @example\n     * // returns { name: undefined }\n     * prekeyed(['name'])\n     * // returns { name: 'John' }\n     * prekeyed({ name: 'John' })\n     * // returns { name: 'John' }\n     * prekeyed(['name'], 'John')\n     */\n    prekeyed(\n      keys,\n      defaultValue = undefined,\n      definedAs = ['data', 'accessor'][0],\n      accessorMeta = { get: undefined, set: undefined, thisArg: undefined },\n      descriptorBase = { enumerable: true, configurable: true },\n      extraDescriptors = undefined,\n      prototype = Object.prototype\n    ) {\n      const object = Object.create(prototype, extraDescriptors)\n      let mapped = {}\n\n      if (Array.isArray(keys)) {\n        mapped = keys.reduce((a, k) => ({ ...a, [k]: defaultValue }), {})\n      }\n      else if (keys && typeof keys === 'object') {\n        Object.assign(mapped, keys)\n      }\n      else {\n        console.warn('skipping')\n        return object\n      }\n\n      for (const [key, value] of Object.entries(mapped)) {\n        let symKey = Symbol.for(`${key}#${Math.random().toString(36).slice(2)}`)\n        let suppliedValue = mapped[key] ?? defaultValue\n        if (definedAs === 'accessor' && accessorMeta.get === undefined) {\n          Object.defineProperty(\n            object, symKey, {\n              value: suppliedValue, enumerable: false, configurable: true\n            }\n          )\n          accessorMeta.thisArg = object\n        }\n\n        let descriptorRest = definedAs === 'data'\n          ? { value: value ?? defaultValue, writable: true }\n          : {\n              get: accessorMeta.get ?? function()  { return this[symKey] },\n              set: accessorMeta.set ?? function(v) { this[symKey] = v }\n            }\n\n        if (accessorMeta.thisArg) {\n          descriptorRest.get = descriptorRest.get.bind(accessorMeta.thisArg)\n          descriptorRest.set = descriptorRest.set.bind(accessorMeta.thisArg)\n        }\n\n        Object.defineProperty(\n          object, key, { ...descriptorBase, ...descriptorRest }\n        )\n      }\n\n      return object\n    },\n\n    /**\n     * Strips an object down to only the keys specified. Optionally, any\n     * accessors can be made to retain their context on the source object.\n     *\n     * @param {object} object the object to pare down\n     * @param {Array<string|symbol>} keys the keys that should appear in the\n     * final reduced object\n     * @param {boolean} [bindAccessors = true] if this value is true then any\n     * accessors from the source object will continue to have their `this`\n     * value bound to the source. If the getter or setter on that object is\n     * defined using an arrow function, this will not work as intended.\n     * @returns {object} an object containing only the keys and symbols\n     * specified in the `keys` parameter.\n     */\n    stripTo(object, keys, bindAccessors = true) {\n      if (!object || typeof object !== 'object') {\n        throw new TypeError(\n          'Object.stripTo requires an object to strip. Received',\n          object\n        );\n      }\n\n      const result = {};\n\n      if (!Array.isArray(keys)) {\n        return result;\n      }\n\n      for (let key of keys) {\n        if (Reflect.has(object, key)) {\n          const originalDescriptor = Object.getOwnPropertyDescriptor(object, key);\n          const descriptor = { ...originalDescriptor };\n\n          if (\n            typeof descriptor.get === 'function' ||\n            typeof descriptor.set === 'function'\n          ) {\n            if (bindAccessors) {\n              descriptor.get = descriptor.get?.bind(object);\n              descriptor.set = descriptor.set?.bind(object);\n            }\n          }\n\n          Object.defineProperty(result, key, descriptor);\n        }\n      }\n\n      return result;\n    },\n\n    withProperties(prototype, ...properties) {\n      const props = properties.filter(p => p instanceof Property);\n      const possible = properties.filter(p => Array.isArray(p))\n\n      if (possible.length) {\n        for (const [key, descriptorOrDataOrAccessorArgs, ...rest] of possible) {\n          // if arg[1] is a descriptor\n          if (Property.is.descriptor(descriptorOrDataOrAccessorArgs)) {\n            props.push(new Property(key, descriptorOrDataOrAccessorArgs))\n          }\n          else {\n            const { get, set } = descriptorOrDataOrAccessorArgs;\n            const args = [key, descriptorOrDataOrAccessorArgs, ...rest];\n            if (get || set) {\n              props.push(Property.accessor(...args))\n            }\n            else {\n              props.push(Property.data(...args))\n            }\n          }\n        }\n      }\n\n      const object = Object.create(prototype ?? Object.prototype);\n      const sorted = props.toSorted(\n        (a,b) => a.key < b.key ? -1 : (a.key > b.key ? 1 : 0)\n      );\n      for (const property of sorted) {\n        property.apply(object);\n      }\n\n      Property.data(Symbol.for('properties'), sorted).apply(object);\n      return object;\n    }\n  },\n});\n\nconst {\n  isObject: pIsObject,            ifObject: pIfObject,\n  isNullDefined: pIsNullDefined,  ifNullDefined: pIfNullDefined,\n  isPrimitive: pIsPrimitive,      ifPrimitive: pIfPrimitive,\n  isValidKey: pIsValidKey,        ifValidKey: pIfValidKey,\n  hasStringTag: pHasStringTag,    getStringTag: pGetStringTag,\n  stripTo: pStripTo,\n\n} = ObjectExtensions.patches;\n\n/**\n * `ObjectPrototypeExtensions` is a constant that applies a patch to the\n * Object prototype. This patch extends the Object prototype with additional\n * methods and properties, enhancing its functionality.\n *\n * The `Patch` function takes two arguments: the target object to be patched\n * (in this case, `Object.prototype`), and an object containing the methods\n * and properties to be added to the target object.\n *\n * @example\n * // Using a method added by ObjectPrototypeExtensions\n * const obj = {};\n * console.log(obj.isObject()); // Output: true\n *\n * @const\n * @type {Patch}\n * @memberof module:object.extensions\n */\nexport const ObjectPrototypeExtensions = new Patch(Object.prototype, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Retrieves the prototype chain entries of the current object.\n     *\n     * This method traverses the prototype chain of the current object\n     * (`this`) and collects an array of entries. Each entry is a pair\n     * consisting of the prototype object and its property descriptors.\n     *\n     * The property descriptors are obtained using the `Reflect.ownKeys`\n     * method and the `Object.getOwnPropertyDescriptor` function.\n     *\n     * @returns {Array} An array of entries, where each entry is a pair\n     * consisting of a prototype object and its property descriptors.\n     *\n     * @example\n     * const obj = Object.create({ foo: 'bar' });\n     * console.log(obj.getPrototypeChainEntries());\n     * // Output: [[{ foo: 'bar' }, { foo: { value: 'bar', writable: true, enumerable: true, configurable: true } }], [Object.prototype, { ... }]]\n     */\n    getPrototypeChainEntries() {\n      return ObjectExtensions.patches.getPrototypeChainEntries(this)\n    },\n\n    /**\n     * Determines if the current value is an object.\n     *\n     * This method checks whether the current value is an object,\n     * excluding null. It is a convenience wrapper around the\n     * `pIsObject` function from the `ObjectExtensions` patch.\n     *\n     * @name isObject\n     * @type {function}\n     * @memberof Object.prototype\n     * @returns {boolean} `true` if the current value is an object\n     * (excluding null), `false` otherwise.\n     *\n     * @example\n     * const obj = {};\n     * console.log(obj.isObject());\n     * // Output: true\n     *\n     * const str = \"hello\";\n     * console.log(str.isObject());\n     * // Output: false\n     *\n     * console.log(null.isObject());\n     * // Output: false\n     */\n    get isObject() {\n      return pIsObject(this)\n    },\n\n    /**\n     * Checks if the current value is an object and returns one of two\n     * provided values based on the result. This function is a convenience\n     * method for performing conditional operations based on the type of\n     * the current value.\n     *\n     * @name ifObject\n     * @type {function}\n     * @memberof Object.prototype\n     * @param {function | any} thenValue - The value to be returned if the\n     * current value is an object (excluding null).\n     * @param {function | any} elseValue - The value to be returned if the\n     * current value is not an object or is null.\n     * @returns {*} Returns `thenValue` if the current value is an object\n     * (excluding null), otherwise returns `elseValue`.\n     *\n     * @example\n     * const obj = {};\n     * console.log(obj.ifObject('Object', 'Not an object'));\n     * // Output: 'Object'\n     *\n     * const str = \"hello\";\n     * console.log(str.ifObject('Object', 'Not an object'));\n     * // Output: 'Not an object'\n     *\n     * console.log(null.ifObject('Object', 'Not an object'));\n     * // Output: 'Not an object'\n     */\n    ifObject(thenValue, elseValue) {\n      return pIfObject(this, thenValue, elseValue)\n    },\n\n    /**\n     * Checks if the current value is either `null` or `undefined`.\n     *\n     * @name isNullDefined\n     * @type {boolean}\n     * @memberof Object.prototype\n     * @returns {boolean} Returns `true` if the current value is either\n     * `null` or `undefined`, `false` otherwise.\n     *\n     * @example\n     * const obj = null;\n     * console.log(obj.isNullDefined);\n     * // Output: true\n     *\n     * const str = \"hello\";\n     * console.log(str.isNullDefined);\n     * // Output: false\n     */\n    get isNullDefined() {\n      return pIsNullDefined(this)\n    },\n\n    /**\n     * Checks if the current value is either `null` or `undefined` and\n     * returns one of two provided values based on the result.\n     *\n     * @name ifNullDefined\n     * @type {function}\n     * @memberof Object.prototype\n     * @param {function | any} thenValue - The value to be returned if the\n     * current value is either `null` or `undefined`.\n     * @param {function | any} elseValue - The value to be returned if the\n     * current value is not `null` or `undefined`.\n     * @returns {*} Returns `thenValue` if the current value is either\n     * `null` or `undefined`, otherwise returns `elseValue`.\n     *\n     * @example\n     * const obj = null\n     * console.log(obj.ifNullDefined('Null or Undefined', 'Defined'))\n     * // Output: 'Null or Undefined'\n     *\n     * const str = \"hello\"\n     * console.log(str.ifNullDefined('Null or Undefined', 'Defined'))\n     * // Output: 'Defined'\n     */\n    ifNullDefined(thenValue, elseValue) {\n      return pIfNullDefined(this, thenValue, elseValue)\n    },\n\n    /**\n     * Checks if the current value is a primitive type.\n     *\n     * Primitive types in JavaScript include `string`, `number`,\n     * `bigint`, `boolean`, `undefined`, `symbol`, and `null`.\n     *\n     * @name isPrimitive\n     * @type {boolean}\n     * @memberof Object.prototype\n     * @returns {boolean} Returns `true` if the current value is a\n     * primitive type, `false` otherwise.\n     *\n     * @example\n     * const str = \"hello\"\n     * console.log(str.isPrimitive)\n     * // Output: true\n     *\n     * const obj = { key: \"value\" }\n     * console.log(obj.isPrimitive)\n     * // Output: false\n     */\n    get isPrimitive() {\n      return pIsPrimitive(this)\n    },\n\n    /**\n     * Checks if the current value is a primitive type and returns one\n     * of two provided values based on the result.\n     *\n     * Primitive types in JavaScript include `string`, `number`,\n     * `bigint`, `boolean`, `undefined`, `symbol`, and `null`.\n     *\n     * @name ifPrimitive\n     * @type {function}\n     * @memberof Object.prototype\n     * @param {function | any} thenValue - The value to be returned if\n     * the current value is a primitive type.\n     * @param {function | any} elseValue - The value to be returned if\n     * the current value is not a primitive type.\n     * @returns {*} Returns `thenValue` if the current value is a\n     * primitive type, otherwise returns `elseValue`.\n     *\n     * @example\n     * const str = \"hello\"\n     * console.log(str.ifPrimitive('Primitive', 'Not Primitive'))\n     * // Output: 'Primitive'\n     *\n     * const obj = { key: \"value\" }\n     * console.log(obj.ifPrimitive('Primitive', 'Not Primitive'))\n     * // Output: 'Not Primitive'\n     */\n    ifPrimitive(thenValue, elseValue) {\n      return pIfPrimitive(this, thenValue, elseValue)\n    },\n\n    /**\n     * Determines if the current value is a valid key for an object.\n     *\n     * A valid key is either a string or a symbol. This method is a\n     * convenience wrapper around the `pIsValidKey` function from the\n     * `ObjectExtensions` patch.\n     *\n     * @name isValidKey\n     * @type {boolean}\n     * @memberof Object.prototype\n     * @returns {boolean} `true` if the current value is a valid key for\n     * an object (i.e., a string or symbol), `false` otherwise.\n     *\n     * @example\n     * const str = \"key\"\n     * console.log(str.isValidKey)\n     * // Output: true\n     *\n     * const sym = Symbol(\"key\")\n     * console.log(sym.isValidKey)\n     * // Output: true\n     *\n     * const num = 42\n     * console.log(num.isValidKey)\n     * // Output: false\n     */\n    get isValidKey() {\n      return pIsValidKey(this)\n    },\n\n    /**\n     * Checks if the current value is a valid key for an object and returns\n     * one of two provided values based on the result. This function is a\n     * convenience method for performing conditional operations based on\n     * the type of the current value.\n     *\n     * A valid key is either a string or a symbol.\n     *\n     * @name ifValidKey\n     * @type {function}\n     * @memberof Object.prototype\n     * @param {function | any} thenValue - The value to be returned if the\n     * current value is a valid key for an object.\n     * @param {function | any} elseValue - The value to be returned if the\n     * current value is not a valid key for an object.\n     * @returns {*} Returns `thenValue` if the current value is a valid key\n     * for an object, otherwise returns `elseValue`.\n     *\n     * @example\n     * const str = \"key\"\n     * console.log(str.ifValidKey('Valid Key', 'Not a Valid Key'))\n     * // Output: 'Valid Key'\n     *\n     * const num = 42\n     * console.log(num.ifValidKey('Valid Key', 'Not a Valid Key'))\n     * // Output: 'Not a Valid Key'\n     */\n    ifValidKey(thenValue, elseValue) {\n      return pIfValidKey(this, thenValue, elseValue)\n    },\n\n    /**\n     * Checks to see if the supplied `value` is both an object, and has the\n     * appropriate symbol defined.\n     *\n     * @param {any} value the value to determine if it contains a defined\n     * `Symbol.toStringTag` defined.\n     * @returns true if the symbol is defined, false otherwise\n     */\n    get hasStringTag() {\n      return pHasStringTag(this)\n    },\n\n    /**\n     * Retrieves the string tag of an object. The string tag is a representation\n     * of the object's type, as defined by its `Object.prototype.toString`\n     * method. This utility method is helpful for getting a more descriptive\n     * type of an object than what is returned by the `typeof` operator,\n     * especially for custom objects.\n     *\n     * @param {*} value - The object whose string tag is to be retrieved.\n     * @param {boolean} strict - if this is set to true, undefined will be\n     * returned whenever a supplied object does not have a\n     * `Symbol.toStringTag` defined, period. if false, the default,\n     * @returns {string} - The string tag of the object, indicating its type.\n     */\n    getStringTag(strict = false) {\n      return pGetStringTag(this, strict)\n    },\n\n    /**\n     * Strips an object down to only the keys specified. Optionally, any\n     * accessors can be made to retain their context on the source object.\n     * This is a passthrough to the static {@link Object.stripTo} function\n     *\n     * @param {Array<string|symbol>} keys the keys that should appear in the\n     * final reduced object\n     * @param {boolean} [bindAccessors = true] if this value is true then any\n     * accessors from the source object will continue to have their `this`\n     * value bound to the source. If the getter or setter on that object is\n     * defined using an arrow function, this will not work as intended.\n     * @returns {object} an object containing only the keys and symbols\n     * specified in the `keys` parameter.\n     */\n    stripTo(keys, bindAccessors = true) {\n      return pStripTo(this, keys, bindAccessors)\n    },\n  },\n})\n\n// NOTE to self; this is repeated here otherwise a circular reference from\n// Object<->Function<->Global occurs. See original source in global.this.js\n// {@see globalThis.isThenElse}\nfunction isThenElse(bv, tv, ev) {\n  if (arguments.length > 1) {\n    var _then = isFunction(tv) ? tv(bv) : tv; if (arguments.length > 2) {\n      var _else = isFunction(ev) ? tv(bv) : ev; return bv ? _then : _else\n    } return bv || _then;\n  } return bv\n}\n\n/**\n * Creates a deep or shallow copy of the provided source objects and merges\n * them into the destination object. The function uses a Set to keep track\n * of visited objects to avoid circular references.\n *\n * @function\n * @name copyObject\n * @param {boolean} deep - If true, performs a deep copy, otherwise performs\n * a shallow copy.\n * @param {object} destination - The object to which properties will be copied.\n * @param {...object} sources - The source object(s) from which properties\n * will be copied.\n * @returns {object} The destination object with the copied properties.\n *\n * @example\n * // Shallow copy\n * const obj1 = { a: 1, b: { c: 2 } };\n * const obj2 = { b: { d: 3 }, e: 4 };\n * const result = copyObject(false, obj1, obj2);\n * console.log(result); // Output: { a: 1, b: { d: 3 }, e: 4 }\n *\n * @example\n * // Deep copy\n * const obj1 = { a: 1, b: { c: 2 } };\n * const obj2 = { b: { d: 3 }, e: 4 };\n * const result = copyObject(true, obj1, obj2);\n * console.log(result); // Output: { a: 1, b: { c: 2, d: 3 }, e: 4 }\n */\nexport function copyObject(deep, destination, ...sources) {\n  const visited = new Set()\n\n  for (const source of sources) {\n    if (source === null || typeof source !== 'object' || visited.has(source)) {\n      continue\n    }\n\n    visited.add(source)\n\n    const keys = Reflect.ownKeys(source)\n    for (const key of keys) {\n      let descriptor\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(source, key)\n      } catch (err) {\n        console.warn(`Failed to get descriptor for key \"${key}\": ${err}`)\n        continue\n      }\n\n      const isDataDesc = Reflect.has(descriptor, 'value')\n      const keyedValue = descriptor?.value\n\n      const conditionsMet = [\n        isDataDesc,\n        keyedValue,\n        typeof keyedValue === 'object',\n        !visited.has(keyedValue)\n      ].every(condition => condition)\n\n      if (conditionsMet) {\n        visited.add(keyedValue)\n\n        const prototype = Object.getPrototypeOf(keyedValue)\n        const descriptors = Object.getOwnPropertyDescriptors(keyedValue)\n        const replacement = Object.create(prototype, descriptors)\n\n        descriptor.value = deep\n          ? copyObject(deep, replacement, keyedValue)\n          : replacement\n      }\n\n      try {\n        Object.defineProperty(destination, key, descriptor)\n      } catch (err) {\n        console.error(`Failed to define property \"${key}\": ${err}`)\n      }\n    }\n  }\n\n  return destination\n}", "import { Patch } from '@nejs/extension'\n\n/**\n * The `ReflectExtensions` class is a patch applied to the built-in JavaScript\n * `Reflect` object. It extends `Reflect` with additional utility methods that\n * enhance its capabilities. These methods provide more advanced ways of\n * interacting with object properties, such as checking for the presence of\n * multiple keys at once (`hasAll`) or verifying if at least one specified key\n * exists in an object (`hasSome`). This class is part of the `@nejs/extension`\n * library and is designed to offer these extended functionalities in a way\n * that is consistent with the existing `Reflect` API, making it intuitive for\n * developers who are already familiar with standard reflection methods in\n * JavaScript.\n */\nexport const ReflectExtensions = new Patch(Reflect, {\n  /**\n   * The function checks if an object has all the specified keys.\n   *\n   * @param object - The `object` parameter is the object that we want to\n   * check if it has all the specified keys.\n   * @param keys - The `keys` parameter is a rest parameter, which means\n   * it can accept any number of arguments. In this case, it is expected\n   * to receive multiple keys as arguments.\n   * @returns a boolean value.\n   */\n  hasAll(object, ...keys) {\n    return Object.isObject(object) && (keys.flat(Infinity)\n      .map(key => Reflect.has(object, key))\n      .every(has => has)\n    )\n  },\n\n  /**\n   * The function checks if an object has at least one of the specified keys.\n   *\n   * @param object - The `object` parameter is the object that we want to check\n   * for the presence of certain keys.\n   * @param keys - The `keys` parameter is a rest parameter, which means it can\n   * accept any number of arguments. These arguments are the keys that we want\n   * to check if they exist in the `object`.\n   * @returns The function `hasSome` returns a boolean value indicating whether\n   * at least one of the keys provided as arguments exists in the given object.\n   */\n  hasSome(object, ...keys) {\n    return isObject(object) && (keys.flat(Infinity)\n      .map(key => Reflect.has(object, key))\n      .some(has => has)\n    )\n  },\n\n  /**\n   * The `metadata` method retrieves metadata about a property of an object.\n   * It returns an object containing information about the property, such as\n   * its value, descriptor, and whether it is read-only, assignable, an\n   * accessor, or a data descriptor.\n   *\n   * @param {string} key - The name of the property.\n   * @param {object} [owner=globalThis] - The object that owns the property.\n   * If not provided, it defaults to the global object.\n   * @returns {object|undefined} An object containing metadata about the\n   * property, or `undefined` if the property does not exist or the owner is\n   * not an object.\n   *\n   * @example\n   * const obj = { foo: 'bar' }\n   * const meta = ReflectExtensions.metadata('foo', obj)\n   * console.log(meta.value) // Outputs: 'bar'\n   * console.log(meta.isReadOnly) // Outputs: false\n   */\n  metadata(key, owner = globalThis) {\n    const args = [{key}, {owner}]\n    const variants = applyVariants(args)()\n    if (variants.check(0)) {\n      key = variants.object.key\n      owner = variants.object.owner\n    }\n\n    const descriptor = isObject(owner) && isValidKey(key)\n      ? Object.getOwnPropertyDescriptor(owner, key)\n      : undefined\n\n    const value = () => descriptor?.get?.bind(owner)?.() ?? owner[key]\n\n    if (!descriptor) {\n      return undefined\n    }\n\n    const meta = {\n      /**\n       * A getter method that returns the owner of the property.\n       * The owner is the object that owns the property.\n       *\n       * @returns {object} The owner of the property.\n       *\n       * @example\n       * const obj = { foo: 'bar' }\n       * const meta = Reflect.metadata('foo', obj)\n       * console.log(meta.owner) // Outputs: obj\n       */\n      get owner() { return owner },\n\n      /**\n       * A getter method that returns the key of the property.\n       * The key is the name of the property.\n       *\n       * @returns {string} The key of the property.\n       *\n       * @example\n       * const obj = { foo: 'bar' }\n       * const meta = Reflect.metadata('foo', obj)\n       * console.log(meta.key) // Outputs: 'foo'\n       */\n      get key() { return key },\n\n      /**\n       * A getter method that returns the value of the property.\n       * The value is obtained by invoking the `value` function.\n       *\n       * @returns {*} The value of the property.\n       *\n       * @example\n       * const obj = { foo: 'bar' }\n       * const meta = Reflect.metadata('foo', obj)\n       * console.log(meta.value) // Outputs: 'bar'\n       */\n      get value() { return value() },\n\n      /**\n       * A getter method that returns the descriptor of the property.\n       * The descriptor is an object that describes a property's configuration.\n       * It includes properties like value, writable, enumerable, configurable,\n       * get, and set.\n       *\n       * @returns {object} The descriptor of the property.\n       *\n       * @example\n       * const obj = { foo: 'bar' }\n       * const meta = Reflect.metadata('foo', obj)\n       * console.log(meta.descriptor)\n       *\n       * // Outputs: {\n       * //   value: 'bar',\n       * //   writable: true,\n       * //   enumerable: true,\n       * //   configurable: true\n       * // }\n       */\n      get descriptor() { return descriptor },\n\n      /**\n       * A getter method that checks if the property is read-only.\n       * A property is considered read-only if it is an accessor property\n       * (i.e., it has a getter or a setter) and it does not have a setter.\n       * This means that the property can be read, but not written to.\n       *\n       * @returns {boolean} `true` if the property is read-only,\n       * `false` otherwise.\n       *\n       * @example\n       * const obj = {\n       *   get foo() { return 'bar' }\n       * }\n       * const meta = Reflect.metadata('foo', obj)\n       * console.log(meta.isReadOnly) // Outputs: true\n       */\n      get isReadOnly() {\n        return this.isAccessor && !descriptor?.set\n      },\n\n      /**\n       * A getter method that checks if the property is assignable.\n       * A property is considered assignable if it is either configurable\n       * or writable. Configurable properties can be modified and deleted,\n       * while writable properties can have their values changed.\n       *\n       * @returns {boolean} `true` if the property is assignable,\n       * `false` otherwise.\n       *\n       * @example\n       * const obj = { foo: 'bar' }\n       * const meta = Reflect.metadata('foo', obj)\n       * console.log(meta.isAssignable) // Outputs: true\n       */\n      get isAssignable() {\n        return descriptor?.configurable ?? descriptor?.writable\n      },\n\n      /**\n       * A getter method that checks if the property is an accessor.\n       * An accessor property is a property that has a getter method, a setter\n       * method, or both. This method returns `true` if the property has either\n       * a getter or a setter, and `false` otherwise.\n       *\n       * @returns {boolean} `true` if the property is an accessor,\n       * `false` otherwise.\n       *\n       * @example\n       * const obj = {\n       *   get foo() { return 'bar' },\n       *   set foo(value) { console.log('Setting foo to', value) }\n       * }\n       * const meta = Reflect.metadata('foo', obj)\n       * console.log(meta.isAccessor) // Outputs: true\n       */\n      get isAccessor() {\n        return !!(this?.descriptor?.get || this?.descriptor?.set)\n      },\n\n      /**\n       * A getter method that checks if the property is a data property.\n       * A data property is a property that has a value and can be written to.\n       * This method returns `true` if the property has a value or is writable,\n       * and `false` otherwise.\n       *\n       * @returns {boolean} `true` if the property is a data property,\n       * `false` otherwise.\n       *\n       * @example\n       * const obj = { foo: 'bar' }\n       * const meta = Reflect.metadata('foo', obj)\n       * console.log(meta.isData) // Outputs: true\n       */\n      get isData() {\n        return !!(this?.descriptor?.value || this?.descriptor?.writable)\n      },\n    }\n\n    return meta\n  },\n\n  /**\n   * Fetches all descriptors of an object, including those mapped to a\n   * symbol descriptor value.\n   *\n   * @param {object} object the object from whose descriptors need to be\n   * retrieved.\n   * @returns {object} with keys mapped to object descriptors\n   * @throws {TypeError} if the supplied `object` is null or not an object\n   * a TypeError exception will be thrown\n   */\n  ownDescriptors(object) {\n    if (!isObject(object)) {\n      throw new TypeError('The supplied object must be non-null and an object')\n    }\n\n    const result = {}\n\n    const keys = Reflect.ownKeys(object)\n\n    for (const key of keys) {\n      result[key] = Object.getOwnPropertyDescriptor(key)\n    }\n\n    return result\n  },\n\n  /**\n   * Retrieves an array of [key, descriptor] pairs for each property of the\n   * provided object. This method is akin to `Object.entries` but includes\n   * property descriptors instead of the property values. It's useful for cases\n   * where you need detailed information about properties, including their\n   * configurability, enumerability, and accessors.\n   *\n   * @param {object} object - The object whose property entries are to be\n   * retrieved.\n   * @returns {Array} An array of [key, descriptor] pairs, where each pair\n   * consists of the property name (key) and its descriptor. Returns an empty\n   * array if the input is not a valid object.\n   */\n  entries(object) {\n    if (!object || typeof object !== 'object') { return [] }\n\n    return Reflect.ownKeys(object).map(key => [\n      key, Object.getOwnPropertyDescriptor(object, key)\n    ])\n  },\n\n  /**\n   * Retrieves an array of values from the property descriptors of the given\n   * object. This method works similarly to `Object.values` but operates on\n   * property descriptors instead. It's useful when you need the values of\n   * properties including getters, setters, and other descriptor-specific\n   * attributes.\n   *\n   * @param {object} object - The object whose property values are to be\n   * retrieved.\n   * @returns {Array} An array of values extracted from the object's property\n   * descriptors. The values correspond to the `value` attribute in each\n   * property's descriptor. Returns an empty array if the input is not a valid\n   * object.\n   */\n  values(object) {\n    return Reflect.entries.map(([,value]) => value)\n  },\n})\n\nfunction isObject(value) {\n  return value && typeof value === 'object'\n}\n\nfunction isValidKey(value) {\n  return ['string', 'symbol'].some(type => typeof value === type)\n}\n\nfunction applyVariants(thisArg) {\n  return ((function variants() {\n    const keys = this.map(o => Object.keys(o)?.[0])\n    const entries = this.map(o => Object.entries(o)?.[0])\n    const object = entries.reduce((acc,[key, value]) => {\n      acc[key] = value;\n      return acc;\n    }, {})\n\n    const result = {\n      order: keys,\n      entries: entries,\n      object: object,\n    }\n\n    Object.defineProperty(result, 'check', {\n      value(position) {\n        if (\n          typeof position !== 'number' &&\n          position >= 0 &&\n          position < this.order.length\n        ) {\n          return false\n        }\n\n        const value = this.entries[position][1]\n\n        if (typeof value === 'object' && value) {\n          if (Object.keys(value).every(key => ~this.order.indexOf(key))) {\n            return true\n          }\n        }\n\n        return false\n      },\n      enumerable: false,\n      configurable: true\n    })\n\n    return result\n  }).bind(thisArg))\n}", "import { Patch } from '@nejs/extension'\n\nexport const RegExpExtensions = new Patch(RegExp, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Generates a regular expression pattern that matches any character.\n     *\n     * This method creates a regular expression pattern that matches any\n     * character. The pattern can be configured to be greedy or non-greedy,\n     * and to include or exclude newline characters.\n     *\n     * @param {boolean} [greedy=false] - If true, the pattern will be greedy,\n     * meaning it will match as many characters as possible. If false, the\n     * pattern will be non-greedy, meaning it will match as few characters\n     * as possible.\n     * @param {boolean} [includeNewlines=false] - If true, the pattern will\n     * include newline characters ('\\n' and '\\r'). If false, newline\n     * characters will be excluded from the pattern.\n     * @returns {string} - The generated regular expression pattern.\n     *\n     * @example\n     * // Generate a non-greedy pattern that excludes newlines\n     * console.log(anything())  // Output: '[.]*?'\n     *\n     * @example\n     * // Generate a greedy pattern that includes newlines\n     * console.log(anything(true, true))  // Output: '[.\\\\n\\\\r]*'\n     */\n    anything(greedy = false, includeNewlines = false) {\n      return `[.${includeNewlines ? '\\\\n\\\\r' : ''}]*${greedy ? '' : '?'}`\n    },\n\n    /**\n     * Creates a non-capturing group in a regular expression.\n     *\n     * This method wraps the provided string in a non-capturing group,\n     * which is denoted by the syntax `(?:...)` in a regular expression.\n     * Non-capturing groups match the pattern inside the group but do not\n     * capture the matched content for later use.\n     *\n     * @param {string} string - The string to be wrapped in a non-capturing group.\n     * @returns {string} - The string wrapped in a non-capturing group.\n     *\n     * @example\n     * // Suppose we have a string 'abc'\n     * const str = 'abc'\n     *\n     * // Using `nonCaptureGroup`\n     * console.log(nonCaptureGroup(str))  // Output: '(?:abc)'\n     */\n    nonCaptureGroup(string) {\n      return `(?:${string})`\n    },\n\n    /**\n     * Creates a capturing group in a regular expression.\n     *\n     * This method wraps the provided string in a capturing group,\n     * which is denoted by the syntax `(...)` in a regular expression.\n     * Capturing groups match the pattern inside the group and capture\n     * the matched content for later use.\n     *\n     * @param {string} string - The string to be wrapped in a capturing group.\n     * @returns {string} - The string wrapped in a capturing group.\n     *\n     * @example\n     * // Suppose we have a string 'abc'\n     * const str = 'abc'\n     *\n     * // Using `captureGroup`\n     * console.log(captureGroup(str))  // Output: '(abc)'\n     */\n    captureGroup(string) {\n      return `(${string})`\n    },\n\n    /**\n     * Creates a regular expression pattern that matches any one of the\n     * provided strings.\n     *\n     * This method takes any number of strings as arguments, and returns a\n     * string that represents a regular expression pattern. The pattern\n     * matches any one of the provided strings. The strings are joined\n     * together with the '|' character, which represents the OR operator\n     * in regular expressions.\n     *\n     * @param {...string} strings - The strings to be included in the pattern.\n     * @returns {string} - A string representing a regular expression pattern\n     * that matches any one of the provided strings.\n     *\n     * @example\n     * // Suppose we have strings 'abc', 'def', and 'ghi'\n     * const str1 = 'abc'\n     * const str2 = 'def'\n     * const str3 = 'ghi'\n     *\n     * // Using `oneOf`\n     * console.log(oneOf(str1, str2, str3))  // Output: 'abc|def|ghi'\n     */\n    oneOf(...strings) {\n      return strings.join('|')\n    },\n\n    /**\n     * Creates a regular expression pattern that matches zero or more\n     * occurrences of the provided string.\n     *\n     * This method wraps the provided string in a non-capturing group,\n     * which is denoted by the syntax `(?:...)` in a regular expression,\n     * and appends the `*` character, which represents zero or more\n     * occurrences in regular expressions.\n     *\n     * @param {string} string - The string to be matched zero or more times.\n     * @returns {string} - A string representing a regular expression pattern\n     * that matches zero or more occurrences of the provided string.\n     *\n     * @example\n     * // Suppose we have a string 'abc'\n     * const str = 'abc'\n     *\n     * // Using `zeroOrMore`\n     * console.log(zeroOrMore(str))  // Output: '(?:abc)*'\n     */\n    zeroOrMore(string) {\n      return `(?:${string})*`\n    },\n\n    /**\n     * Creates a regular expression pattern that matches zero or one\n     * occurrence of the provided string.\n     *\n     * This method wraps the provided string in a non-capturing group,\n     * which is denoted by the syntax `(?:...)` in a regular expression,\n     * and appends the `?` character, which represents zero or one\n     * occurrence in regular expressions.\n     *\n     * @param {string} string - The string to be matched zero or one time.\n     * @returns {string} - A string representing a regular expression pattern\n     * that matches zero or one occurrence of the provided string.\n     *\n     * @example\n     * // Suppose we have a string 'abc'\n     * const str = 'abc'\n     *\n     * // Using `zeroOrOne`\n     * console.log(zeroOrOne(str))  // Output: '(?:abc)?'\n     */\n    zeroOrOne(string) {\n      return `(?:${string})?`\n    },\n\n    /**\n     * Escapes special characters in a string for use in a regular expression.\n     *\n     * This method checks if the `RegExp.escape` method is available. If it is,\n     * it uses that method to escape the string. If it's not, it uses a polyfill\n     * method to escape the string.\n     *\n     * The polyfill method replaces all special characters in the string with\n     * their escaped equivalents. The special characters are defined by the\n     * regular expression `/[-[\\]{}()*+?.,\\\\^$|#\\s]/g`.\n     *\n     * @param {string} string - The string to be escaped.\n     * @returns {string} - The escaped string.\n     *\n     * @example\n     * // Suppose we have a string with special characters\n     * const str = 'Hello, [World]!'\n     *\n     * // Using `escape` or `escapePolyfill`\n     * console.log(RegExp[RegExp.escape ? 'escapePolyfill' : 'escape'](str))\n     * // Output: 'Hello\\\\, \\\\[World\\\\]\\\\!'\n     */\n    escape(string) {\n      return RegExpEscape(string)\n    },\n\n    /**\n     * Getter method that returns a string 'null'.\n     *\n     * This method is used when you need a string representation of null\n     * in your regular expressions. It simply returns the string 'null'.\n     *\n     * @returns {string} - A string 'null'.\n     *\n     * @example\n     * // Using `null`\n     * console.log(this.null)  // Output: 'null'\n     */\n    get null() {\n      return 'null'\n    },\n\n    /**\n     * Getter method that returns a regular expression string for boolean\n     * values.\n     *\n     * This method uses the `oneOf` method to create a regular expression\n     * string that matches either 'true' or 'false'. This is useful when you\n     * need to match boolean values in a string using a regular expression.\n     *\n     * @returns {string} - A regular expression string that matches 'true'\n     * or 'false'.\n     *\n     * @example\n     * // Using `bool`\n     * const boolRegex = new RegExp(this.bool)\n     * console.log(boolRegex.test('true'))  // Output: true\n     * console.log(boolRegex.test('false')) // Output: true\n     * console.log(boolRegex.test('maybe')) // Output: false\n     */\n    get bool() {\n      return this.oneOf('true', 'false')\n    },\n\n    /**\n     * Generates a regular expression string that matches the symbols of\n     * specified currencies.\n     *\n     * This method uses the Intl API to get the symbols of the specified\n     * currencies and constructs a regular expression string that matches\n     * these symbols. If no specific currencies are provided, it defaults\n     * to all known currencies. If a single currency is provided as a\n     * string, it is converted to an array. If the symbols array is empty\n     * after filtering out unknown currencies, it defaults back to all\n     * known currencies.\n     *\n     * @param {Array|string} [symbols=[['*'], ['USD','GBP']][0]] - The\n     * currencies to include in the regular expression. Can be an array\n     * of currency codes or a single currency code as a string. Defaults\n     * to all known currencies.\n     * @param {string} [locale='en-US'] - The locale to use when getting\n     * the currency symbols. Defaults to 'en-US'.\n     * @returns {string} - A regular expression string that matches the\n     * symbols of the specified currencies.\n     *\n     * @example\n     * // Using `currencySymbols` with default parameters\n     * console.log(this.currencySymbols())\n     * // Output: A regular expression string that matches all known\n     * // currency symbols\n     *\n     * @example\n     * // Using `currencySymbols` with specific currencies\n     * console.log(this.currencySymbols(['USD', 'EUR']))\n     * // Output: A regular expression string that matches the symbols\n     * // of USD and EUR\n     */\n    currencySymbols(symbols = [['*'], ['USD','GBP']][0], locale = 'en-US') {\n      const known = Intl.supportedValuesOf('currency')\n      const has = code => !!~known.indexOf(code)\n\n      if (typeof symbols === 'string' && has(symbols)) {\n        symbols = [symbols]\n      }\n\n      if (!Array.isArray(symbols)) {\n        symbols = known\n      }\n\n      symbols = symbols.filter(symbol => has(symbol))\n      if (!symbols.length) {\n        symbols = known\n      }\n\n      const opts = (currency) => ({style: 'currency', currency})\n      const fmt = (place, currency) => Intl.NumberFormat(place, opts(currency))\n      const codes = (\n        ((symbols.length === 1 && symbols[0] === '*') ? known : symbols)\n          .filter(code => has(code))\n          .map(currency => {\n            const symbol = fmt(locale, currency).formatToParts()?.[0].value\n            return symbol && `(?:${RegExp.escape(symbol)})`\n          })\n          .join('|')\n      )\n\n      return codes\n    },\n\n    /**\n     * Getter method that returns a regular expression string for numbers.\n     *\n     * This method returns a regular expression string that matches both\n     * integer and floating point numbers. The returned regular expression\n     * string is '\\\\d+\\\\.?\\\\d*', which matches one or more digits followed\n     * by an optional decimal point and zero or more digits.\n     *\n     * @returns {string} - A regular expression string that matches numbers.\n     *\n     * @example\n     * // Using `number`\n     * const numberRegex = new RegExp(this.number)\n     * console.log(numberRegex.test('123'))    // Output: true\n     * console.log(numberRegex.test('123.45')) // Output: true\n     * console.log(numberRegex.test('abc'))    // Output: false\n     */\n    get number() {\n      const instance = Object(`\\\\d+\\\\.?\\\\d*`)\n      const self = this\n\n      Object.defineProperties(instance, {\n        // alias for .float\n        any: { get() { return String(instance) } },\n\n        /**\n         * Getter method that returns a regular expression string for floating\n         * point numbers.\n         *\n         * This method returns a regular expression string that matches floating\n         * point numbers. It leverages the 'number' getter method which matches\n         * both integer and floating point numbers. The returned regular expression\n         * string is '\\\\d+\\\\.?\\\\d*', which matches one or more digits followed by\n         * an optional decimal point and zero or more digits.\n         *\n         * @returns {string} - A regular expression string that matches floating\n         * point numbers.\n         *\n         * @example\n         * // Using `float`\n         * const floatRegex = new RegExp(this.float)\n         * console.log(floatRegex.test('123.45')) // Output: true\n         * console.log(floatRegex.test('123'))    // Output: false\n         * console.log(floatRegex.test('abc'))    // Output: false\n         */\n        float: { get() { return String(instance) } },\n\n        // any known locale currency symbol + .float\n        money: { get() { return `(?:${self.currencySymbols()})?${this.float}` }},\n\n        /**\n         * Getter method that returns a regular expression string for integers.\n         *\n         * This method returns a regular expression string that matches integer\n         * numbers. The returned regular expression string is '\\\\d+', which matches\n         * one or more digits.\n         *\n         * @returns {string} - A regular expression string that matches integers.\n         *\n         * @example\n         * // Using `integer`\n         * const integerRegex = new RegExp(this.integer)\n         * console.log(integerRegex.test('123'))    // Output: true\n         * console.log(integerRegex.test('123.45')) // Output: false\n         * console.log(integerRegex.test('abc'))    // Output: false\n         */\n        integer: { get() { return `\\\\d+` } },\n\n        /**\n         * Getter method that returns a regular expression string for pretty\n         * numbers.\n         *\n         * This method returns a regular expression string that matches numbers\n         * with commas or spaces for thousands separators. The returned regular\n         * expression string is '[\\\\d\\\\$]+\\\\.?[\\\\d,\\\\$]*', which matches one or\n         * more digits or dollar signs, followed by an optional decimal point,\n         * and zero or more digits, commas, or dollar signs.\n         *\n         * @returns {string} - A regular expression string that matches pretty\n         * numbers.\n         *\n         * @example\n         * // Using `pretty`\n         * const prettyRegex = new RegExp(this.pretty)\n         * console.log(prettyRegex.test('1,234.56')) // Output: true\n         * console.log(prettyRegex.test('1234.56'))  // Output: true\n         * console.log(prettyRegex.test('1 234.56')) // Output: true\n         * console.log(prettyRegex.test('abc'))      // Output: false\n         */\n        pretty: {\n          value(locale = 'en-US') {\n            const symbols = self.zeroOrMore(self.currencySymbols(['*'], locale))\n            return `${symbols}[\\\\d,]+\\\\.?[\\\\d]*`\n          }\n        },\n\n        /**\n         * Getter method that returns a regular expression string for JavaScript\n         * literals.\n         *\n         * This method returns a regular expression string that matches JavaScript\n         * literals. The returned regular expression string is '[\\\\d_]+', which\n         * matches one or more digits or underscores.\n         *\n         * @returns {string} - A regular expression string that matches JavaScript\n         * literals.\n         *\n         * @example\n         * // Using `jsLiteral`\n         * const jsLiteralRegex = new RegExp(this.jsLiteral)\n         * console.log(jsLiteralRegex.test('123_456')) // Output: true\n         * console.log(jsLiteralRegex.test('abc'))     // Output: false\n         */\n        jsLiteral: { get() { return `[\\\\d_]+` } }\n      })\n\n      return instance\n    },\n\n\n    /**\n     * Getter method that returns a regular expression string for integers.\n     *\n     * This method returns a regular expression string that matches integer\n     * numbers. The returned regular expression string is '\\\\d+', which matches\n     * one or more digits.\n     *\n     * @returns {string} - A regular expression string that matches integers.\n     *\n     * @example\n     * // Using `integer`\n     * const integerRegex = new RegExp(this.integer)\n     * console.log(integerRegex.test('123'))    // Output: true\n     * console.log(integerRegex.test('123.45')) // Output: false\n     * console.log(integerRegex.test('abc'))    // Output: false\n     */\n    get integer() {\n      return `\\\\d+`\n    },\n\n    get string() {\n      return {\n        get doubleQuoted() {\n          return '\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*\"'\n        },\n\n        get singleQuoted() {\n          return \"'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*'\"\n        }\n      }\n    },\n\n    get whitespace() {\n      return `\\\\s*`\n    },\n\n    get comma() {\n      return `,${this.whitespace}`\n    },\n  }\n}, {\n  conditions: {\n    ['escape']() { return !Reflect.has(RegExp, 'escape' )},\n  }\n})\n\n// Simple variant that does not require external dependencies; may not cover\n// all known use cases.\nfunction RegExpEscape(string) {\n  return string.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}", "import { Patch } from '@nejs/extension';\n\n/**\n * `SetExtensions` is a constant that applies a patch to the global\n * `Set` constructor. This patch extends the `Set` with additional\n * methods and properties, enhancing its functionality.\n *\n * The `Patch` function takes two arguments: the target object to be patched\n * (in this case, `Set`), and an object containing the methods and\n * properties to be added to the target object.\n *\n * @example\n * // Using a method added by SetExtensions\n * const set = new Set();\n * console.log(Set.isSet(set)); // Output: true\n *\n * @const\n * @type {Patch}\n * @memberof module:set.extensions\n */\nexport const SetExtensions = new Patch(Set, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Determines if the supplied `value` is a `Set` object. This check\n     * is performed by first looking for the `Symbol.toStringTag` on the\n     * `value` and checking to see if it is equal to the string \"Set\".\n     * If that check fails, `instanceof` is used as a fallback to check\n     * the prototype chain.\n     *\n     * @param {any} value the value that needs to be checked to determine\n     * if it is a `Set` object or not\n     * @returns {boolean} `true` if the supplied `value` is a `Set`\n     * object, `false` otherwise\n     *\n     * @example\n     * const set = new Set()\n     * isSet(set) // true\n     * isSet(new Map()) // false\n     * isSet([]) // false\n     * isSet({}) // false\n     */\n    isSet(value) {\n      return value?.[Symbol.toStringTag] === Set.name || value instanceof Set\n    },\n\n    /**\n     * Conditionally returns a value based on whether the supplied\n     * `value` is a `Set` object or not. If the `value` is a `Set`\n     * object, the `thenValue` will be returned. If it is not a `Set`\n     * object, the `elseValue` will be returned instead.\n     *\n     * @param {any} value the value to check to determine if it is a\n     * `Set` object\n     * @param {any} thenValue the value to return if the supplied\n     * `value` is a `Set` object\n     * @param {any} elseValue the value to return if the supplied\n     * `value` is not a `Set` object\n     * @returns {any} either the `thenValue` or `elseValue` depending\n     * on if the supplied `value` is a `Set` object\n     *\n     * @example\n     * const set = new Set()\n     * const map = new Map()\n     * ifSet(set, 'is a set', 'not a set') // 'is a set'\n     * ifSet(map, 'is a set', 'not a set') // 'not a set'\n     */\n    ifSet(value, thenValue, elseValue) {\n      return isThenElse(this.isSet(value), thenValue, elseValue)\n    },\n  }\n})\n\nconst { isSet: pIsSet } = SetExtensions.patches\n\n/**\n * `SetPrototypeExtensions` is a constant that applies a patch to the\n * prototype of the built-in JavaScript `Set` object. This patch extends the\n * `Set` prototype with additional methods and properties, enhancing its\n * functionality.\n *\n * The `Patch` function takes two arguments: the target object to be patched\n * (in this case, `Set.prototype`), and an object containing the methods and\n * properties to be added to the target object.\n *\n * @example\n * // Using a method added by SetPrototypeExtensions\n * const mySet = new Set();\n * mySet.myNewMethod(); // Calls the new method added by the patch\n *\n * @const\n * @type {Patch}\n * @memberof module:set.extensions\n */\nexport const SetPrototypeExtensions = new Patch(Set.prototype, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Merges multiple iterables into the set. Each element from the iterables\n     * is added to the set, ensuring uniqueness of all elements. This method\n     * mutates the original set.\n     *\n     * @param {...Iterable} iterables - One or more iterable objects (like Set\n     * or Array) whose elements will be added to the set.\n     */\n    concat(...iterables) {\n      for (const iterable of iterables) {\n        if (\n          typeof iterable === 'string' ||\n          !Reflect.has(iterable, Symbol.iterator)\n        ) {\n          this.add(iterable)\n          continue\n        }\n\n        for (const element of iterable) {\n          this.add(element)\n        }\n      }\n    },\n\n    /**\n     * Checks to see if any value within the `Set` loosely equals the supplied\n     * value.\n     *\n     * @param {*} value any value that might be loosely equal to an item in the\n     * set, as opposed to {@link Set.has} which is the equivalent of a strict or\n     * triple equals (`===`) check\n     * @returns {boolean} `true` if any value within the set is loosely equal to\n     * the supplied value, `false` otherwise\n     */\n    contains(value) {\n      for (const element of this) {\n        if (value == element) {\n          return true\n        }\n      }\n\n      return false\n    },\n\n    /**\n     * Checks if every element in the set passes the test implemented by the\n     * provided function. The function is called with each element of the set.\n     * Note: Since sets do not have indices, the index parameter is always NaN.\n     *\n     * @param {Function} everyFn - The function to test each element. Receives\n     * the element, index (always NaN), and the set itself.\n     * @param {Object} [thisArg] - Optional. Value to use as `this` when executing\n     * `everyFn`.\n     * @throws {TypeError} If `everyFn` is not a function.\n     * @returns {boolean} True if every element passes the test, false otherwise.\n     */\n    every(everyFn, thisArg) {\n      if (typeof everyFn !== 'function') {\n        throw new TypeError(\n          `everyFn must be a function! Received ${String(everyFn)}`\n        )\n      }\n\n      let found = 0\n\n      for (const element of this) {\n        if (everyFn.call(thisArg, element, NaN, this)) {\n          found++\n        }\n      }\n\n      return (found === this.size)\n    },\n\n    /**\n     * Finds the first element in the set satisfying the provided testing\n     * function. If no elements satisfy the testing function, undefined is\n     * returned. The function is called with each element of the set.\n     * Note: Since sets do not have indices, the index parameter is always NaN.\n     *\n     * @param {Function} findFn - The function to execute on each element. It\n     * receives the element, index (always NaN), and the set itself.\n     * @param {Object} [thisArg] - Optional. Value to use as `this` when executing\n     * `findFn`.\n     * @throws {TypeError} If `findFn` is not a function.\n     * @returns {*} The first element that satisfies `findFn`, or undefined.\n     */\n    find(findFn, thisArg) {\n      if (typeof findFn !== 'function') {\n        throw new TypeError(\n          `findFn must be a function! Received ${String(findFn)}`\n        )\n      }\n\n      for (const element of this) {\n        const match = findFn.call(thisArg, element, NaN, this)\n        if (match) {\n          return element\n        }\n      }\n\n      return undefined\n    },\n\n    /**\n     * Finds the last element in the set satisfying the provided testing function.\n     * If no elements satisfy the testing function, undefined is returned. The\n     * function is called with each element of the set in reverse order.\n     * Note: Since sets do not have indices, the index parameter is always NaN.\n     *\n     * @param {Function} findFn - The function to execute on each element. It\n     * receives the element, index (always NaN), and the set itself.\n     * @param {Object} [thisArg] - Optional. Value to use as `this` when executing\n     * `findFn`.\n     * @throws {TypeError} If `findFn` is not a function.\n     * @returns {*} The last element that satisfies `findFn`, or undefined.\n     */\n    findLast(findFn, thisArg) {\n      if (typeof findFn !== 'function') {\n        throw new TypeError(\n          `findFn must be a function! Received ${String(findFn)}`\n        )\n      }\n\n      const found = []\n\n      for (const element of this) {\n        const match = findFn.call(thisArg, element, NaN, this)\n        if (match) {\n          found.push(element)\n        }\n      }\n\n      if (found.length) {\n        return found[found.length - 1]\n      }\n\n      return undefined\n    },\n\n    /**\n     * Determines if the current object is a `Set` object.\n     *\n     * This is a getter that uses the `isSet` function from the\n     * `SetExtensions` patch to check if the current object (`this`) is\n     * a `Set` object.\n     *\n     * @type {boolean}\n     * @readonly\n     *\n     * @example\n    * const set = new Set()\n    * console.log(set.isSet) // Output: true\n    *\n    * const notSet = {}\n    * console.log(notSet.isSet) // Output: false\n    */\n   get isSet() {\n     return pIsSet(this)\n   },\n\n   /**\n    * Checks if the current object is a Set and returns the\n    * corresponding value based on the result.\n    *\n    * This method uses the `isThenElse` function from the\n    * `SetExtensions` patch to determine if the current object\n    * (`this`) is a Set. If it is a Set, the `thenValue` is returned.\n    * Otherwise, the `elseValue` is returned.\n    *\n    * @param {any} thenValue - The value to return if the current object\n    * is a Set.\n    * @param {any} elseValue - The value to return if the current object\n    * is not a Set.\n    * @returns {any} The `thenValue` if the current object is a Set, or\n    * the `elseValue` if it is not a Set.\n    *\n    * @example\n    * const set = new Set([1, 2, 3])\n    * console.log(set.ifSet('Is a Set', 'Not a Set')) // 'Is a Set'\n    *\n    * const notSet = {}\n    * console.log(notSet.ifSet('Is a Set', 'Not a Set')) // 'Not a Set'\n    */\n   ifSet(thenValue, elseValue) {\n     return isThenElse(pIsSet(this), thenValue, elseValue)\n   },\n\n    /**\n     * A getter property that returns the number of elements in the set.\n     * This is an alias for the `size` property of the set.\n     *\n     * @returns {number} The number of elements in the set.\n     */\n    get length() {\n      return this.size\n    },\n\n    /**\n     * Creates a new array populated with the results of calling the provided\n     * function on every element in the set. The function is called with each\n     * element of the set. Note: Since sets do not have indices, the index\n     * parameter is always NaN.\n     *\n     * @param {Function} mapFn - The function to execute on each element. It\n     * receives the element, index (always NaN), and the set itself.\n     * @param {Object} [thisArg] - Optional. Value to use as `this` when executing\n     * `mapFn`.\n     * @throws {TypeError} If `mapFn` is not a function.\n     * @returns {Array} A new array with each element being the result of the\n     * `mapFn`.\n     */\n    map(mapFn, thisArg) {\n      if (typeof mapFn !== 'function') {\n        throw new TypeError(\n          `mapFn must be a function! Received ${String(mapFn)}`\n        )\n      }\n\n      const transformed = []\n\n      for (const element of this) {\n        transformed.push(mapFn.call(thisArg, element, NaN, this))\n      }\n\n      return transformed\n    },\n\n    /**\n     * Applies a function against an accumulator and each element in the set to\n     * reduce it to a single value. The function is called with each element of\n     * the set. Note: Since sets do not have indices, the index parameter is\n     * always NaN.\n     *\n     * @param {Function} reduceFn - The function to execute on each element. It\n     * receives the accumulator, element, index (always NaN), and the set itself.\n     * @param {*} initialValue - The initial value to start reducing from.\n     * @param {Object} [thisArg] - Optional. Value to use as `this` when executing\n     * `reduceFn`.\n     * @throws {TypeError} If `reduceFn` is not a function.\n     * @returns {*} The reduced value.\n     */\n    reduce(reduceFn, initialValue, thisArg) {\n      if (typeof reduceFn !== 'function') {\n        throw new TypeError(\n          `reduceFn must be a Function! Received ${String(reduceFn)}`\n        )\n      }\n\n      let accumulator = initialValue\n      for (const element of this) {\n        accumulator = reduceFn.call(thisArg, accumulator, element, NaN, this)\n      }\n\n      return accumulator\n    },\n\n    /**\n     * Tests whether at least one element in the set passes the test implemented\n     * by the provided function. The function is called with each element of the\n     * set. Note: Since sets do not have indices, the index parameter is always NaN.\n     *\n     * @param {Function} someFn - The function to test each element. It receives\n     * the element, index (always NaN), and the set itself.\n     * @param {Object} [thisArg] - Optional. Value to use as `this` when executing\n     * `someFn`.\n     * @throws {TypeError} If `someFn` is not a function.\n     * @returns {boolean} True if at least one element passes the test, false\n     * otherwise.\n     */\n    some(someFn, thisArg) {\n      if (typeof someFn !== 'function') {\n        throw new TypeError(\n          `someFn must be a function! Received ${String(someFn)}`\n        )\n      }\n\n      for (const element of this) {\n        if (someFn.call(thisArg, element, NaN, this)) {\n          return true\n        }\n      }\n\n      return false\n    },\n  },\n})\n\n// NOTE to self; this is repeated here otherwise a circular reference from\n// Object<->Function<->Global occurs. See original source in global.this.js\n// {@see globalThis.isThenElse}\nfunction isThenElse(bv, tv, ev) {\n  if (arguments.length > 1) {\n    var _then = isFunction(tv) ? tv(bv) : tv; if (arguments.length > 2) {\n      var _else = isFunction(ev) ? tv(bv) : ev; return bv ? _then : _else\n    } return bv || _then;\n  } return bv\n}", "import { Patch } from '@nejs/extension'\n\nconst parenthesisPair = ['(', ')']\n\n/**\n * `StringExtensions` is a patch for the JavaScript built-in `String` class. It\n * adds utility methods to the `String` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `String` class with additional\n * utility functions.\n */\nexport const StringExtensions = new Patch(String, {\n  /**\n   * The `isString` method does exactly what one would it expect. It returns\n   * true if the string matches typeof or instanceof as a string.\n   *\n   * @param {*} value checks to see if the `value` is a string\n   * @returns {boolean} `true` if it is a `String`, `false` otherwise\n   */\n  isString(value) {\n    return (\n      value !== null && value !== undefined &&\n      (typeof value === 'string' || value instanceof String)\n    )\n  },\n\n  /**\n   * Conditionally returns a value based on whether the supplied\n   * `value` is a `String` or not. If the `value` is a `String`,\n   * the `thenValue` will be returned. If it is not a `String`,\n   * the `elseValue` will be returned instead.\n   *\n   * @param {any} value the value to check to determine if it is a\n   * `String`\n   * @param {any} thenValue the value to return if the supplied\n   * `value` is a `String`\n   * @param {any} elseValue the value to return if the supplied\n   * `value` is not a `String`\n   * @returns {any} either the `thenValue` or `elseValue` depending\n   * on if the supplied `value` is a `String`\n   *\n   * @example\n   * const str = 'hello'\n   * const num = 42\n   * ifString(str, 'is a string', 'not a string') // 'is a string'\n   * ifString(num, 'is a string', 'not a string') // 'not a string'\n   */\n  ifString(value, thenValue, elseValue) {\n    return isThenElse(this.isString(value), thenValue, elseValue)\n  },\n\n  /**\n   * A getter property that returns a pair of parentheses as an array.\n   * This property can be used when operations require a clear distinction\n   * between the opening and closing parentheses, such as parsing or\n   * matching balanced expressions in strings.\n   *\n   * @returns {[string, string]} An array containing a pair of strings: the\n   * opening parenthesis '(' as the first element, and the closing parenthesis\n   * ')' as the second element.\n   */\n  get parenthesisPair() {\n    return ['(', ')'];\n  },\n\n  /**\n   * A getter property that returns a pair of square brackets as an array.\n   * This property is particularly useful for operations that require a clear\n   * distinction between the opening and closing square brackets, such as\n   * parsing arrays in strings or matching balanced expressions within\n   * square brackets.\n   *\n   * @returns {[string, string]} An array containing a pair of strings: the\n   * opening square bracket '[' as the first element, and the closing square\n   * bracket ']' as the second element.\n   */\n  get squareBracketsPair() {\n    return ['[', ']'];\n  },\n\n  /**\n   * A getter property that returns a pair of curly brackets as an array.\n   * This property is particularly useful for operations that require a clear\n   * distinction between the opening and closing curly brackets, such as\n   * parsing objects in strings or matching balanced expressions within\n   * curly brackets. The returned array consists of the opening curly bracket\n   * '{' as the first element, and the closing curly bracket '}' as the\n   * second element.\n   *\n   * @returns {[string, string]} An array containing a pair of strings: the\n   * opening curly bracket '{' as the first element, and the closing curly\n   * bracket '}' as the second element.\n   */\n  get curlyBracketsPair() {\n    return ['{', '}'];\n  },\n\n  /**\n   * Generates a random string using base 36 (numbers and lowercase letters).\n   * This method is useful when you need a random string that includes both\n   * numbers and letters. The generated string does not include the leading\n   * '0.' that is part of the string representation of a random number in\n   * base 36.\n   *\n   * @returns {string} A random string of characters in base 36.\n   *\n   * @example\n   * const randomStr = StringExtensions.random36();\n   * console.log(randomStr); // Output: \"3n5yzxjkf2o\"\n   */\n  random36() {\n    return Math.random().toString(36).slice(2)\n  },\n\n  /**\n   * Generates a random string using base 16 (hexadecimal numbers).\n   * This method is useful when you need a random string that includes both\n   * numbers and letters in hexadecimal format. The generated string does not\n   * include the leading '0.' that is part of the string representation of a\n   * random number in base 16.\n   *\n   * @returns {string} A random string of characters in base 16.\n   *\n   * @example\n   * const randomStr = StringExtensions.random16();\n   * console.log(randomStr); // Output: \"3a5f4c\"\n   */\n  random16() {\n    return Math.random().toString(16).slice(2)\n  },\n\n  /**\n   * Generates a random RGB color code.\n   *\n   * This method generates a random hexadecimal number, slices off the\n   * leading '0.' and takes the first 6 characters. It then pads the\n   * end of the string with '0' until it is 6 characters long. The\n   * result is a string that can be used as a color code in CSS.\n   *\n   * @param {string} [prefix='#'] - The prefix to prepend to the color\n   * code. Defaults to '#'.\n   *\n   * @returns {string} A random RGB color code.\n   *\n   * @example\n   * const randomColor = StringExtensions.randomRGB();\n   * console.log(randomColor); // Output: \"#3a5f4c\"\n   */\n  randomRGBHex(prefix = '#') {\n    const hex = Math.random().toString(16).slice(2).substring(0,6)\n    return `${prefix}${hex.padEnd(6, '0')}`\n  },\n\n  /**\n   * Generates a random ARGB color code.\n   *\n   * This method generates a random hexadecimal number, slices off the\n   * leading '0.' and takes the first 8 characters. It then pads the\n   * start of the string with '0' until it is 6 characters long and the\n   * end of the string with '0' until it is 8 characters long. The\n   * result is a string that can be used as a color code in CSS.\n   *\n   * @param {string} [prefix='#'] - The prefix to prepend to the color\n   * code. Defaults to '#'.\n   *\n   * @returns {string} A random ARGB color code.\n   *\n   * @example\n   * const randomColor = StringExtensions.randomARGB();\n   * console.log(randomColor); // Output: \"#3a5f4c00\"\n   */\n  randomARGBHex(prefix = '#') {\n    const hex = Math.random().toString(16).slice(2).substring(0,8)\n    return `${prefix}${hex.padStart(6, '0').padEnd(8, '0')}`\n  },\n\n  /**\n   * Generates a random RGBA color code.\n   *\n   * This method generates a random hexadecimal number, slices off the\n   * leading '0.' and takes the first 8 characters. It then pads the\n   * start of the string with '0' until it is 6 characters long and the\n   * end of the string with '0' until it is 8 characters long. The\n   * result is a string that can be used as a color code in CSS.\n   *\n   * @param {string} [prefix='#'] - The prefix to prepend to the color\n   * code. Defaults to '#'.\n   *\n   * @returns {string} A random RGBA color code.\n   *\n   * @example\n   * const randomColor = StringExtensions.randomRGBA();\n   * console.log(randomColor); // Output: \"#3a5f4c00\"\n   */\n  randomRGBAHex(prefix = '#') {\n    const hex = Math.random().toString(16).slice(2).substring(0,8)\n    return `${prefix}${hex.padStart(6, '0').padStart(8, '0')}`\n  },\n\n  /**\n   * Generates a random RGB color code.\n   *\n   * This method generates a random hexadecimal number, slices off the\n   * leading '0.' and pads the end of the string with '0' until it is\n   * 8 characters long. It then parses the first 6 characters into\n   * three separate 2-character strings, each representing a color\n   * component (red, green, blue) in hexadecimal format. These strings\n   * are then converted into decimal format and used to construct an\n   * RGB color code.\n   *\n   * @returns {string} A random RGB color code.\n   *\n   * @example\n   * const randomColor = StringExtensions.randomRGB();\n   * console.log(randomColor); // Output: \"rgb(58,95,76)\"\n   */\n  randomRGB() {\n    const hex = Math.random().toString(16).slice(2).padEnd(8, '0')\n    const red = parseInt(hex.substring(0,2), 16)\n    const green = parseInt(hex.substring(2,4), 16)\n    const blue = parseInt(hex.substring(4, 6), 16)\n    return `rgb(${red}, ${green}, ${blue})`\n  },\n\n  /**\n   * Generates a random RGBA color code with optional forced color values.\n   *\n   * This method generates a random hexadecimal number, slices off the\n   * leading '0.' and pads the end of the string with '0' until it is\n   * 8 characters long. It then parses the first 8 characters into\n   * four separate 2-character strings, each representing a color\n   * component (red, green, blue, alpha) in hexadecimal format. These strings\n   * are then converted into decimal format and used to construct an\n   * RGBA color code.\n   *\n   * If a color component is provided in the `force` parameter, it will\n   * be used instead of a random value for that component.\n   *\n   * @param {Object} force - An object with properties for each color\n   * component (red, green, blue, alpha) that should be forced to a\n   * specific value. If a property is undefined or not provided, a\n   * random value will be used for that component.\n   * @param {number} force.red - The red component (0-255).\n   * @param {number} force.green - The green component (0-255).\n   * @param {number} force.blue - The blue component (0-255).\n   * @param {number} force.alpha - The alpha component (0.0-1.0).\n   *\n   * @returns {string} A random RGBA color code.\n   *\n   * @example\n   * const randomColor = StringExtensions.randomRGBA();\n   * console.log(randomColor); // Output: \"rgba(58,95,76,0.50)\"\n   *\n   * const forcedGreen = StringExtensions.randomRGBA({ green: 255 });\n   * console.log(forcedGreen); // Output: \"rgba(58,255,76,0.50)\"\n   */\n  randomRGBA(\n    force = {\n      red: undefined,\n      green: undefined,\n      blue: undefined,\n      alpha: undefined\n    }\n  ) {\n    const hex = Math.random().toString(16).slice(2).padEnd(8, '0')\n    const red = force.red ?? parseInt(hex.substring(0,2), 16)\n    const green = force.green ?? parseInt(hex.substring(2,4), 16)\n    const blue = force.blue ?? parseInt(hex.substring(4, 6), 16)\n    const alpha = force.alpha ??\n      (parseInt(hex.substring(6, 8), 16) / 255.0) * 1.0\n\n    return `rgba(${red}, ${green}, ${blue}, ${alpha.toFixed(2)})`\n  },\n\n  /**\n   * Applies Select Graphic Rendition (SGR) parameters to a given message for\n   * styling in terminal environments. This function allows for the dynamic\n   * styling of text output using ANSI escape codes. It supports a variety of\n   * modes such as color, brightness, and text decorations like bold or underline.\n   *\n   * @param {string} message The message to be styled.\n   * @param {...string} useModes A series of strings representing the desired\n   * styling modes. Modes can include colors (e.g., 'red', 'blue'), brightness\n   * ('bright'), foreground/background ('fg', 'bg'), and text decorations\n   * ('bold', 'underline'). Modes can be combined in a single string using\n   * commas or passed as separate arguments.\n   *\n   * Colors:\n   * ```\n   * 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'\n   * ```\n   * Color Specifiers:\n   * ```\n   * 'fg' -> foreground   |  'bg' -> background  |  'bright' -> bright colors\n   * ```\n   *\n   * Modes:\n   * ```\n   * 'blink' or 'k' | 'conceal' or 'c' | 'italics' or 'i'  | 'strike' or 's'\n   * 'bold' or 'b'  | 'dim' or 'd'     | 'negative' or 'n' | 'underline' or 'u'\n   * ```\n   *\n   * Examples:\n   * - `sgr('Hello', 'red')` applies red color to 'Hello'.\n   * - `sgr('World', 'green,bold')` applies green color and bold styling\n   *   to 'World'.\n   * - `sgr('Example', 'bluebgbright')` applies bright blue\n   *   background color.\n   *\n   * Short hand syntax is also allowed:\n   * - `sgr('hello', 'biu')` applies bold, italics and underline\n   * - `sgr('hello', 'bi,redfg')` applies bold, italics and red foreground\n   *\n   * As a bonus, there is a secret getter applied to the return string that\n   * allows you to invoke `sgr(...).show` to automatically log the output to\n   * `console.log`. This is done by wrapping the output string in `Object()`\n   * to make it a `String` instance and then adding the property descriptor.\n   * A custom `Symbol` is applied to make it evaluate in nodejs as though it\n   * were a normal string. To strip the extras, wrap the output in `String()`\n   *\n   * @returns {string} The message wrapped in ANSI escape codes corresponding\n   * to the specified modes. The returned string, when printed to a terminal,\n   * displays the styled message. Additional properties are attached to the\n   * result for utility purposes, such as 'show' for immediate console output.\n   */\n  sgr(message, ...useModes) {\n    const colors = Object.assign(\n      ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'],\n      {\n        isBG: a => !!/bg/i.exec(a),\n        isBright: a => !!/bright/i.exec(a),\n        isColor: a => {\n          let color = colors.find(c => new RegExp(c, 'i').exec(a));\n          return [!!color, colors.indexOf(color)];\n        },\n      }\n    );\n\n    const arrayifyString = s => {\n      if (Array.isArray(s)) {\n        let results = [];\n\n        for (const i of s) {\n          results = [ ...results, ...arrayifyString(i) ];\n        }\n\n        return results.flat().filter(i => i.length);\n      }\n\n      if (!s || typeof s !== 'string') {\n        return [''];\n      }\n      else if (s.includes(',')) {\n        return arrayifyString(s.split(','));\n      }\n      else {\n        if (!colors.isColor(s)[0] && s.length > 1) {\n          return [...s];\n        }\n        else return [s];\n      }\n    }\n\n    let modes = arrayifyString(useModes)\n\n    const sgrModes = {\n      blink: ['\\x1b[5m', '\\x1b[25m', 'k'],\n      bold: ['\\x1b[1m', '\\x1b[22m', 'b'],\n      conceal: ['\\x1b[8m', '\\x1b[28m', 'c'],\n      dim: ['\\x1b[2m', '\\x1b[22m', 'd'],\n      italics: ['\\x1b[3m', '\\x1b[23m', 'i'],\n      negative: ['\\x1b[7m', '\\x1b[27m', 'n'],\n      strike: ['\\x1b[9m', '\\x1b[29m', 's'],\n      underline: ['\\x1b[4m', '\\x1b[24m', 'u'],\n    };\n\n    Object.values(sgrModes).forEach(mode => sgrModes[mode[2]] = mode);\n\n    const codes = a => {\n      let open = '', close = '', mode = String(a).toLowerCase();\n      let [_isColor, colorIndex] = colors.isColor(mode);\n\n      if (_isColor) {\n        open = colors.isBG(mode)\n          ? `\\x1b[${colors.isBright(mode) ? 10 : 4}${colorIndex}m`\n          : `\\x1b[${colors.isBright(mode) ? 9 : 3}${colorIndex}m`;\n        close = colors.isBG(mode) ? '\\x1b[49m' : `\\x1b[39m`;\n      }\n      else if (sgrModes[mode]) {\n        open = sgrModes[mode][0];\n        close = sgrModes[mode][1];\n      }\n\n      return [open, close];\n    };\n\n    const onOrder = modes.map(key => codes(key)[0]).join('');\n    const offOrder = modes.map(key => codes(key)[1]).reverse().join('');\n\n    let result = Object(`${onOrder}${message}${offOrder}`)\n\n    Object.defineProperties(result, {\n      show: {\n        get() { console.log(String(this)); return this },\n        enumerable: false,\n      },\n      [Symbol.for('nodejs.util.inspect.custom')]: {\n        value(depth, options, inspect) {\n          return inspect(String(this), options)\n        },\n        enumerable: false,\n      },\n    })\n\n    return result\n  },\n\n  /**\n   * Wraps an object's properties into a formatted string.\n   *\n   * This method takes an object and a set of options to format the\n   * object's properties into a string. It allows customization of\n   * indentation, line endings, maximum line length, and more.\n   *\n   * @param {Object} [object=globalThis] - The object to wrap.\n   * @param {Object} [options={}] - The formatting options.\n   * @param {number} [options.indent=2] - The number of indentation\n   * characters to use.\n   * @param {string} [options.indentCharacter=' '] - The character to use\n   * for indentation.\n   * @param {Array} [options.inspector=[Object, 'getOwnPropertyNames']] -\n   * The inspector to use for retrieving object properties.\n   * @param {string} [options.lineEnding='\\n'] - The line ending character.\n   * @param {number} [options.maxLen=78] - The maximum line length.\n   * @param {Function} [options.perLine=undefined] - A function to apply\n   * per line of output.\n   * @param {Function} [options.perLinePerProperty=undefined] - A function\n   * to apply per property per line of output.\n   * @param {Function} [options.preProcess=undefined] - A function to\n   * preprocess the object's properties.\n   * @param {Function} [options.preReturn=undefined] - A function to apply\n   * to the final output before returning.\n   * @param {string} [options.separator=', '] - The separator to use\n   * between properties.\n   *\n   * @returns {string} The formatted string representation of the object.\n   *\n   * @example\n   * const obj = { a: 1, b: 2, c: 3 }\n   * const wrapped = StringExtensions.wrap(obj, { maxLen: 20 })\n   * console.log(wrapped)\n   * // Output:\n   * // {\n   * //   a: 1,\n   * //   b: 2,\n   * //   c: 3\n   * // }\n   */\n  wrap(\n    objectOrLines,\n    options = {\n      colorProperties: undefined,\n      indent: 2,\n      indentCharacter: ' ',\n      inspector: [Object, 'getOwnPropertyNames'],\n      lineEnding: '\\n',\n      maxLen: 78,\n      perLine: undefined,\n      perLinePerProperty: undefined,\n      preProcess: undefined,\n      preReturn: undefined,\n      separator: ', ',\n    }\n  ) {\n    let {\n      colorProperties = undefined,\n      indent = options?.indent ?? 2,\n      indentCharacter = options?.indentCharacter ?? ' ',\n      inspector = options?.inspector ?? [Object, 'getOwnPropertyNames'],\n      lineEnding = options?.lineEnding ?? '\\n',\n      maxLen = options?.maxLen ?? 78,\n      perLine = options?.perLine ?? undefined,\n      perLinePerProperty = options?.perLinePerProperty ?? undefined,\n      preProcess = options?.preProcess ?? undefined,\n      preReturn = options?.preReturn ?? undefined,\n      separator = options?.separator ?? ', ',\n    } = options ?? {}\n\n    let tab = indent === 0 ? ''\n      : indentCharacter.repeat(Number(indent) || 2)\n    maxLen = 78 - tab.length\n\n    const sgr = this.sgr;\n    const validMapper = f => typeof f === 'function'\n\n    let line = []\n    let getElements = inspector[0][inspector[1]]\n    let values = Array.isArray(objectOrLines)\n      ? objectOrLines : getElements(Object(objectOrLines))\n\n    if (validMapper(preProcess)) {\n      values = preProcess(values)\n    }\n\n    const context = { indent, indentCharacter, lineEnding, maxLen, tab, sgr }\n\n    let finalLines = values.reduce((acc, nextProp) => {\n      let ifCombined = [...line, nextProp].join(separator)\n\n      if ((tab.length + ifCombined.length) <= maxLen) {\n        line.push(nextProp)\n      }\n\n      else {\n        let lineProps = [...line]\n\n        if (validMapper(perLinePerProperty)) {\n          lineProps = lineProps.map((value, index, array) => {\n            return perLinePerProperty(value, index, array, context)\n          })\n        }\n\n        if (colorProperties) {\n          const sgrArgs = (Array.isArray(colorProperties)\n            ? colorProperties\n            : [colorProperties]\n          )\n          lineProps = lineProps.map(v => sgr(v, ...sgrArgs))\n        }\n\n        lineProps = [tab, lineProps.join(separator)].join('')\n        if (validMapper(perLine)) {\n          lineProps = perLine(lineProps[0], 0, lineProps)?.[0] ?? lineProps[0]\n        }\n\n        acc.push(lineProps)\n        line = []\n      }\n\n      return acc\n    }, [])\n\n    if (validMapper(preReturn)) {\n      finalLines = finalLines.map((value, index, array) => {\n        return preReturn(value, index, array, context)\n      })\n    }\n\n    Symbol.for(`@nejs.string.wrap ${JSON.stringify({lines: finalLines})}`)\n\n    if (lineEnding) {\n      finalLines = finalLines.join(lineEnding)\n    }\n\n    return finalLines\n  },\n});\n\nconst { isString: pIsString, ifString: pIfString } = StringExtensions.patches\n\n/**\n * `StringPrototypeExtensions` provides a set of utility methods that are\n * added to the `String` prototype. This allows all string instances to\n * access new functionality directly, enhancing their capabilities beyond\n * the standard `String` class methods. These extensions are applied using\n * the `Patch` class from '@nejs/extension', ensuring that they do not\n * interfere with the global namespace or existing properties.\n *\n * The extensions include methods for extracting substrings based on\n * specific tokens, checking the presence of certain patterns, and more,\n * making string manipulation tasks more convenient and expressive.\n */\nexport const StringPrototypeExtensions = new Patch(String.prototype, {\n  [Patch.kMutablyHidden]: {\n    /**\n     * Determines if the current object is a string.\n     *\n     * This getter uses the `pIsString` function from the\n     * `StringExtensions` patch to check if the current object\n     * (`this`) is a string.\n     *\n     * @type {boolean}\n     * @readonly\n     *\n     * @example\n     * const str = \"Hello, World!\"\n     * console.log(str.isString) // Output: true\n     *\n     * const notStr = 123\n     * console.log(notStr.isString) // Output: false\n     */\n    get isString() {\n      return pIsString(this)\n    },\n\n    /**\n     * Checks if the current object is a string and returns the\n     * corresponding value based on the result.\n     *\n     * This method uses the `pIfString` function from the\n     * `StringExtensions` patch to determine if the current object\n     * (`this`) is a string. If it is a string, the `thenValue` is returned.\n     * Otherwise, the `elseValue` is returned.\n     *\n     * @param {any} thenValue - The value to return if the current object\n     * is a string.\n     * @param {any} elseValue - The value to return if the current object\n     * is not a string.\n     * @returns {any} The `thenValue` if the current object is a string, or\n     * the `elseValue` if it is not a string.\n     *\n     * @example\n     * const str = \"Hello, World!\"\n     * // 'Is a string'\n     * console.log(str.ifString('Is a string', 'Not a string'))\n     *\n     * const notStr = 123\n     * // 'Not a string'\n     * console.log(notStr.ifString('Is a string', 'Not a string'))\n     */\n    ifString(thenValue, elseValue) {\n      return pIfString(this, thenValue, elseValue)\n    },\n\n    /**\n     * Returns an object representation of the string instance.\n     *\n     * This getter method creates and returns an object that wraps\n     * the string instance, allowing it to be treated as an object.\n     * The returned object is created using the `Object()`\n     * constructor, which takes the string instance as its argument.\n     *\n     * @type {Object}\n     * @readonly\n     *\n     * @example\n     * const str = 'Hello, World!'\n     * console.log(typeof str)        // 'string'\n     * console.log(typeof str.instance) // 'object'\n     */\n    get instance() {\n      return Object(this)\n    },\n\n    /**\n     * Extracts a substring from the current string, starting at a given offset\n     * and bounded by specified opening and closing tokens. This method is\n     * particularly useful for parsing nested structures or quoted strings,\n     * where the level of nesting or the presence of escape characters must\n     * be considered.\n     *\n     * @param {number} offset The position in the string from which to start the\n     * search for the substring.\n     * @param {[string, string]} tokens An array containing two strings: the\n     * opening and closing tokens that define the boundaries of the substring\n     * to be extracted.\n     * @returns {Object} An object with two properties: `extracted`, the\n     * extracted substring, and `newOffset`, the position in the original\n     * string immediately after the end of the extracted substring. If no\n     * substring is found, `extracted` is `null` and `newOffset` is the same\n     * as the input offset.\n     */\n    extractSubstring(offset = 0, tokens = parenthesisPair) {\n      let [openToken, closeToken] = tokens;\n      let depth = 0;\n      let start = -1;\n      let end = -1;\n      let leadingToken = '';\n      let firstToken = 0;\n\n      for (let i = offset; i < this.length; i++) {\n        const char = this[i];\n\n        if (char === openToken) {\n          depth++;\n          if (start === -1)\n            start = i;\n        }\n        else if (char === closeToken) {\n          depth--;\n          if (depth === 0) {\n            end = i;\n            break;\n          }\n        }\n      }\n\n      let lRange = [\n        Math.max(0, start - 100),\n        start\n      ];\n      let leading = [...this.substring(lRange[0], lRange[1])].reverse().join('')\n      let reversedLeadingToken;\n\n      try {\n        reversedLeadingToken = /([^ \\,\\\"\\'\\`]+)/.exec(leading)[1] ?? '';\n        leadingToken = [...reversedLeadingToken].reverse().join('');\n      }\n      catch(ignored) { }\n\n      if (start !== -1 && end !== -1) {\n        const sliceRange = [start, end + 1];\n        const extracted = this.slice(sliceRange[0], sliceRange[1]);\n\n        return {\n          extracted,\n          range: [start, end],\n          newOffset: end + 1,\n          leadingToken,\n        };\n      }\n      else {\n        return {\n          extracted: null,\n          range: [start, end],\n          newOffset: offset,\n          leadingToken,\n        };\n      }\n    },\n  },\n})\n\n// NOTE to self; this is repeated here otherwise a circular reference from\n// Object<->Function<->Global occurs. See original source in global.this.js\n// {@see globalThis.isThenElse}\nfunction isThenElse(bv, tv, ev) {\n  if (arguments.length > 1) {\n    var _then = isFunction(tv) ? tv(bv) : tv; if (arguments.length > 2) {\n      var _else = isFunction(ev) ? tv(bv) : ev; return bv ? _then : _else\n    } return bv || _then;\n  } return bv\n}", "import { Extension } from '@nejs/extension'\n\n/**\n * Deferreds, which were first introduced by jQuery for browsers in the early\n * 2000s, are a way to manage asynchronous operations. They have been widely\n * used and replicated by engineers since then. Although the Promise class in\n * modern JavaScript provides a static method called `withResolvers` that\n * returns an object with similar properties to a Deferred, it is not directly\n * supported by Node.js.\n *\n * ```\n * const withResolvers = Promise.withResolvers()\n * Reflect.has(withResolvers, 'promise') // true\n * Reflect.has(withResolvers, 'resolve') // true\n * Reflect.has(withResolvers, 'reject')  // true\n * ```\n *\n * This Deferred class extends the Promise class, allowing it to capture the\n * value or reason for easy access after resolution, akin to\n * {@link Promise.withResolvers}. As it extends {@link Promise}, it is\n * 'thenable' and works with `await` as if it were a native Promise. This\n * allows seamless integration with code expecting Promise-like objects.\n */\nexport class Deferred extends Promise {\n  /**\n   * The promise backing this deferred object. Created when the constructor\n   * runs, this promise is what all `Promise.prototype` functions are routed\n   * to.\n   *\n   * @type {Promise}\n   */\n  #promise = null\n\n  /**\n   * The reject() resolver that will be assigned when a new instance is\n   * created. Invoking this function with or without a `reason` will cause\n   * the deferred's promise to be settled.\n   *\n   * @type {function}\n   */\n  #reject = null\n\n  /**\n   * The resolve() resolver that will be assigned when a new instance is\n   * created. Invoking this function with or without a `value` will cause\n   * the deferred's promise to be settled.\n   *\n   * @type {function}\n   */\n  #resolve = null\n\n  #rejected = false\n\n  #resolved = false\n\n  /**\n   * When the Deferred is settled with {@link Deferred.resolve}, the `value`\n   * passed to that function will be set here as well.\n   *\n   * @type {*}\n   */\n  value = null\n\n  /**\n   * When the Deferred is settled with {@link Deferred.reject}, the `reason`\n   * passed to that rejection will also be stored here.\n   *\n   * @type {*}\n   */\n  reason = null\n\n  /**\n   * When either {@link Deferred.resolve} or {@link Deferred.reject} are called,\n   * this property is set to `true`. Its current status at any time can be\n   * queried using the {@link Deferred.settled} getter.\n   *\n   * @type {boolean}\n   */\n  #settled = false\n\n  /**\n   * The constructor for Deferred instances. By default, a new Deferred will\n   * have three important properties: `promise`, `resolve`, and `reject`.\n   *\n   * The constructor takes an object called `options`. It can have the\n   * following properties:\n   *\n   * ```\n   * interface BaseDeferredOptions {\n   *   // Deferreds store the value or reason. To turn this off, pass true\n   *   // to this option.\n   *   doNotTrackAnswers?: boolean;\n   * }\n   *\n   * interface ResolveDeferredOptions {\n   *   // Passing in an option object with a resolve value will auto resolve\n   *   // the Deferred with your value. An error will be raised if both\n   *   // resolve and reject are supplied at the same time.\n   *   resolve?: (value: any) => void;\n   * }\n   *\n   * interface RejectDeferredOptions {\n   *   // Passing in an option object with a reject reason will auto reject\n   *   // the Deferred with your reason. An error will be raised if both\n   *   // resolve and reject are supplied at the same time.\n   *   reject?: (reason: any) => void;\n   * }\n   *\n   * type DeferredOptions = BaseDeferredOptions &\n   *   (ResolveDeferredOptions | RejectDeferredOptions)\n   * ```\n   *\n   * @param {object} options see above for examples on supported options, but\n   * when supplied, the constructor can take instructions on how to auto\n   * resolve or reject the deferred created here.\n   */\n  constructor(options) {\n    // Check if options is an object, if not, assign an empty object to config\n    const config = (options && typeof(options) === 'object'\n      ? options\n      : {}\n    )\n\n    // Throw an error if both resolve and reject options are provided\n    if (config?.resolve && config?.reject) {\n      throw new TypeError(\n        'resolve and reject options cannot be simultaneously provided'\n      )\n    }\n\n    // Create an empty object to store the resolve and reject functions\n    let _resolve, _reject;\n\n    // Create a new promise and assign its resolve and reject functions to resolvers\n    super((resolve, reject) =>{\n      _resolve = resolve\n      _reject = reject\n\n      if (config?.executor && typeof(config?.executor) === 'function') {\n        config?.executor(resolve, reject)\n      }\n    })\n\n    // Define the resolve function for the Deferred instance\n    this.#resolve = (value) => {\n      // If doNotTrackAnswers is not set to true, store the value\n      if (config?.doNotTrackAnswers !== true) {\n        this.value = value\n      }\n      // Mark the Deferred instance as settled\n      this.#settled = true\n\n      // Mark the Deferred instance as resolved\n      this.#resolved = true\n\n      // Resolve the promise with the provided value\n      return _resolve(value)\n    }\n\n    // Define the reject function for the Deferred instance\n    this.#reject = async (reason) => {\n      // If doNotTrackAnswers is not set to true, store the reason\n      if (config?.doNotTrackAnswers !== true) {\n        this.reason = reason\n      }\n      // Mark the Deferred instance as settled\n      this.#settled = true\n\n      // Mark the Deferred as being rejected.\n      this.#rejected = true\n\n      // Reject the promise with the provided reason\n      return _reject(reason)\n    }\n\n    this.#promise = this\n\n    // If a resolve option is provided, resolve the Deferred instance with it\n    if (config?.resolve) {\n      this.#resolve(config?.resolve)\n    }\n    // If a reject option is provided, reject the Deferred instance with it\n    else if (config?.reject) {\n      this.#reject(config?.reject)\n    }\n  }\n\n  /**\n   * Returns a boolean value that indicates whether or not this Deferred\n   * has been settled (either resolve or reject have been invoked).\n   *\n   * @returns {boolean} `true` if either {@link Deferred.resolve} or\n   * {@link Deferred.reject} have been invoked; `false` otherwise\n   */\n  get settled() {\n    return this.#settled\n  }\n\n  /**\n   * A getter that returns a boolean indicating whether the Deferred instance\n   * was rejected. This property can be used to check if the Deferred has been\n   * settled with a rejection. It is particularly useful in scenarios where\n   * the resolution status of the Deferred needs to be checked without\n   * accessing the rejection reason or invoking any additional logic.\n   *\n   * @returns {boolean} `true` if the Deferred was rejected, otherwise `false`.\n   */\n  get wasRejected() {\n    return this.#rejected\n  }\n\n  /**\n   * A getter that returns a boolean indicating whether the Deferred instance\n   * was resolved. This property is useful for checking if the Deferred has been\n   * settled with a resolution, allowing for checks on the Deferred's status\n   * without needing to access the resolved value or trigger any additional\n   * logic.\n   *\n   * @returns {boolean} `true` if the Deferred was resolved, otherwise `false`.\n   */\n  get wasResolved() {\n    return this.#resolved\n  }\n\n  /**\n   * Accessor for the promise managed by this Deferred instance.\n   *\n   * This getter provides access to the internal promise which is controlled\n   * by the Deferred's resolve and reject methods. It allows external code to\n   * attach callbacks for the resolution or rejection of the Deferred without\n   * the ability to directly resolve or reject it.\n   *\n   * @returns {Promise} The promise controlled by this Deferred instance.\n   */\n  get promise() {\n    return this.#promise\n  }\n\n  /**\n   * Resolves the Deferred with the given value. If the value is a thenable\n   * (i.e., has a \"then\" method), the Deferred will \"follow\" that thenable,\n   * adopting its eventual state; otherwise, the Deferred will be fulfilled\n   * with the value. This function behaves the same as Promise.resolve.\n   *\n   * @param {*} value - The value to resolve the Deferred with.\n   * @returns {Promise} A Promise that is resolved with the given value.\n   */\n  resolve(value) {\n    return this.#resolve(value)\n  }\n\n  /**\n   * Rejects the Deferred with the given reason. This function behaves the\n   * same as Promise.reject. The Deferred will be rejected with the provided\n   * reason.\n   *\n   * @param {*} reason - The reason to reject the Deferred with.\n   * @returns {Promise} A Promise that is rejected with the given reason.\n   */\n  reject(reason) {\n    return this.#reject(reason)\n  }\n\n  /**\n   * Customizes the output of `util.inspect` on instances of Deferred when\n   * used in Node.js. This method is invoked by Node.js's `util.inspect`\n   * utility to format the inspection output of a Deferred instance.\n   *\n   * The output includes the state of the Deferred (resolved, rejected, or\n   * unsettled) along with the resolved value or rejection reason, if\n   * applicable. This provides a quick, readable status of the Deferred\n   * instance directly in the console or debugging tools.\n   *\n   * @param {number} depth The depth to which `util.inspect` will recurse.\n   * @param {object} options Formatting options provided by `util.inspect`.\n   * @param {function} inspect Reference to the `util.inspect` function.\n   * @returns {string} A formatted string representing the Deferred instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    return [\n      '\\x1b[1mDeferred [\\x1b[22;3mPromise\\x1b[23;1m]\\x1b[22m ',\n      '{ ',\n      (this.settled\n        ? (this.wasResolved\n          ? `resolved with \\x1b[32m${this.value}\\x1b[39m`\n          : `rejected with \\x1b[31m${this.reason?.message ?? this.reason}\\x1b[39m`)\n        : '\\x1b[33munsettled valued or reason\\x1b[39m'\n      ),\n      ' }'\n    ].join('')\n  }\n\n  /**\n   * A getter for the species symbol which returns a custom DeferredPromise\n   * class. This class extends from Deferred and is used to ensure that the\n   * constructor signature matches that of a Promise. The executor function\n   * passed to the constructor of this class is used to initialize the Deferred\n   * object with resolve and reject functions, similar to how a Promise would\n   * be initialized.\n   *\n   * @returns {DeferredPromise} A DeferredPromise class that extends Deferred.\n   */\n  static get [Symbol.species]() {\n    return class DeferredPromise extends Deferred {\n      /**\n       * The constructor for the DeferredPromise class.\n       * It takes an executor function which is used to initialize the Deferred.\n       *\n       * @param {Function} executor - A function that is passed with the resolve\n       * and reject functions. The executor is expected to initialize the\n       * Deferred by calling resolve or reject at some point.\n       */\n      constructor(executor) {\n        super({executor})\n      }\n    }\n  }\n}\n\nexport const DeferredExtension = new Extension(Deferred)", "import { Extension } from '@nejs/extension'\n\nexport class Introspector {\n  static addExpansion(array) {\n    const toEntriesFrom = (owner = globalThis) => {\n      return (accumulator, key) => {\n        const count = accumulator.length;\n\n        try {\n          const value = owner[key]\n          accumulator.splice(count, 0, [key, value], [value, key])\n        }\n        catch (error) { accumulator.splice(count, 0, [key, error]) }\n\n        return accumulator\n      }\n    }\n\n    return Object.defineProperty(array, 'expand', {\n      get() {\n        return new Map(\n          this.reduce(toEntriesFrom(globalThis), [])\n        )\n      },\n      configurable: true,\n      enumerable: true,\n    })\n  }\n\n  static accessors(owner = globalThis, keys = []) {\n    const entries = []\n\n    for (const key of keys) {\n      try {\n        const metadata = this.metadata(owner, key)\n        if (metadata.get || metadata.set) {\n          entries.push([key, metadata])\n        }\n        continue\n      }\n      catch (error) {\n        entries.push([key, error])\n      }\n    }\n\n    return new Map(entries)\n  }\n\n  static classes(owner = globalThis) {\n    return this.fetcher(\n      'function', /^[A-Z]/, Object, 'getOwnPropertyNames', owner\n    )\n  }\n\n  static functions(owner = globalThis) {\n    return this.fetcher(\n      'function', /^[a-z]/, Object, 'getOwnPropertyNames', owner\n    )\n  }\n\n  static objects(owner = globalThis) {\n    return this.fetcher('object', null, Object, 'getOwnPropertyNames', owner)\n  }\n\n  static properties(owner = globalThis) {\n    return this.fetcher(\n      (v,t,d) => t !== 'object' && t !== 'function',\n      null, Object, 'getOwnPropertyNames', owner\n    )\n  }\n\n  static symbols(owner = globalThis) {\n    return this.addExpansion(Object.getOwnPropertySymbols(owner))\n  }\n\n  static metadata(owner, key) {\n    const metadata = {\n      owner, key,\n      descriptor: undefined,\n      value: undefined,\n      get type() { return typeof this.value },\n    }\n\n    try { metadata.descriptor = Object.getOwnPropertyDescriptor(owner, key) }\n    catch(error) { metadata.descriptor = error }\n\n    try {\n      metadata.value = (\n        metadata.descriptor?.value ??\n        metadata.descriptor?.get?.bind(owner)?.() ??\n        owner[key]\n      )\n    }\n    catch(error) { metadata.value = error }\n\n    return metadata\n  }\n\n  static fetcher(\n    typeNameOrTyperFn,\n    regExp = undefined,\n    searchClass = Object,\n    searchFunction = 'getOwnPropertyNames',\n    owner = globalThis\n  ) {\n    let typer = typeNameOrTyperFn\n\n    if (typeof typeNameOrTyperFn !== 'function') {\n      const type = String(typeNameOrTyperFn)\n      typer = (function(value, typeName, descriptor) {\n        return typeName === type\n      }).bind(this)\n    }\n\n    return this.addExpansion(\n      searchClass[searchFunction](owner).filter(key => {\n        const metadata = this.metadata(owner, key)\n        return (\n          (!regExp || regExp.exec(String(key))) &&\n          typer(metadata.value, metadata.type, metadata.descriptor)\n        )\n      }).toSorted()\n    )\n  }\n\n  static makeReport(owner = globalThis) {\n    let names = [\n      'classes', 'functions', 'objects', 'properties', 'symbols', 'accessors'\n    ];\n    let bound = names.reduce(\n      (a,n) => { a[n] = this[n].bind(this); return a },\n      {}\n    )\n    const { classes, functions, objects, properties, symbols, accessors } = bound\n    const result = { }\n\n    Object.assign(result, {\n      accessors: {\n        classes: undefined,\n        functions: undefined,\n        objects: undefined,\n        properties: undefined,\n        symbols: undefined,\n      },\n      classes: this[classes.name](),\n      functions: this[functions.name](),\n      objects: this[objects.name](),\n      properties: this[properties.name](),\n      symbols: this[symbols.name](),\n      expandAll() {\n        names.forEach(reportName => {\n          result[reportName] = result?.[reportName]?.expand\n        })\n      },\n    })\n\n    (names.forEach(type => {\n        debugger\n        result.accessors[type] = accessors(globalThis, result[type])\n      })\n    )\n\n    return result\n  }\n}\n\nexport const IntrospectorExtensions = new Extension(Introspector);", "import { Extension } from '@nejs/extension'\n\n/**\n * The Iterable class is designed to provide a convenient way to create synchronous\n * iterable objects. It can be initialized with either an array or individual elements.\n * This class implements the iterable protocol, allowing instances to be used with\n * `for...of` loops and other standard JavaScript iteration mechanisms.\n */\nexport class Iterable {\n  /**\n   * Private field to store the elements of the iterable.\n   * @private\n   */\n  #elements = [];\n\n  /**\n   * Constructs an instance of Iterable. It can be initialized with either an\n   * iterable object (such as an array, Set, Map, string, or any object\n   * implementing the iterable protocol) or individual elements. If the first\n   * argument is an iterable, the class instance is initialized with the\n   * elements from the iterable, followed by any additional arguments. If the\n   * first argument is not an iterable, all arguments are treated as individual\n   * elements.\n   *\n   * @param {Iterable|*} elementsOrFirstElement - An iterable object or the\n   * first element.\n   * @param {...*} moreElements - Additional elements if the first argument is\n   * not an iterable.\n   */\n  constructor(elementsOrFirstElement, ...moreElements) {\n    if (\n      elementsOrFirstElement != null &&\n      typeof elementsOrFirstElement[Symbol.iterator] === 'function'\n    ) {\n      this.#elements = [...elementsOrFirstElement, ...moreElements];\n    } else {\n      this.#elements = [elementsOrFirstElement, ...moreElements];\n    }\n  }\n\n  /**\n   * Implements the iterable protocol. When an instance of Iterable is used\n   * in a `for...of` loop or spread syntax, this generator function is invoked\n   * to yield the elements one by one in a synchronous manner.\n   *\n   * @returns {Generator} A generator that yields each element of the iterable.\n   */\n  *[Symbol.iterator]() {\n    for (const element of this.#elements) {\n      yield element;\n    }\n  }\n\n  /**\n   * Provides access to the elements as a standard array. Useful for scenarios\n   * where array methods and behaviors are needed.\n   *\n   * @returns {Array} An array containing all the elements of the iterable.\n   */\n  get asArray() {\n    return this.#elements;\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Checks if a given value is an iterable. This method determines if the\n   * provided value has a `Symbol.iterator` property that is a generator\n   * function. It's a precise way to identify if the value conforms to the\n   * iterable protocol using a generator function.\n   *\n   * Note: This method specifically checks for generator functions. Some\n   * iterables might use regular functions that return an iterator, which\n   * this method won't identify.\n   *\n   * @param {*} value - The value to be checked for iterability.\n   * @returns {boolean} - Returns true if the value is an iterable implemented\n   * using a generator function, false otherwise.\n   */\n  static isIterable(value) {\n    const type = Object.prototype.toString.call(value?.[Symbol.iterator]);\n    return type === '[object GeneratorFunction]';\n  }\n}\n\n/**\n * Being able to create a compliant `Iterator` around any type of iterable\n * object. This can be wrapped around any type of object that has a\n * `[Symbol.iterator]` property assigned to a generator function.\n */\nexport class Iterator {\n  /**\n   * A private function that when provided has the following signature:\n   * `function mapEach(entry) -> entry`. This allows any changes to be made\n   * to each element, conditionally and programmatically, as needed before\n   * they are returned to the called code.\n   */\n  #mapEach = undefined\n\n  /**\n   * Creates a new `Iterator` object instance.\n   *\n   * @param {object} iterable any object that has a `[Symbol.iterator]`\n   * property assigned to a generator function.\n   * @param {function} mapEach when provided `mapEach` is a callback that\n   * takes an entry as input and receives one as output.\n   */\n  constructor(iterable, mapEach) {\n    if (!iterable || !Reflect.has(iterable, Symbol.iterator)) {\n      throw new TypeError(\n        'Value used to instantiate Iterator is not iterable'\n      );\n    }\n\n    this.#iterable = iterable;\n    this.#iterator = iterable[Symbol.iterator]();\n    this.#mapEach = typeof mapEach === 'function' ? mapEach : undefined\n  }\n\n  /**\n   * Returns a new `Array` derived from the iterable this object\n   * wraps.\n   *\n   * @returns {array} a new `Array` generated from the wrapped\n   * iterable. The method is generated from `Array.from()`\n   */\n  get asArray() {\n    return Array.from(this.#iterable)\n  }\n\n  /**\n   * Returns the actual iterable object passed to the constructor that\n   * created this instance.\n   *\n   * @returns {object} the object containing the `[Symbol.iterator]`\n   */\n  get iterable() {\n    return this.#iterable\n  }\n\n  /**\n   * The function retrieves the next value in the iterator. If the\n   * the iterator has run its course, `reset()` can be invoked to\n   * reset the pointer to the beginning of the iteration.\n   *\n   * @returns {any} the next value\n   */\n  next() {\n    const input = this.#iterator.next();\n    let output = input\n\n    if (output.done) {\n      return { value: undefined, done: true };\n    }\n    else {\n      if (this.#mapEach && typeof this.#mapEach === 'function') {\n        output.value = this.#mapEach(input.value)\n      }\n\n      return { value: output.value, done: false };\n    }\n  }\n\n  /**\n   * Resets the iterator to the beginning allowing it to be\n   * iterated over again.\n   */\n  reset() {\n    this.#iterator = this.#iterable[Symbol.iterator]();\n  }\n\n  /**\n   * The existence of this symbol on the object instances, indicates that\n   * it can be used in `for(.. of ..)` loops and its values can be\n   * extracted from calls to `Array.from()`\n   *\n   * @returns {Iterator} this is returned since this object is already\n   * conforming to the expected JavaScript Iterator interface\n   */\n  [Symbol.iterator]() {\n    return this;\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * The object from which its iterator functionality is derived.\n   *\n   * @type {object}\n   * @private\n   */\n  #iterable = null;\n\n  /**\n   * The results of a call to the iterable's `[Symbol.iterator]`\n   * generator function.\n   *\n   * @type {object}\n   * @private\n   */\n  #iterator = null;\n\n  /**\n   * Creates an Iterator for the keys of the given object.\n   *\n   * @note alternatives to keyFetcher might be `Reflect.ownKeys` or even\n   * `Object.keys`. Each type of fetcher has their own requirements but\n   * any function that takes an object and returns keys will suffice.\n   *\n   * @param {Object} object - The object whose keys will be iterated.\n   * @param {Function} [mapEach] - Optional function to map each key.\n   * @param {Function} [keyFetcher=Object.getOwnPropertyNames] - Function to\n   * fetch keys from the object. Defaults to Object.getOwnPropertyNames.\n   * @returns {Iterator} An Iterator instance containing the object's keys.\n   */\n  static keys(object, mapEach, keyFetcher) {\n    keyFetcher ??= Object.getOwnPropertyNames;\n\n    const keys = keyFetcher(object);\n    return new Iterator(keys, mapEach);\n  }\n\n  /**\n   * Creates an Iterator for the entries of the given object.\n   *\n   * @note alternatives to keyFetcher might be `Reflect.ownKeys` or even\n   * `Object.keys`. Each type of fetcher has their own requirements but\n   * any function that takes an object and returns keys will suffice.\n   *\n   * @param {Object} object - The object whose entries will be iterated.\n   * @param {Function} [mapEach] - Optional function to map each entry.\n   * @param {Function} [keyFetcher=Object.getOwnPropertyNames] - Function to\n   * fetch keys from the object. Defaults to Object.getOwnPropertyNames.\n   * @returns {Iterator} An Iterator instance containing the object's entries.\n   */\n  static entries(object, mapEach, keyFetcher) {\n    keyFetcher ??= Object.getOwnPropertyNames;\n\n    const keys = keyFetcher(object);\n    const entries = [];\n\n    for (const key of keys) {\n      entries.push([key, object[key]]);\n    }\n\n    return new Iterator(entries, mapEach)\n  }\n\n  /**\n   * Creates an Iterator for the property descriptors of the given object.\n   *\n   * @note alternatives to keyFetcher might be `Reflect.ownKeys` or even\n   * `Object.keys`. Each type of fetcher has their own requirements but\n   * any function that takes an object and returns keys will suffice.\n   *\n   * @param {Object} object - The object whose descriptors will be iterated.\n   * @param {Function} [mapEach] - Optional function to map each descriptor\n   * entry.\n   * @param {Function} [keyFetcher=Object.getOwnPropertyNames] - Function to\n   * fetch keys from the object. Defaults to Object.getOwnPropertyNames.\n   * @returns {Iterator} An Iterator instance containing entries of [key,\n   * descriptor] pairs.\n   */\n  static descriptors(object, mapEach, keyFetcher) {\n    keyFetcher ??= Object.getOwnPropertyNames;\n\n    const keys = keyFetcher(object);\n    const entries = [];\n\n    for (const key of keys) {\n      entries.push([key, Object.getOwnPropertyDescriptor(object, key)])\n    }\n\n    return new Iterator(entries, mapEach);\n  }\n}\n\nexport const IterableExtensions = new Extension(Iterable)\nexport const IteratorExtensions = new Extension(Iterator)", "import { Extension } from '@nejs/extension'\n\nexport class ParamParser {\n  /**\n   * Constructs an instance of ParamParser. It takes in parameters, an optional\n   * validator function, and an optional parser function. The parameters are\n   * validated and if successful, parsed.\n   *\n   * @param {any[]} parameters - Arguments passed in by the process.\n   * @param {((any[]) => boolean)?} [validator=() => {}] - An optional function\n   * to specify a validator without subclassing ParamParser. It should return\n   * a boolean indicating the validity of the parameters.\n   * @param {((any[]) => object)?} [parser=() => {}] - An optional function to\n   * specify a parser without subclassing ParamParser. It should return an\n   * object after parsing the input parameters.\n   *\n   * @example\n   * const parameters = ['param1', 'param2']\n   * const validator = params => params.every(param => typeof param === 'string')\n   * const parser = params => ({ params })\n   * const paramParser = new ParamParser(parameters, validator, parser)\n   * if (paramParser.success) {\n   *   console.log('Parsing successful:', paramParser.results)\n   * } else {\n   *   console.error('Parsing failed.')\n   * }\n   */\n  constructor(parameters, validator = () => {}, parser = () => {}) {\n    this.args = parameters\n    this.parser = parser\n    this.validator = validator\n    this.result = undefined\n    this.success = this.validate(this.args)\n\n    if (this.success) {\n      this.results = this.parse(this.args)\n    }\n  }\n\n  /**\n   * @param {object} args arguments that were previously validated\n   * by either the overloaded validate() method or the supplied\n   * validator closure.\n   * @returns {object} returns the output object, or an empty\n   * object, after parsing the input arguments or parameters.\n   */\n  parse(args) {\n    return this.parser?.(args);\n  }\n\n  /**\n   * Walk the arguments and determine if the supplied input is\n   * a valid parsing.\n   *\n   * @param {any[]} args arguments supplied by the process.\n   * @returns {boolean} `true` if the validation is successful,\n   * `false` otherwise.\n   */\n  validate(args) {\n    return this.validator?.(args);\n  }\n\n  /**\n   * Attempts to parse the given parameters using the provided parsers, throwing an\n   * error if no valid parser is found. This method serves as a convenience wrapper\n   * around `safeTryParsers`, enforcing strict parsing by automatically enabling\n   * error throwing on failure.\n   *\n   * @param {any[]} parameters - The parameters to be parsed.\n   * @param {Function[]} parsers - An array of `ParamParser` subclasses to attempt\n   * parsing with.\n   * @returns {Object} An object containing the parsing result, with a `success`\n   * property indicating if parsing was successful, and a `data` property containing\n   * the parsed data if successful.\n   * @example\n   * const parameters = ['param1', 'param2'];\n   * const parsers = [Parser1, Parser2];\n   * const result = ParamParser.tryParsers(parameters, parsers);\n   * if (result.success) {\n   *   console.log('Parsing successful:', result.data);\n   * } else {\n   *   console.error('Parsing failed.');\n   * }\n   */\n  static tryParsers(parameters, parsers) {\n    return this.safeTryParsers(parameters, parsers, true)\n  }\n\n  /**\n   * Tries parsing `parameters` with each parser in `parsers`. If\n   * `throwOnFail` is true, throws an error when validation fails or\n   * no valid parser is found.\n   *\n   * This method attempts to parse the given parameters using the\n   * provided list of parsers. It validates the input to ensure both\n   * `parameters` and `parsers` are arrays and that `parsers`\n   * contains at least one valid `ParamParser` subclass. If\n   * `throwOnFail` is set to true, it will throw specific errors for\n   * invalid inputs or when no parser succeeds. Otherwise, it returns\n   * an object indicating the success status and the result of\n   * parsing, if successful.\n   *\n   * @param {any[]} parameters - The parameters to be parsed.\n   * @param {Function[]} parsers - An array of `ParamParser`\n   * subclasses to attempt parsing with.\n   * @param {boolean} [throwOnFail=false] - Whether to throw an\n   * error on failure.\n   * @returns {{success: boolean, data: any}} An object with a\n   * `success` flag and `data` containing the parsing result, if\n   * successful.\n   * @throws {ParametersMustBeArrayError} If `parameters` or\n   * `parsers` are not arrays when `throwOnFail` is true.\n   * @throws {ParsersArrayMustContainParsersError} If `parsers`\n   * does not contain at least one valid `ParamParser` subclass\n   * when `throwOnFail` is true.\n   * @throws {NoValidParsersFound} If no valid parser is found\n   * and `throwOnFail` is true.\n   * @example\n   * const parameters = ['param1', 'param2'];\n   * const parsers = [Parser1, Parser2];\n   * const result = ParamParser.safeTryParsers(\n   *   parameters, parsers, true\n   * );\n   *\n   * if (result.success) {\n   *   console.log('Parsing successful:', result.data);\n   * } else {\n   *   console.error('Parsing failed.');\n   * }\n   */\n  static safeTryParsers(parameters, parsers, throwOnFail = false) {\n    if (!Array.isArray(parameters) || !Array.isArray(parsers)) {\n      if (throwOnFail) {\n        throw new this.ParametersMustBeArrayError(\n          `${this.name}.tryParsers must receive two arrays as args`\n        );\n      }\n    }\n\n    if (!parsers.some(parser => parser?.prototype instanceof ParamParser &&\n                                typeof parser === 'function')) {\n      if (throwOnFail) {\n        throw new this.ParsersArrayMustContainParsersError(\n          `${this.name}.tryParsers parsers argument must contain at least one ` +\n          `ParamParser derived class`\n        );\n      }\n    }\n\n    let success = false;\n    let result = undefined;\n\n    for (let Parser of parsers) {\n      const parser = new Parser(parameters);\n      if (parser.success) {\n        success = true;\n        result = parser.result;\n        break;\n      }\n    }\n\n    if (!success && throwOnFail) {\n      throw new this.NoValidParsersFound('No valid parsers found');\n    }\n\n    return { success, data: result };\n  }\n\n  /**\n   * A custom error class that signifies no valid parsers were found\n   * during the parsing process. This error is thrown when all\n   * parsers fail to parse the given parameters and the `throwOnFail`\n   * flag is set to true in the `safeTryParsers` method.\n   *\n   * @returns {Function} A class extending Error, representing a\n   * specific error when no valid parsers are found.ound.\n   *\n   * @example\n   * try {\n   *   const result = ParamParser.safeTryParsers(\n   *     parameters, parsers, true\n   *   );\n   * } catch (error) {\n   *   if (error instanceof ParamParser.NoValidParsersFound) {\n   *     console.error(\n   *       'No valid parsers could process the parameters.'\n   *     );\n   *   }\n   * }\n   */\n  static get NoValidParsersFound() {\n    return class NoValidParsersFound extends Error { }\n  }\n\n  /**\n   * Represents an error thrown when the parameters provided to a method\n   * are not in an array format as expected. This class extends the\n   * native JavaScript `Error` class, allowing for instances of this\n   * error to be thrown and caught using standard error handling\n   * mechanisms in JavaScript.\n   *\n   * This error is specifically used in scenarios where a method\n   * expects its arguments to be provided as an array, and the\n   * validation of those arguments fails because they were not\n   * provided in an array format. It serves as a clear indicator\n   * of the nature of the error to developers, enabling them to\n   * quickly identify and rectify the issue in their code.\n   *\n   * @example\n   * try {\n   *   ParamParser.safeTryParsers(nonArrayParameters, parsers, true);\n   * } catch (error) {\n   *   if (error instanceof ParamParser.ParametersMustBeArrayError) {\n   *     console.error('Parameters must be provided as an array.');\n   *   }\n   * }\n   */\n  static get ParametersMustBeArrayError() {\n    return class ParametersMustBeArrayError extends Error { }\n  }\n\n  /**\n   * A custom error class indicating that the parsers array does not\n   * contain valid parser functions. This error is thrown when the\n   * validation of parsers within `ParamParser.safeTryParsers` fails\n   * to find any instance that is a subclass of `ParamParser`. It\n   * extends the native JavaScript `Error` class, allowing it to be\n   * thrown and caught using standard error handling mechanisms.\n   *\n   * This error serves as a clear indicator to developers that the\n   * provided array of parsers does not meet the expected criteria,\n   * specifically that it must contain at least one valid parser\n   * that extends `ParamParser`. This ensures that the parsing\n   * process can be executed with at least one valid parser function.\n   *\n   * @example\n   * try {\n   *   ParamParser.safeTryParsers(parameters, [], true);\n   * } catch (error) {\n   *   const { ParsersArrayMustContainParsersError } = ParamParser\n   *   if (error instanceof ParsersArrayMustContainParsersError) {\n   *     console.error(\n   *       'The parsers array must contain at least one valid parser.'\n   *     );\n   *   }\n   * }\n   */\n  static get ParsersArrayMustContainParsersError() {\n    return class ParsersArrayMustContainParsersError extends Error { }\n  }\n}\n\nexport const ParamParserExtensions = new Extension(ParamParser);", "import { Extension } from '@nejs/extension'\n\nconst { toStringTag, hasInstance } = Symbol\n\nexport class ProxyHandlerResponse {\n  constructor(success = false, value = undefined, context = undefined) {\n    Object.assign(this, { succes, value, context })\n  }\n\n  /**\n   * A getter method for the toStringTag symbol.\n   * This method returns the name of the constructor of the instance.\n   * It is used to provide a custom string description of the object,\n   * which can be useful for debugging or logging purposes.\n   *\n   * @example\n   * const response = new ProxyHandlerResponse();\n   * console.log(response[Symbol.toStringTag]); // logs: \"ProxyHandlerResponse\"\n   *\n   * @returns {string} The name of the constructor of the instance.\n   */\n  get [toStringTag]() { return this.constructor.name }\n\n  /**\n   * This static method is a Symbol.hasInstance method implementation.\n   * It checks if the provided instance is an instance of the class.\n   * It does this by comparing the instance's toStringTag or constructor\n   * to the class's name or the class itself respectively.\n   *\n   * @param {Object} instance - The instance to check.\n   * @returns {boolean} True if the instance is of the class, false otherwise.\n   *\n   * @example\n   * // Assuming MyClass has implemented this method\n   * const myInstance = new MyClass();\n   * // logs: true\n   * console.log(MyClass[Symbol.hasInstance](myInstance));\n   */\n  static [hasInstance](instance) {\n    return (\n      instance?.[toStringTag] === this.name ||\n      instance?.constructor === this\n    )\n  }\n}\n\nexport class ProxyHandler {\n  constructor(handler, type = ProxyHandler.type.get) {\n    this.handler = handler;\n    this.typeName = Array.isArray(type)\n      ? ProxyHandler.nameFromType(type) ?? 'get'\n      : String(type)\n    this.type = Array.isArray(type) ? type : ProxyHandler.type[type ?? 'get'];\n  }\n\n  invoke(...args) {\n    const context = {\n      defaultValue: Reflect[this.typeName](...args),\n      proxyHandler: this,\n      typeHandler: this.handler,\n    }\n\n    try {\n      const result = this.handler.apply(context, args)\n\n      if (!(result?.[Symbol.toStringTag] === ProxyHandler.ResponseType)) {\n        return ProxyHandler.response(!!result, result, context)\n      }\n\n      result.context = context\n\n      return result\n    }\n    catch (error) {\n      return ProxyHandler.response(false, error)\n    }\n  }\n\n  /**\n   * This static method is used to create a response object. The response\n   * object contains the success status, the value, and the context of the\n   * response. It also includes a getter for the Symbol.toStringTag property\n   * that returns the ResponseType of the ProxyHandler.\n   *\n   * @param {boolean} success - The success status of the response.\n   * @param {*} value - The value of the response.\n   * @param {Object} context - The context of the response.\n   * @returns {Object} The response object.\n   *\n   * @example\n   * // Create a response object\n   * const response = ProxyHandler.response(\n   *   true, 'value', { key: 'context' }\n   * );\n   *\n   * // Output: { success: true, value: 'value', context: { key: 'context' },\n   * //           [Symbol.toStringTag]: 'ProxyHandlerResponse' }\n   * console.log(response);\n   */\n  static response(success, value, context) {\n    return {\n      success, value, context,\n      get [Symbol.toStringTag]() { return this.ResponseType }\n    }\n  }\n\n  /**\n   * This static getter method is used to retrieve the response type\n   * of the ProxyHandler. It returns a string that represents the\n   * response type of the ProxyHandler.\n   *\n   * @property {function} ResponseType - A static getter method that\n   * returns the response type of the ProxyHandler.\n   * @returns {string} A string representing the response type of the\n   * ProxyHandler.\n   *\n   * @example\n   * // Get the response type of the ProxyHandler\n   * const responseType = ProxyHandler.ResponseType;\n   *\n   * // Output: 'ProxyHandlerResponse'\n   * console.log(responseType);\n   */\n  static get ResponseType() { return 'ProxyHandlerResponse' }\n\n  /**\n   * This static method is used to retrieve the name of a ProxyHandler type\n   * from a given array of arguments. If the array of arguments matches any\n   * of the ProxyHandler types, the name of that type is returned. If no\n   * match is found, or if the input is not an array, 'custom' is returned.\n   *\n   * @param {Array.<*>} proxyHandlerType - An array of arguments to match\n   * against the ProxyHandler types.\n   * @returns {string} The name of the matching ProxyHandler type, or 'custom'\n   * if no match is found.\n   *\n   * @example\n   * // Get the name of a type from its arguments\n   * const typeName = ProxyHandler.nameFromType(\n   *   ['target', 'thisArg', 'argumentsList']\n   * );\n   *\n   * // Output: 'apply'\n   * console.log(typeName);\n   *\n   * @throws {TypeError} If ProxyHandler.type is undefined.\n   */\n  static nameFromType(proxyHandlerType) {\n    if (!Array.isArray(proxyHandlerType)) {\n      return 'custom'\n    }\n\n    const names = Object.entries(ProxyHandler.type)\n    for (const [name, args] of names) {\n      if (proxyHandlerType.every(element => ~args.indexOf(element))) {\n        return name\n      }\n    }\n\n    return 'custom'\n  }\n\n  /**\n   * This method is used to retrieve all the types of ProxyHandler available\n   * in the ProxyHandler.type object. It is useful when you need to iterate\n   * over all the types or when you need to check if a certain type exists.\n   *\n   * @property {function} typeNames - A static getter method that returns an\n   * array of keys from the ProxyHandler.type object.\n   * @returns {Array.<string>} An array of strings representing the keys of\n   * the ProxyHandler.type object.\n   *\n   * @example\n   * // Get all type names\n   * const types = ProxyHandler.typeNames;\n   *\n   * // Output: ['apply', 'construct', 'defineProperty', ...]\n   * console.log(types);\n   *\n   * @throws {TypeError} If ProxyHandler.type is undefined.\n   */\n  static get typeNames() {\n    return Object.keys(ProxyHandler.type)\n  }\n\n  /**\n   * A static getter method that returns an object containing keyed proxy\n   * trap types and their associated expected arguments list by name. A\n   * docstring description complete with url shortening links for each entry\n   * are provided (links go to the MDN documentation)\n   *\n   * @property {function} type - A static getter method that returns an object\n   * of ProxyHandler types.\n   * @returns {Object.<string, function>} An object where each key is a type\n   * name and each value is a function that returns an array of strings\n   * representing the arguments for that type.\n   *\n   * @example\n   * // Get the 'apply' type\n   * const applyType = ProxyHandler.type.apply;\n   *\n   * // Output: ['target', 'thisArg', 'argumentsList']\n   * console.log(applyType());\n   *\n   * @throws {TypeError} If ProxyHandler.type is undefined.\n   */\n  static get type() {\n    return {\n      /**\n       * The handler.apply() method is a trap for the [[Call]] object internal\n       * method, which is used by operations such as function calls.\n       * MDN link: https://t.ly/orBsG\n       */\n      get apply() { return ['target', 'thisArg', 'argumentsList'] },\n\n      /**\n       * The handler.construct() method is a trap for the [[Construct]] object\n       * internal method, which is used by operations such as the new operator.\n       * In order for the new operation to be valid on the resulting Proxy\n       * object, the target used to initialize the proxy must itself be a\n       * valid constructor.\n       * MDN link: https://t.ly/1LukS\n       */\n      get construct() { return ['target', 'args'] },\n\n      /**\n       * The handler.defineProperty() method is a trap for the\n       * [[DefineOwnProperty]] object internal method, which is used by\n       * operations such as Object.defineProperty().\n       * MDN link: https://t.ly/3Ml9y\n       */\n      get defineProperty() { return ['target', 'key', 'descriptor'] },\n\n      /**\n       * The handler.deleteProperty() method is a trap for the [[Delete]]\n       * object internal method, which is used by operations such as the\n       * delete operator.\n       * MDN link: https://t.ly/neu2H\n       */\n      get deleteProperty() { return ['target', 'property'] },\n\n      /**\n       * The handler.get() method is a trap for the [[Get]] object internal\n       * method, which is used by operations such as property accessors.\n       * MDN link: https://t.ly/E419x\n       */\n      get get() { return ['target', 'property', 'receiver'] },\n\n      /**\n       * The handler.getOwnPropertyDescriptor() method is a trap for the\n       * [[GetOwnProperty]] object internal method, which is used by operations\n       * such as Object.getOwnPropertyDescriptor().\n       * MDN link: https://t.ly/wzPTX\n       */\n      get getOwnPropertyDescriptor() { return ['target', 'property'] },\n\n      /**\n       * The handler.getPrototypeOf() method is a trap for the\n       * [[GetPrototypeOf]] object internal method, which is used by operations\n       * such as Object.getPrototypeOf().\n       * MDN link: https://t.ly/Ww4S1\n       */\n      get getPrototypeOf() { return ['target'] },\n\n      /**\n       * The handler.has() method is a trap for the [[HasProperty]] object\n       * internal method, which is used by operations such as the in operator.\n       * MDN link: https://t.ly/UcJL-\n       */\n      get has() { return ['target', 'prototype'] },\n\n      /**\n       * The handler.isExtensible() method is a trap for the [[IsExtensible]]\n       * object internal method, which is used by operations such as\n       * Object.isExtensible().\n       * MDN link: https://t.ly/MkdIK\n       */\n      get isExtensible() { return ['target'] },\n\n      /**\n       * The handler.ownKeys() method is a trap for the [[OwnPropertyKeys]]\n       * object internal method, which is used by operations such as\n       * Object.keys(), Reflect.ownKeys(), etc.\n       * MDN link: https://t.ly/QkiTI\n       */\n      get ownKeys() { return ['target'] },\n\n      /**\n       * The handler.preventExtensions() method is a trap for the\n       * [[PreventExtensions]] object internal method, which is used by\n       * operations such as Object.preventExtensions().\n       * MDN link: https://t.ly/nvfjJ\n       */\n      get preventExtensions() { return ['target'] },\n\n      /**\n       * The handler.set() method is a trap for the [[Set]] object internal\n       * method, which is used by operations such as using property accessors\n       * to set a property's value.\n       * MDN link: https://t.ly/FDWcl\n       */\n      get set() { return ['target', 'property', 'value', 'receiver'] },\n\n      /**\n       * The handler.setPrototypeOf() method is a trap for the\n       * [[SetPrototypeOf]] object internal method, which is used by operations\n       * such as Object.setPrototypeOf().\n       * MDN link: https://t.ly/pS8ej\n       */\n      get setPrototypeOf() { return ['target', 'prototype'] },\n    }\n  }\n}\n\nexport class PluggableProxy {\n  constructor(Class, handlers, options = {\n    prototype: undefined, // undefined means extract from class\n    apply: true,\n  }) {\n    const validHandlers = handlers.filter(h => h instanceof ProxyHandler)\n\n    Object.assign(this, {\n      class: Class instanceof Function ? Class : Class.constructor,\n      instance: Class instanceof Function ? null : Class,\n    })\n\n    this.handlers = new Map()\n\n    for (let typeName of ProxyHandler.typeNames) {\n      const handlersOfType = [].concat(\n        validHandlers.filter(h => h.typeName === typeName)\n      )\n\n      this.handlers.set(typeName, handlersOfType)\n    }\n\n    this[PluggableProxy.kOriginal] = (\n      options?.prototype ?? Object.getPrototypeOf(this.class)\n    )\n\n    this[PluggableProxy.kCreated] = Object.create(\n      this[PluggableProxy.kOriginal],\n      this.instance,\n    )\n\n    this[PluggableProxy.kProxy] = new Proxy(this[PluggableProxy.kCreated], this)\n\n    if (options?.apply != true) {\n      const target = this?.instance ?? this.class\n      Object.setPrototypeOf(target, this[PluggableProxy.kCreated])\n    }\n  }\n\n  handlersOfType(typeName) {\n    return this.handlers.get(typeName)\n  }\n\n  tryEachOfType(type, ...args) {\n    const types = ProxyHandler.typeNames\n    const failures = []\n\n    for (const handler of types) {\n      const result = handler.invoke(...args)\n      if (result.success) {\n        return [result, failures]\n      }\n      failures.push(result)\n    }\n\n    return [undefined, failures]\n  }\n\n  apply(target, thisArg, argumentsList) {\n    const type = 'apply', args = [target, thisArg, argumentsList]\n    const [result, _fails] = tryEachOfType(type, ...args)\n    if (result) { return result }\n    return Reflect[type](...args)\n  }\n\n  construct(target, args) {\n    const type = 'construct', _args = [target, args]\n    const [result, _fails] = tryEachOfType(type, ..._args)\n    if (result) { return result }\n    return Reflect[type](..._args)\n  }\n\n  defineProperty(target, key, descriptor) {\n    const type = 'defineProperty', args = [target, key, descriptor]\n    const [result, _fails] = tryEachOfType(type, ...args)\n    if (result) { return result }\n    return Reflect[type](...args)\n  }\n\n  deleteProperty(target, property) {\n    const type = 'deleteProperty', args = [target, property]\n    const [result, _fails] = tryEachOfType(type, ...args)\n    if (result) { return result }\n    return Reflect[type](...args)\n  }\n\n  get(target, property, receiver) {\n    const type = 'get', args = [target, property, receiver]\n    const [result, _fails] = tryEachOfType(type, ...args)\n    if (result) { return result }\n    return Reflect[type](...args)\n  }\n\n  getOwnPropertyDescriptor(target, property) {\n    const type = 'getOwnPropertyDescriptor', args = [target, property]\n    const [result, _fails] = tryEachOfType(type, ...args)\n    if (result) { return result }\n    return Reflect[type](...args)\n  }\n\n  getPrototypeOf(target) {\n    const type = 'getPrototypeOf', args = [target]\n    const [result, _fails] = tryEachOfType(type, ...args)\n    if (result) { return result }\n    return Reflect[type](...args)\n  }\n\n  has(target, property) {\n    const type = 'has', args = [target, property]\n    const [result, _fails] = tryEachOfType(type, ...args)\n    if (result) { return result }\n    return Reflect[type](...args)\n  }\n\n  isExtensible(target) {\n    const type = 'isExtensible', args = [target]\n    const [result, _fails] = tryEachOfType(type, ...args)\n    if (result) { return result }\n    return Reflect[type](...args)\n  }\n\n  ownKeys(target) {\n    const type = 'ownKeys', args = [target]\n    const [result, _fails] = tryEachOfType(type, ...args)\n    if (result) { return result }\n    return Reflect[type](...args)\n  }\n\n  preventExtensions(target) {\n    const type = 'preventExtensions', args = [target]\n    const [result, _fails] = tryEachOfType(type, ...args)\n    if (result) { return result }\n    return Reflect[type](...args)\n  }\n\n  set(target, property, value, receiver) {\n    const type = 'set', args = [target, property, value, receiver]\n    const [result, _fails] = tryEachOfType(type, ...args)\n    if (result) { return result }\n    return Reflect[type](...args)\n  }\n\n  setPrototypeOf(target, prototype) {\n    const type = 'setPrototypeOf', args = [target, prototype]\n    const [result, _fails] = tryEachOfType(type, ...args)\n    if (result) { return result }\n    return Reflect[type](...args)\n  }\n\n  static get kCreated() {\n    return Symbol.for('pp.prototype.created')\n  }\n\n  static get kOriginal() {\n    return Symbol.for('pp.prototype.original')\n  }\n\n  static get kProxy() {\n    return Symbol.for('pp.proxy')\n  }\n}\n\nexport const ProxyHandlerExtensions = new Extension(ProxyHandler)\nexport const PluggableProxyExtensions = new Extension(PluggableProxy)\n\n\nexport const PluggableProxyExtensionSet = new Extension.ExtensionSet(\n  'PluggableProxyExtensionSet',\n  ProxyHandlerExtensions,\n  PluggableProxyExtensions\n)", "import { Patch } from '@nejs/extension'\n\nexport const WeakRefExtensions = new Patch(WeakRef, {\n  /**\n   * A static method to check if a given value is a valid target for a WeakRef.\n   *\n   * @param {*} value - The value to check for validity as a WeakRef target.\n   * @returns {boolean} - True if the value is a valid WeakRef target,\n   * false otherwise.\n   */\n  isValidReference(value) {\n    return !(\n      (typeof value === 'symbol' && Symbol.keyFor(value) === undefined) ||\n      (typeof value !== 'object' && typeof value !== 'symbol') ||\n      (value === null || value === undefined)\n    )\n  },\n})", "import { Extension } from '@nejs/extension'\n\nimport { ObjectExtensions } from '../object.extensions.js'\nimport { SymbolExtensions } from '../symbol.extensions.js'\nimport { WeakRefExtensions } from '../weakref.extensions.js'\n\nimport { Iterable, Iterator } from './iterable.js'\n\nconst { isObject, isNullDefined, isValidKey } = ObjectExtensions.patches\nconst { isRegistered } = SymbolExtensions.patches\nconst { isValidReference } = WeakRefExtensions.patches\n\n/**\n * RefMap class extends the standard Map object to manage a collection of\n * WeakRef values mapped to strong keys. It provides additional functionality\n * such as objectification of values and various utility methods.\n *\n * Unlike standard Maps or Objects, RefMap stores weak references to objects,\n * allowing them to be garbage-collected if there are no other references to\n * them. This behavior is different from Maps and standard Objects, which\n * maintain strong references to their elements.\n *\n * @extends Map\n */\nexport class RefMap extends Map {\n  /**\n   * Private field to track whether the RefMap should objectify primitive\n   * values.\n   *\n   * @private\n   */\n  #objectifyValues = false\n\n  constructor(...args) {\n    super(...args)\n  }\n\n  /**\n   * Method to control whether the RefMap should objectify its values. When\n   * objectifying, primitive values (number, string, boolean, bigint) are\n   * converted to their respective object types, which allows them to be used as\n   * WeakRef targets.\n   *\n   * @param {boolean} setObjectification - Flag to enable or disable\n   * objectification.\n   * @returns {RefMap} - The current RefMap instance to allow method chaining.\n   */\n  objectifying(setObjectification = true) {\n    this.objectifyValues = setObjectification\n    return this\n  }\n\n  /**\n   * The function converts a JavaScript Map object into a regular JavaScript\n   * object, handling invalid keys by converting them to strings.\n   *\n   * @returns {object} an object; keys that are not either a `String` or a\n   * `Symbol` will be converted to a string.\n   */\n  asObject() {\n    const object = {}\n\n    for (const [key, value] of this) {\n      const useKey = isValidKey(key) ? key : String(key)\n      const useValue = value?.valueOf() || value\n\n      object[useKey] = useValue\n    }\n\n    return object\n  }\n\n  /**\n   * Returns the state indicating whether or not `RefMap` will attempt to\n   * convert non-valid primitives into targets that are valid input for\n   * new `WeakRef` object instances. If this value is `false` then no\n   * *objectification* will occur.\n   *\n   * @returns {boolean} The current state of objectifyValues.\n   */\n  get objectifyValues() {\n    return this.#objectifyValues\n  }\n\n\n  /**\n   * The `get` function retrieves a value from a map and returns it, or returns a\n   * default value if the value is null or undefined. The actual retrieved value\n   * is a dereferenced `WeakRef`. If the result is `undefined` and this is not the\n   * expected response, it is likely the value has been garbage collected.\n   *\n   * @param {any} key - The key parameter is the key of the value you want to\n   * retrieve from the data structure.\n   * @param {any} defaultValue - The `defaultValue` parameter is the value that\n   * will be returned if the key does not exist in the map or if the value\n   * associated with the key has been garbage collected (i.e., it no longer\n   * exists).\n   * @returns The method is returning the value associated with the given key.\n   * If the value is not found or if it has been garbage collected (deref()\n   * returns null), then the defaultValue is returned.\n   */\n  get(key, defaultValue) {\n    const value = super.get(key)\n\n    if (!value || !value?.deref()) {\n      return defaultValue\n    }\n\n    return value?.deref()\n  }\n\n  /**\n   * Setting this value to true, will cause all set values to the Map to\n   * be analyzed for validity as a candidate to be wrapped in a `WeakRef`\n   * object. If true, and if possible, the object will be turned into an\n   * `Object` variant first.\n   *\n   * @param {boolean} value - The new state to set for objectifyValues.\n   */\n  set objectifyValues(value) {\n    this.#objectifyValues = !!value\n  }\n\n  /**\n   * Overrides the set method of `Map`. Adds a value to the `RefMap`,\n   * converting it to a `WeakRef`. Throws an error if the value is not a\n   * valid `WeakRef` target (e.g., `null`, `undefined`, or a registered\n   * `symbol`). If {@link objectifyValues} is enabled, an attempt to convert\n   * primitives to their object variants will be made. These are `numbers`,\n   * `strings`, `boolean` values and `bigint`s.\n   *\n   * @param {*} key - The `key` to be set on the `RefMap`\n   * @param {*} value - The value to be associated with the `key`\n   * @throws {TypeError} If the value is not a valid WeakRef target.\n   */\n  set(key, value) {\n    let useValue = value\n\n    // Objectify the value if needed\n    if (this.#objectifyValues && (\n      typeof useValue === 'number' ||\n      typeof useValue === 'string' ||\n      typeof useValue === 'boolean' ||\n      typeof useValue === 'bigint'\n    )) {\n      useValue = Object(useValue);\n    }\n\n    // Check if the value is an object, and if it's a symbol, ensure it's not registered\n    if (typeof useValue === 'symbol' && Symbol.keyFor(useValue) !== undefined) {\n      throw new TypeError('RefMap cannot accept registered symbols as values');\n    }\n\n    if (typeof useValue !== 'object' && typeof useValue !== 'symbol') {\n      throw new TypeError(\n        'RefMap values must be objects, non-registered symbols, or objectified primitives'\n      );\n    }\n\n    // If the value is null or undefined, throw an error\n    if (useValue === null || useValue === undefined) {\n      throw new TypeError('RefMap values cannot be null or undefined');\n    }\n\n    const ref = new WeakRef(useValue)\n\n    super.set(key, ref)\n  }\n\n  /**\n   * Sets multiple values at a single time. The format is an array of array\n   * or rather an array of {@link Object.entries} (for example,\n   * `[[key1,value1], [key2,value2]]`). For each entry pair, if the length\n   * is not 2, either missing a key or value, it will be skipped.\n   *\n   * @param {Iterable} values - An iterable of values to add to the RefMap.\n   * @throws {TypeError} If the supplied values are falsey or non-iterable.\n   * @returns {RepMap} returns `this` to allow for chaining\n   */\n  setAll(entries) {\n    if (!Iterable.isIterable(entries)) {\n      throw new TypeError(\n        'The supplied list of entries must be an array of arrays in the ' +\n        'format [[key1, value1], [key2, value2], ...].'\n      )\n    }\n\n    const forEach = entry => {\n      const [key, value] = entry\n\n      if (!key || !isObject(value) || !isRegistered(value)) {\n        return\n      }\n\n      this.set(key, value)\n    }\n\n    for (const entry of entries) {\n      forEach(entry)\n    }\n\n    return this\n  }\n\n  /**\n   * Removes all elements from the RefMap that have been garbage collected\n   * (i.e., their WeakRef no longer points to an object).\n   *\n   * @returns {RefMap} - The current RefMap instance to allow method chaining.\n   */\n  clean() {\n    for (const [key, dereferenced] of this) {\n      if (!dereferenced) {\n        this.delete(key)\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Executes a provided function once for each value in the RefMap. The callback\n   * function receives the dereferenced value, the value again (as RefMap doesn't\n   * use keys), and the RefMap itself. This method provides a way to iterate over\n   * and apply operations to the values stored in the RefMap, taking into account\n   * that they are weak references and may have been garbage-collected.\n   *\n   * @param {Function} forEachFn - Function to execute for each element. It\n   * takes three arguments: element, element (again, as RefMap has no key), and\n   * the RefMap itself.\n   * @param {*} thisArg - Value to use as `this` when executing `forEachFn`.\n   */\n  entries() {\n    const entriesIterator = super.entries()\n    const refIterator = new Iterator(entriesIterator, (entry) => {\n      if (entry) {\n        const [key, ref] = entry\n        const value = ref?.deref()\n\n        return [key, value]\n      }\n\n      return entry\n    })\n\n    return refIterator\n  }\n\n  /**\n   * Iterate over the items in the map and pass them to the supplied\n   * function ala `Map.prototype.forEach`. Note however, there are no\n   * indexes on Maps and as such, the index parameter of the callback\n   * will always be the value's key. Subsequently the `array` or third\n   * parameter will receive the map instance rather than an array.\n   *\n   * @param {function} forEachFn the function to use for each element in\n   * the set.\n   * @param {object} thisArg the `this` argument to be applied to each\n   * invocation of the `forEachFn` callback. Note, this value is unable\n   * to be applied if the `forEachFn` is a big arrow function\n   */\n  forEach(forEachFn, thisArg) {\n    for (const [key, ref] of super.entries()) {\n      const value = ref?.deref()\n\n      if (!value) {\n        continue\n      }\n\n      forEachFn.call(thisArg, value, key, this)\n    }\n  }\n\n  /**\n   * Returns an iterator for the values in the RefMap. Each value is\n   * dereferenced from its WeakRef before being returned. This method allows\n   * iterating over he set's values, similar to how one would iterate over\n   * values in a standard Map or Array, but with the understanding that the\n   * values are weakly referenced and may no longer exist (in which case\n   * they are skipped).\n   *\n   * @returns {Iterator} An iterator for the values.\n   */\n  values() {\n    return new Iterator(super.values(), function perItem(value) {\n      const dereferenced = value?.deref()\n      return dereferenced || value\n    })\n  }\n\n  /**\n   * Determines whether an element with the specified value exists in the\n   * `RefMap`. For non-objectified sets, this method checks if the dereferenced\n   * values of the map include the specified value.\n   *\n   * For objectified sets, strict is set to false which uses loose\n   * equality to allow for things like `Object(5)` to equal `5`. This is important\n   * because otherwise primitives could not be weakly referenced. In the grand\n   * scheme of things, this is only useful if the objectified value is the\n   * one being referenced.\n   *\n   * @param {*} value - The value to check for presence in the RefMap.\n   * @param {boolean} strict - if `true`, the default, then the supplied value\n   * is hard compared to the dereferenced value (`===`). If `false`, then a\n   * loose comparison is used (`==`)\n   * @returns {boolean} - True if an element with the specified value exists\n   * in the RefMap, false otherwise.\n   */\n  hasValue(value, strict = true) {\n    if (isNullDefined(value)) {\n      return false\n    }\n\n    if (this.#objectifyValues) {\n      strict = false\n    }\n\n    for (const [_, dereferenced] of this) {\n      if (\n        (strict && value === dereferenced) ||\n        (!strict && value == dereferenced)\n      ) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * The `filter` function filters the entries of a `RefMap` object based on\n   * a given filter function. The dereferenced entries of the values of the map\n   * will be passed to the function rather than a `WeakRef` itself.\n   *\n   * A new resulting entry set will be generated and a new `RefMap` will be made\n   * from these entries and returned. Note that this function never returns\n   * `null`\n   *\n   * @param {function} filterFn - The `filterFn` parameter is a function that\n   * will be used to filter the entries in the `RefMap`. It will be called with\n   * three arguments: the value of the current entry, the key of the current\n   * entry, and the `RefMap` itself. The function should return `true`\n   * @param {object} thisArg - The `thisArg` parameter is an optional argument\n   * that specifies the value to be used as `this` when executing the\n   * `filterFn` function. It allows you to explicitly set the context in which\n   * the `filterFn` function is called. If `thisArg` is not provided, `this\n   * @returns {array} The `filter` method is returning an array of filtered map\n   * entries\n   */\n  filter(filterFn, thisArg) {\n    const resultingEntries = []\n\n    for (const [key, dereferenced] of this) {\n      if (filterFn.call(thisArg, dereferenced, key, this)) {\n        resultingEntries.push([key, dereferenced])\n      }\n    }\n\n    return resultingEntries\n  }\n\n  /**\n   * The `find` function iterates over a map and calls a given function on\n   * each value, returning the first value for which the function returns\n   * a truthy value.\n   *\n   * The function signature of `findFn` is\n   * ```\n   * function findFn(value, key, map)\n   * ```\n   * 'value' is passed to findFn up to two times; first with the `WeakRef`\n   * value, second with the result of {@link WeakRef.deref}. If `findFn`\n   * returns true for either of these the dereferenced value will be\n   * returned from the call to {@link RefMap.find}.\n   * `key` represents the key object that the value is mapped to.\n   * `map` is simply a reference to `this` map.\n   *\n   * @param findFn - `findFn` is a function that will be called for each\n   * element in the map. It takes three arguments: `ref`, `key`, and `map`;\n   * where `ref` is the value of the current element in the map, `key` is\n   * the key of the current element, and `map` is a reference to the instance\n   * being searched.\n   * @param thisArg - The `thisArg` parameter is the value to be used as\n   * the `this` value when executing the `findFn` function. It allows you\n   * to specify the context in which the `findFn` function should be called.\n   * @returns the first dereferenced value that satisfies the condition\n   * specified by the `findFn` function. If no value satisfies the condition,\n   * it returns `null`.\n   */\n  find(findFn, thisArg) {\n    for (const [key, dereferenced] of this) {\n      const ref = super.get(key)\n      let result = findFn.call(thisArg, ref, key, map)\n\n      if (!result) {\n        result = findFn.call(thisArg, dereferenced, key, map)\n      }\n\n      if (result) {\n        return dereferenced\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Creates a new array or `RefMap` with the results of calling a provided\n   * function on every element in the calling `RefMap`. This method dereferences\n   * each value, applies the `mapFn`, and collects the results. If `toRefMap` is\n   * `true`, a new `RefMap` is returned; otherwise, an array. This method\n   * differs from `Array.map` in handling weak references and the potential to\n   * return a new `RefMap` instead of an array.\n   *\n   * @param {Function} mapFn - Function that produces an element of the new\n   * array or `RefMap`, taking three arguments.\n   * @param {*} thisArg - Value to use as this when executing mapFn.\n   * @param {boolean} toRefMap - Determines if the output should be a new\n   * `RefMap` (`true`) or an array (`false`).\n   * @param {boolean} mirrorObjectification - If `true` and `toRefMap` is\n   * `true`, the new `RefMap` mirrors the objectification setting of the\n   * original.\n   * @returns {Array|RefMap} - A new array or `RefMap` with each element being\n   * the result of the `mapFn`.\n   */\n  map(mapFn, thisArg, toRefMap, mirrorObjectification) {\n    if (typeof mapFn !== 'function') {\n      throw new TypeError('mapFn must be a function! Received', mapFn)\n    }\n\n    const entries = []\n    const errors = []\n\n    let needsObjectification = mirrorObjectification && this.objectifyValues\n    let detectNeed = mirrorObjectification === undefined\n    let objectify = needsObjectification\n\n    for (const [key, dereferenced] of this) {\n      const [, VALUE] = [0,1]\n      const transformed = mapFn.call(thisArg, [key, dereferenced], key, this)\n\n      if (!isValidReference(transformed[VALUE])) {\n        if (isValidReference(Object(transformed[VALUE]))) {\n          needsObjectification = true\n          if (detectNeed && !objectify) {\n            objectify = true\n            transformed[VALUE] = Object(transformed[VALUE])\n          }\n        }\n      }\n\n      entries.push(transformed)\n    }\n\n    if (toRefMap) {\n      return new RefMap(entries).objectifying(objectify)\n    }\n\n    return entries\n  }\n\n  /**\n   * The function returns an iterator that iterates over the entries of an object,\n   * dereferencing any weak references.\n   *\n   * @returns {Iterator} A new iterator object is being returned.\n   */\n  *[Symbol.iterator]() {\n    for (const [key, ref] of this.entries()) {\n      yield [key, ref]\n    }\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n\nexport const RefMapExtensions = new Extension(RefMap)", "import { Extension } from '@nejs/extension'\n\n/**\n * RefSet class extends the standard Set object to manage a collection of\n * WeakRef objects. It provides additional functionality such as objectification\n * of values and various utility methods.\n *\n * Unlike standard Sets or Arrays, RefSet stores weak references to objects,\n * allowing them to be garbage-collected if there are no other references to\n * them. This behavior is different from Arrays and standard Sets, which\n * maintain strong references to their elements.\n *\n * @extends Set\n */\nexport class RefSet extends Set {\n  /**\n   * Private field to track whether the RefSet should objectify primitive\n   * values.\n   *\n   * @private\n   */\n  #objectifyValues = false\n\n  /**\n   * Method to control whether the RefSet should objectify its values. When\n   * objectifying, primitive values (number, string, boolean, bigint) are\n   * converted to their respective object types, which allows them to be used as\n   * WeakRef targets.\n   *\n   * @param {boolean} setObjectification - Flag to enable or disable\n   * objectification.\n   * @returns {RefSet} - The current RefSet instance to allow method chaining.\n   */\n  objectifying(setObjectification = true) {\n    this.objectifyValues = setObjectification\n    return this\n  }\n\n  /**\n   * Returns the state indicating whether or not `RefSet` will attempt to\n   * convert non-valid primitives into targets that are valid input for\n   * new `WeakRef` object instances. If this value is `false` then no\n   * *objectification* will occur.\n   *\n   * @returns {boolean} The current state of objectifyValues.\n   */\n  get objectifyValues() {\n    return this.#objectifyValues\n  }\n\n  /**\n   * Setting this value to true, will cause all added values to the Set to\n   * be analyzed for validity as a candidate to be wrapped in a `WeakRef`\n   * object. If true, and if possible, the object will be turned into an\n   * `Object` variant first. This will also enable less rigid variable\n   * comparison in the `.has()` method (i.e. `==` instead of `===`).\n   *\n   * @param {boolean} value - The new state to set for objectifyValues.\n   */\n  set objectifyValues(value) {\n    this.#objectifyValues = !!value\n  }\n\n  /**\n   * Overrides the add method of Set. Adds a value to the RefSet, converting it\n   * to a WeakRef. Throws an error if the value is not a valid WeakRef target\n   * (e.g., null, undefined, or a registered symbol). If `objectifyValues` is\n   * enabled, an attempt to convert primitives to their object variants will be\n   * made. These are numbers, strings, boolean values and big integers.\n   *\n   * @param {*} value - The value to be added to the RefSet.\n   * @throws {TypeError} If the value is not a valid WeakRef target.\n   */\n  add(value) {\n    // Objectify the value if needed\n    if (this.#objectifyValues && (\n      typeof value === 'number' ||\n      typeof value === 'string' ||\n      typeof value === 'boolean' ||\n      typeof value === 'bigint'\n    )) {\n      value = Object(value);\n    }\n\n    // Check if the value is an object, and if it's a symbol, ensure it's not registered\n    if (typeof value === 'symbol' && Symbol.keyFor(value) !== undefined) {\n      throw new TypeError('RefSet cannot accept registered symbols as values');\n    }\n\n    if (typeof value !== 'object' && typeof value !== 'symbol') {\n      throw new TypeError(\n        'RefSet values must be objects, non-registered symbols, or objectified primitives'\n      );\n    }\n\n    // If the value is null or undefined, throw an error\n    if (value === null || value === undefined) {\n      throw new TypeError('RefSet values cannot be null or undefined');\n    }\n\n    super.add(new WeakRef(value));\n  }\n\n  /**\n   * Adds multiple values to the RefSet. The supplied `values` should be\n   * iterable and truthy. This function defers to `.add()` for its logic so\n   * each value from the supplied collection of values will also be subject\n   * to the criteria of that function.\n   *\n   * @param {Iterable} values - An iterable of values to add to the RefSet.\n   * @throws {TypeError} If the supplied values are falsey or non-iterable.\n   */\n  addAll(values) {\n    if (\n      !values ||\n      (typeof values !== 'object') ||\n      !Reflect.has(values, Symbol.iterator)\n    ) {\n      throw new TypeError('The supplied values are either falsey or non-iterable')\n    }\n\n    for (const value of values) {\n      this.add(value)\n    }\n  }\n\n  /**\n   * Removes all elements from the RefSet that have been garbage collected\n   * (i.e., their WeakRef no longer points to an object).\n   *\n   * @returns {RefSet} - The current RefSet instance to allow method chaining.\n   */\n  clean() {\n    for (const ref of this) {\n      if (!ref.deref()) {\n        this.delete(ref)\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Executes a provided function once for each value in the RefSet. The callback\n   * function receives the dereferenced value, the value again (as RefSet doesn't\n   * use keys), and the RefSet itself. This method provides a way to iterate over\n   * and apply operations to the values stored in the RefSet, taking into account\n   * that they are weak references and may have been garbage-collected.\n   *\n   * @param {Function} forEachFn - Function to execute for each element. It\n   * takes three arguments: element, element (again, as RefSet has no key), and\n   * the RefSet itself.\n   * @param {*} thisArg - Value to use as `this` when executing `forEachFn`.\n   */\n  entries() {\n    const refEntries = Array.from(super.entries())\n\n    return refEntries\n      .map(([_, ref]) => [ref.deref(), ref.deref()])\n      .filter(([_, value]) => !!value)\n  }\n\n  /**\n   * Iterate over the items in the set and pass them to the supplied\n   * function ala `Array.prototype.forEach`. Note however, there are no\n   * indexes on Sets and as such, the index parameter of the callback\n   * will always be `NaN`. Subsequently the `array` or third parameter\n   * will receive the set instance rather than an array.\n   *\n   * @param {function} forEachFn the function to use for each element in\n   * the set.\n   * @param {object} thisArg the `this` argument to be applied to each\n   * invocation of the `forEachFn` callback. Note, this value is unable\n   * to be applied if the `forEachFn` is a big arrow function\n   */\n  forEach(forEachFn, thisArg) {\n    const set = this\n\n    super.forEach(function(ref) {\n      const value = ref.deref()\n\n      if (!value) {\n        return\n      }\n\n      forEachFn.call(thisArg, value, value, set)\n    })\n  }\n\n  /**\n   * Returns an iterator for the values in the RefSet. Each value is\n   * dereferenced from its WeakRef before being returned. This method allows\n   * iterating over he set's values, similar to how one would iterate over\n   * values in a standard Set or Array, but with the understanding that the\n   * values are weakly referenced and may no longer exist (in which case\n   * they are skipped).\n   *\n   * @returns {Iterator} An iterator for the values.\n   */\n  values() {\n    const values = []\n\n    for (const value of this) {\n      const dereferenced = value.deref()\n\n      if (dereferenced) {\n        values.push(dereferenced)\n      }\n    }\n\n    return values\n  }\n\n  /**\n   * Returns an iterator for the keys of the RefSet. In RefSet, keys and\n   * values are identical, so this method behaves the same as `values()`. It\n   * provides compatibility with the standard Set interface and allows use in\n   * contexts where keys are expected, despite RefSet not differentiating\n   * between keys and values.\n   *\n   * @returns {Iterator} An iterator for the keys.\n   */\n  keys() {\n    return this.values()\n  }\n\n  /**\n   * Determines whether an element with the specified value exists in the\n   * `RefSet`. For non-objectified sets, this method checks if the dereferenced\n   * values of the set include the specified value.\n   *\n   * For objectified sets, it uses the `contains` method which accounts for\n   * the objectification. This method differs from standard Set `has` in that\n   * it works with weak references and considers objectification settings.\n   *\n   * @param {*} value - The value to check for presence in the RefSet.\n   * @returns {boolean} - True if an element with the specified value exists\n   * in the RefSet, false otherwise.\n   */\n  has(value) {\n    if (this.#objectifyValues) {\n      return this.contains(value)\n    }\n\n    for (const item of this.values()) {\n      if (item === value) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Checks if the RefSet contains a value that is equal to the specified\n   * value. This method is used primarily in objectified RefSets to determine\n   * the presence of a value, taking into account objectification. It differs\n   * from the `has` method in that it's tailored for sets that have\n   * transformed their primitive values into objects, whereas `has` is more\n   * general-purpose.\n   *\n   * @param {*} value - The value to search for in the RefSet.\n   * @returns {boolean} - True if the RefSet contains the value, false otherwise.\n   */\n  contains(value) {\n    return !!(Array.from(this.values())\n      .filter(dereferencedValue => {\n       return value == dereferencedValue\n      })\n      .length\n    )\n  }\n\n  /**\n   * Creates a new array with all elements that pass the test implemented by\n   * the provided function. This method iterates over each element,\n   * dereferences it, and applies the filter function. Unlike Array `filter`,\n   * the callback receives the dereferenced value and not an index or array,\n   * reflecting the non-indexed nature of RefSet. Useful for selectively\n   * creating arrays from the set based on certain conditions, especially when\n   * dealing with weak references.\n   *\n   * @param {Function} filterFn - Function to test each element of the RefSet.\n   * The function receives the dereferenced value.\n   * @param {*} thisArg - Value to use as `this` when executing `filterFn`.\n   * @returns {Array} - A new array with the elements that pass the test.\n   */\n  filter(filterFn, thisArg) {\n    const results = []\n\n    for (const value of this) {\n      const dereferenced = value?.deref()\n\n      if (dereferenced) {\n        const include = filterFn.call(thisArg, dereferenced, NaN, this)\n\n        if (include) {\n          results.push(dereferenced)\n        }\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * Returns the value of the first element in the RefSet that satisfies the\n   * provided testing function. Similar to Array `find`, this method iterates\n   * over the RefSet, dereferencing each value and applying the testing\n   * function. The non-indexed nature of RefSet is considered, as the\n   * callback does not receive an index. This method is useful for finding a\n   * specific element based on a condition.\n   *\n   * @param {*} thisArg - Value to use as this when executing findFn.\n   * @returns {*} - The value of the first element in the RefSet that satisfies\n   * the testing function, or undefined if none found.\n   * @returns {any} the dereferenced value if found, or undefined otherwise\n   */\n  find(findFn, thisArg) {\n    for (const value of this) {\n      const dereferenced = value?.deref()\n\n      if (dereferenced) {\n        const found = findFn.call(thisArg, dereferenced, NaN, this)\n\n        if (found) {\n          return dereferenced\n        }\n      }\n    }\n\n    return undefined\n  }\n\n  /**\n   * Creates a new array or `RefSet` with the results of calling a provided\n   * function on every element in the calling `RefSet`. This method dereferences\n   * each value, applies the `mapFn`, and collects the results. If `toRefSet` is\n   * `true`, a new `RefSet` is returned; otherwise, an array. This method\n   * differs from `Array.map` in handling weak references and the potential to\n   * return a new `RefSet` instead of an array.\n   *\n   * @param {Function} mapFn - Function that produces an element of the new\n   * array or `RefSet`, taking three arguments.\n   * @param {*} thisArg - Value to use as this when executing mapFn.\n   * @param {boolean} toRefSet - Determines if the output should be a new\n   * `RefSet` (`true`) or an array (`false`).\n   * @param {boolean} mirrorObjectification - If `true` and `toRefSet` is\n   * `true`, the new `RefSet` mirrors the objectification setting of the\n   * original.\n   * @returns {Array|RefSet} - A new array or `RefSet` with each element being\n   * the result of the `mapFn`.\n   */\n  map(mapFn, thisArg, toRefSet, mirrorObjectification) {\n    const mapped = []\n\n    let validRefSetOutput = true\n    let validRefSetOutputIfObjectified = true\n\n    for (const value of this) {\n      const dereferenced = value?.deref()\n\n      if (dereferenced) {\n        const mappedItem = mapFn.call(thisArg, dereferenced, NaN, this)\n\n        if (validRefSetOutput || validRefSetOutputIfObjectified) {\n          const weakReferenceable = this.#validWeakRefTarget(mappedItem)\n\n          if (!weakReferenceable) {\n            validRefSetOutput = false\n\n            if (validRefSetOutputIfObjectified) {\n              validRefSetOutputIfObjectified =\n                this.#validWeakRefTarget(Object(mappedItem))\n            }\n          }\n        }\n\n        mapped.push(mappedItem)\n      }\n    }\n\n    if (toRefSet) {\n      if (validRefSetOutput) {\n        return new RefSet(mapped).objectifying(\n          mirrorObjectification ? this.objectifyValues : false\n        )\n      }\n\n      if (validRefSetOutputIfObjectified) {\n        return new RefSet(mapped.map(value => {\n          return this.#validWeakRefTarget(value) ? value : Object(value)\n        })).objectifying()\n      }\n    }\n\n    return mapped\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Private method to check if a given value is a valid target for a WeakRef.\n   *\n   * @param {*} value - The value to check for validity as a WeakRef target.\n   * @returns {boolean} - True if the value is a valid WeakRef target,\n   * false otherwise.\n   * @private\n   */\n  #validWeakRefTarget(value) {\n    return !(\n      (typeof value === 'symbol' && Symbol.keyFor(value) === undefined) ||\n      (typeof value !== 'object' && typeof value !== 'symbol') ||\n      (value === null || value === undefined)\n    )\n  }\n}\n\nexport const RefSetExtensions = new Extension(RefSet)", "import { Extension } from '@nejs/extension'\n\nimport { Introspector } from './introspector.js'\n\nexport class Type {\n  mapped = new Map(Type.mapped.entries())\n\n  of(value) { return Type.of(value) }\n  class(value) { return Type.class(value) }\n  isPrimitive(value) { return Type.isPrimitive(value) }\n\n  static is(value, ofType) {\n    const name = Type.of(value)\n    return name === Type.name(ofType)\n  }\n\n  static of(value) {\n    return typeof value\n  }\n\n  static named(value) {\n    const tag = / (.*?)\\]/.exec(Object.prototype.toString.call(value))?.[1]\n    const name = (\n      value?.[Symbol.toStringTag] ??\n      tag ??\n      (value instanceof Function ? value.name : undefined) ??\n      Type.mapped.get(typeof value).name\n    )\n\n    return name\n  }\n\n  static class(value, mapped) {\n    mapped = mapped ?? Type.mapped\n\n    const name = (\n      value?.[Symbol.toStringTag] ??\n      (value instanceof Function ? value.name : undefined) ??\n      typeof value\n    )\n\n    const type = mapped.has(name)\n      ? Type.mapped.get(name)\n      : value?.constructor\n\n    if (Type.of(type) === 'function' && !mapped.has(name) && this !== Type) {\n      mapped.set(name, type)\n      mapped.set(type, name)\n    }\n\n    return !type ? mapped.get(typeof value) : type\n  }\n\n  static isPrimitive(value) {\n    return new Set([...Type.primitives]).has(typeof value)\n  }\n\n  static get primitives() {\n    return function*() {\n      yield 'bigint'\n      yield 'boolean'\n      yield 'number'\n      yield 'string'\n      yield 'symbol'\n      yield 'undefined'\n    }\n  }\n\n  static get typeOfTypes() {\n    return function*() {\n      yield 'bigint'\n      yield 'boolean'\n      yield 'function'\n      yield 'number'\n      yield 'object'\n      yield 'string'\n      yield 'symbol'\n      yield 'undefined'\n    }\n  }\n\n  static mapped = new Map([\n    ['bigint',BigInt],\n    ['boolean',Boolean],\n    ['function',Function],\n    ['number',Number],\n    ['object',Object],\n    ['string',String],\n    ['symbol',Symbol],\n    ['undefined',undefined],\n    [BigInt, 'bigint'],\n    [Boolean, 'boolean'],\n    [Function, 'function'],\n    [Number, 'number'],\n    [Object, 'object'],\n    [String, 'string'],\n    [Symbol, 'symbol'],\n    [BigInt.name, BigInt],\n    [Boolean.name, Boolean],\n    [Function.name, Function],\n    [Number.name, Number],\n    [Object.name, Object],\n    [String.name, String],\n    [Symbol.name, Symbol],\n    [undefined, 'undefined'],\n  ])\n\n  serverJs = {\n    nodejs: {\n      'v21.1.0': {\n        version: 'v21.1.0',\n        date: new Date('2024-04-21T15:58:12.490Z'),\n        classes: Introspector.addExpansion([\n          'AbortController', 'AbortSignal', 'AggregateError', 'Array',\n          'ArrayBuffer', 'BigInt', 'BigInt64Array', 'BigUint64Array', 'Blob',\n          'Boolean', 'BroadcastChannel', 'Buffer', 'ByteLengthQueuingStrategy',\n          'CompressionStream', 'CountQueuingStrategy', 'Crypto', 'CryptoKey',\n          'CustomEvent', 'DataView', 'Date', 'DecompressionStream', 'DOMException',\n          'Error', 'EvalError', 'Event', 'EventTarget', 'File',\n          'FinalizationRegistry', 'Float32Array', 'Float64Array', 'FormData',\n          'Function', 'Headers', 'Int16Array', 'Int32Array', 'Int8Array', 'Map',\n          'MessageChannel', 'MessageEvent', 'MessagePort', 'Navigator', 'Number',\n          'Object', 'Performance', 'PerformanceEntry', 'PerformanceMark',\n          'PerformanceMeasure', 'PerformanceObserver',\n          'PerformanceObserverEntryList', 'PerformanceResourceTiming', 'Promise',\n          'Proxy', 'RangeError', 'ReadableByteStreamController', 'ReadableStream',\n          'ReadableStreamBYOBReader', 'ReadableStreamBYOBRequest',\n          'ReadableStreamDefaultController', 'ReadableStreamDefaultReader',\n          'ReferenceError', 'RegExp', 'Request', 'Response', 'Set',\n          'SharedArrayBuffer', 'String', 'SubtleCrypto', 'Symbol', 'SyntaxError',\n          'TextDecoder', 'TextDecoderStream', 'TextEncoder', 'TextEncoderStream',\n          'TransformStream', 'TransformStreamDefaultController', 'TypeError',\n          'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray',\n          'URIError', 'URL', 'URLSearchParams', 'WeakMap', 'WeakRef', 'WeakSet',\n          'WritableStream', 'WritableStreamDefaultController',\n          'WritableStreamDefaultWriter'\n        ]),\n        nodeSpecificClasses: Introspector.addExpansion([\n          'Buffer', 'CryptoKey', 'SharedArrayBuffer', 'SubtleCrypto',\n        ]),\n        functions: Introspector.addExpansion([\n          'assert', 'atob', 'btoa', 'clearImmediate', 'clearInterval',\n          'clearTimeout', 'decodeURI', 'decodeURIComponent', 'encodeURI',\n          'encodeURIComponent', 'escape', 'eval', 'events', 'fetch', 'isFinite',\n          'isNaN', 'parseFloat', 'parseInt', 'queueMicrotask', 'require',\n          'setImmediate', 'setInterval', 'setTimeout', 'stream', 'structuredClone',\n          'unescape',\n        ]),\n        objects: Introspector.addExpansion([\n          'Atomics', 'Intl', 'JSON', 'Math', 'Reflect', 'WebAssembly',\n          '_', '_error', 'async_hooks', 'buffer', 'child_process', 'cluster',\n          'console', 'constants', 'crypto', 'dgram', 'diagnostics_channel', 'dns',\n          'domain', 'fs', 'global', 'globalThis', 'http', 'http2',\n          'https', 'inspector', 'module', 'navigator', 'net', 'os',\n          'path', 'perf_hooks', 'performance', 'process', 'punycode', 'querystring',\n          'readline', 'repl', 'string_decoder', 'sys', 'timers', 'tls',\n          'trace_events', 'tty', 'url', 'util', 'v8', 'vm',\n          'wasi', 'worker_threads', 'zlib'\n        ]),\n        properties: Introspector.addExpansion(['Infinity', 'NaN', 'undefined']),\n        symbols: Introspector.addExpansion([Symbol.toStringTag])\n      },\n    },\n\n    qjs: {\n      'v': {\n        version: 'v',\n        classes: Introspector.addExpansion([\n          'AggregateError', 'Array', 'ArrayBuffer', 'BigInt', 'BigInt64Array',\n          'BigUint64Array', 'Boolean', 'DataView', 'Date', 'Error', 'EvalError',\n          'Float32Array', 'Float64Array', 'Function', 'Int16Array', 'Int32Array',\n          'Int8Array', 'InternalError', 'Map', 'Number', 'Object', 'Promise',\n          'Proxy', 'RangeError', 'ReferenceError', 'RegExp', 'Set',\n          'SharedArrayBuffer', 'String', 'Symbol', 'SyntaxError', 'TypeError',\n          'URIError', 'Uint16Array', 'Uint32Array', 'Uint8Array',\n          'Uint8ClampedArray', 'WeakMap', 'WeakSet',\n        ]),\n        functions: Introspector.addExpansion([\n          'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent',\n          'escape', 'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt',\n          'print', 'unescape'\n        ]),\n        objects: Introspector.addExpansion([\n          'Atomics', 'JSON', 'Math', 'Reflect', '_', 'console',\n          'globalThis', 'os', 'scriptArgs', 'std',\n        ]),\n        properties: Introspector.addExpansion([\n          'Infinity', 'NaN', 'undefined'\n        ]),\n        symbols: Introspector.addExpansion([]),\n      }\n    }\n  }\n\n  browser = {\n    arc: {\n      version: 'Version 1.39.0 (48951)',\n      userAgent: [\n        'Mozilla/5.0',\n        '(Macintosh; Intel Mac OS X 10_15_7)',\n        'AppleWebKit/537.36',\n        '(KHTML, like Gecko)',\n        'Chrome/124.0.0.0',\n        'Safari/537.36'\n      ].join(' '),\n      types: {\n        classes: Introspector.addExpansion([\n          'AbortController', 'AbortSignal', 'AggregateError', 'Array',\n          'ArrayBuffer', 'BigInt', 'BigInt64Array', 'BigUint64Array', 'Blob',\n          'Boolean', 'BroadcastChannel', 'ByteLengthQueuingStrategy',\n          'CompressionStream', 'CountQueuingStrategy', 'Crypto', 'CustomEvent',\n          'DOMException', 'DataView', 'Date', 'DecompressionStream', 'Error',\n          'EvalError', 'Event', 'EventTarget', 'File', 'FinalizationRegistry',\n          'Float32Array', 'Float64Array', 'FormData', 'Function', 'Headers',\n          'Int16Array', 'Int32Array', 'Int8Array', 'Map', 'MessageChannel',\n          'MessageEvent', 'MessagePort', 'Navigator', 'Number', 'Object',\n          'Performance', 'PerformanceEntry', 'PerformanceMark',\n          'PerformanceMeasure', 'PerformanceObserver',\n          'PerformanceObserverEntryList', 'PerformanceResourceTiming', 'Promise',\n          'Proxy', 'RangeError', 'ReadableByteStreamController', 'ReadableStream',\n          'ReadableStreamBYOBReader', 'ReadableStreamBYOBRequest',\n          'ReadableStreamDefaultController', 'ReadableStreamDefaultReader',\n          'ReferenceError', 'RegExp', 'Request', 'Response', 'Set', 'String',\n          'Symbol', 'SyntaxError', 'TextDecoder', 'TextDecoderStream',\n          'TextEncoder', 'TextEncoderStream', 'TransformStream',\n          'TransformStreamDefaultController', 'TypeError', 'URIError', 'URL',\n          'URLSearchParams', 'Uint16Array', 'Uint32Array', 'Uint8Array',\n          'Uint8ClampedArray', 'WeakMap', 'WeakRef', 'WeakSet', 'WritableStream',\n          'WritableStreamDefaultController', 'WritableStreamDefaultWriter'\n        ]),\n        browserClasses: Introspector.addExpansion([\n          \"AbstractRange\", \"AnalyserNode\", \"Animation\", \"AnimationEffect\",\n          \"AnimationEvent\", \"AnimationPlaybackEvent\", \"AnimationTimeline\", \"Attr\",\n          \"Audio\", \"AudioBuffer\", \"AudioBufferSourceNode\", \"AudioContext\",\n          \"AudioData\", \"AudioDestinationNode\", \"AudioListener\", \"AudioNode\",\n          \"AudioParam\", \"AudioParamMap\", \"AudioProcessingEvent\",\n          \"AudioScheduledSourceNode\", \"AudioSinkInfo\", \"AudioWorkletNode\",\n          \"BackgroundFetchManager\", \"BackgroundFetchRecord\",\n          \"BackgroundFetchRegistration\", \"BarProp\", \"BaseAudioContext\",\n          \"BeforeInstallPromptEvent\", \"BeforeUnloadEvent\", \"BiquadFilterNode\",\n          \"BlobEvent\", \"BluetoothUUID\", \"BrowserCaptureMediaStreamTrack\",\n          \"CDATASection\", \"CSSAnimation\", \"CSSConditionRule\", \"CSSContainerRule\",\n          \"CSSCounterStyleRule\", \"CSSFontFaceRule\", \"CSSFontPaletteValuesRule\",\n          \"CSSGroupingRule\", \"CSSImageValue\", \"CSSImportRule\", \"CSSKeyframeRule\",\n          \"CSSKeyframesRule\", \"CSSKeywordValue\", \"CSSLayerBlockRule\",\n          \"CSSLayerStatementRule\", \"CSSMathClamp\", \"CSSMathInvert\", \"CSSMathMax\",\n          \"CSSMathMin\", \"CSSMathNegate\", \"CSSMathProduct\", \"CSSMathSum\",\n          \"CSSMathValue\", \"CSSMatrixComponent\", \"CSSMediaRule\", \"CSSNamespaceRule\",\n          \"CSSNumericArray\", \"CSSNumericValue\", \"CSSPageRule\", \"CSSPerspective\",\n          \"CSSPositionValue\", \"CSSPropertyRule\", \"CSSRotate\", \"CSSRule\",\n          \"CSSRuleList\", \"CSSScale\", \"CSSScopeRule\", \"CSSSkew\", \"CSSSkewX\",\n          \"CSSSkewY\", \"CSSStartingStyleRule\", \"CSSStyleDeclaration\", \"CSSStyleRule\",\n          \"CSSStyleSheet\", \"CSSStyleValue\", \"CSSSupportsRule\",\n          \"CSSTransformComponent\", \"CSSTransformValue\", \"CSSTransition\",\n          \"CSSTranslate\", \"CSSUnitValue\", \"CSSUnparsedValue\",\n          \"CSSVariableReferenceValue\", \"CanvasCaptureMediaStreamTrack\",\n          \"CanvasGradient\", \"CanvasPattern\", \"CanvasRenderingContext2D\",\n          \"ChannelMergerNode\", \"ChannelSplitterNode\", \"CharacterBoundsUpdateEvent\",\n          \"CharacterData\", \"ClipboardEvent\", \"CloseEvent\", \"Comment\",\n          \"CompositionEvent\", \"ConstantSourceNode\",\n          \"ContentVisibilityAutoStateChangeEvent\", \"ConvolverNode\", \"CropTarget\",\n          \"CustomElementRegistry\", \"CustomStateSet\", \"DOMError\",\n          \"DOMImplementation\", \"DOMMatrix\", \"DOMMatrixReadOnly\", \"DOMParser\",\n          \"DOMPoint\", \"DOMPointReadOnly\", \"DOMQuad\", \"DOMRect\", \"DOMRectList\",\n          \"DOMRectReadOnly\", \"DOMStringList\", \"DOMStringMap\", \"DOMTokenList\",\n          \"DataTransfer\", \"DataTransferItem\", \"DataTransferItemList\", \"DelayNode\",\n          \"DelegatedInkTrailPresenter\", \"Document\", \"DocumentFragment\",\n          \"DocumentPictureInPictureEvent\", \"DocumentTimeline\", \"DocumentType\",\n          \"DragEvent\", \"DynamicsCompressorNode\", \"EditContext\", \"Element\",\n          \"ElementInternals\", \"EncodedAudioChunk\", \"EncodedVideoChunk\",\n          \"ErrorEvent\", \"EventCounts\", \"EventSource\", \"External\", \"FeaturePolicy\",\n          \"FileList\", \"FileReader\", \"FocusEvent\", \"FontFace\",\n          \"FontFaceSetLoadEvent\", \"FormDataEvent\", \"FragmentDirective\", \"GainNode\",\n          \"Gamepad\", \"GamepadButton\", \"GamepadEvent\", \"GamepadHapticActuator\",\n          \"Geolocation\", \"GeolocationCoordinates\", \"GeolocationPosition\",\n          \"GeolocationPositionError\", \"HTMLAllCollection\", \"HTMLAnchorElement\",\n          \"HTMLAreaElement\", \"HTMLAudioElement\", \"HTMLBRElement\", \"HTMLBaseElement\",\n          \"HTMLBodyElement\", \"HTMLButtonElement\", \"HTMLCanvasElement\",\n          \"HTMLCollection\", \"HTMLDListElement\", \"HTMLDataElement\",\n          \"HTMLDataListElement\", \"HTMLDetailsElement\", \"HTMLDialogElement\",\n          \"HTMLDirectoryElement\", \"HTMLDivElement\", \"HTMLDocument\", \"HTMLElement\",\n          \"HTMLEmbedElement\", \"HTMLFieldSetElement\", \"HTMLFontElement\",\n          \"HTMLFormControlsCollection\", \"HTMLFormElement\", \"HTMLFrameElement\",\n          \"HTMLFrameSetElement\", \"HTMLHRElement\", \"HTMLHeadElement\",\n          \"HTMLHeadingElement\", \"HTMLHtmlElement\", \"HTMLIFrameElement\",\n          \"HTMLImageElement\", \"HTMLInputElement\", \"HTMLLIElement\",\n          \"HTMLLabelElement\", \"HTMLLegendElement\", \"HTMLLinkElement\",\n          \"HTMLMapElement\", \"HTMLMarqueeElement\", \"HTMLMediaElement\",\n          \"HTMLMenuElement\", \"HTMLMetaElement\", \"HTMLMeterElement\",\n          \"HTMLModElement\", \"HTMLOListElement\", \"HTMLObjectElement\",\n          \"HTMLOptGroupElement\", \"HTMLOptionElement\", \"HTMLOptionsCollection\",\n          \"HTMLOutputElement\", \"HTMLParagraphElement\", \"HTMLParamElement\",\n          \"HTMLPictureElement\", \"HTMLPreElement\", \"HTMLProgressElement\",\n          \"HTMLQuoteElement\", \"HTMLScriptElement\", \"HTMLSelectElement\",\n          \"HTMLSlotElement\", \"HTMLSourceElement\", \"HTMLSpanElement\",\n          \"HTMLStyleElement\", \"HTMLTableCaptionElement\", \"HTMLTableCellElement\",\n          \"HTMLTableColElement\", \"HTMLTableElement\", \"HTMLTableRowElement\",\n          \"HTMLTableSectionElement\", \"HTMLTemplateElement\", \"HTMLTextAreaElement\",\n          \"HTMLTimeElement\", \"HTMLTitleElement\", \"HTMLTrackElement\",\n          \"HTMLUListElement\", \"HTMLUnknownElement\", \"HTMLVideoElement\",\n          \"HashChangeEvent\", \"Highlight\", \"HighlightRegistry\", \"History\",\n          \"IDBCursor\", \"IDBCursorWithValue\", \"IDBDatabase\", \"IDBFactory\",\n          \"IDBIndex\", \"IDBKeyRange\", \"IDBObjectStore\", \"IDBOpenDBRequest\",\n          \"IDBRequest\", \"IDBTransaction\", \"IDBVersionChangeEvent\", \"IIRFilterNode\",\n          \"IdleDeadline\", \"Image\", \"ImageBitmap\", \"ImageBitmapRenderingContext\",\n          \"ImageCapture\", \"ImageData\", \"ImageTrack\", \"ImageTrackList\", \"Ink\",\n          \"InputDeviceCapabilities\", \"InputDeviceInfo\", \"InputEvent\",\n          \"IntersectionObserver\", \"IntersectionObserverEntry\", \"Iterator\",\n          \"KeyboardEvent\", \"KeyframeEffect\", \"LargestContentfulPaint\",\n          \"LaunchParams\", \"LaunchQueue\", \"LayoutShift\", \"LayoutShiftAttribution\",\n          \"Location\", \"MathMLElement\", \"MediaCapabilities\",\n          \"MediaElementAudioSourceNode\", \"MediaEncryptedEvent\", \"MediaError\",\n          \"MediaList\", \"MediaMetadata\", \"MediaQueryList\", \"MediaQueryListEvent\",\n          \"MediaRecorder\", \"MediaSession\", \"MediaSource\", \"MediaSourceHandle\",\n          \"MediaStream\", \"MediaStreamAudioDestinationNode\",\n          \"MediaStreamAudioSourceNode\", \"MediaStreamEvent\", \"MediaStreamTrack\",\n          \"MediaStreamTrackEvent\", \"MediaStreamTrackGenerator\",\n          \"MediaStreamTrackProcessor\", \"MediaStreamTrackVideoStats\", \"MimeType\",\n          \"MimeTypeArray\", \"MouseEvent\", \"MutationEvent\", \"MutationObserver\",\n          \"MutationRecord\", \"NamedNodeMap\", \"NavigateEvent\", \"Navigation\",\n          \"NavigationActivation\", \"NavigationCurrentEntryChangeEvent\",\n          \"NavigationDestination\", \"NavigationHistoryEntry\", \"NavigationTransition\",\n          \"NavigatorUAData\", \"NetworkInformation\", \"Node\", \"NodeFilter\",\n          \"NodeIterator\", \"NodeList\", \"Notification\",\n          \"OfflineAudioCompletionEvent\", \"OfflineAudioContext\", \"OffscreenCanvas\",\n          \"OffscreenCanvasRenderingContext2D\", \"Option\", \"OscillatorNode\",\n          \"OverconstrainedError\", \"PageRevealEvent\", \"PageSwapEvent\",\n          \"PageTransitionEvent\", \"PannerNode\", \"Path2D\",\n          \"PerformanceElementTiming\", \"PerformanceEventTiming\",\n          \"PerformanceLongAnimationFrameTiming\", \"PerformanceLongTaskTiming\",\n          \"PerformanceNavigation\", \"PerformanceNavigationTiming\",\n          \"PerformancePaintTiming\", \"PerformanceScriptTiming\",\n          \"PerformanceServerTiming\", \"PerformanceTiming\", \"PeriodicSyncManager\",\n          \"PeriodicWave\", \"PermissionStatus\", \"Permissions\",\n          \"PictureInPictureEvent\", \"PictureInPictureWindow\", \"Plugin\",\n          \"PluginArray\", \"PointerEvent\", \"PopStateEvent\",\n          \"ProcessingInstruction\", \"Profiler\", \"ProgressEvent\",\n          \"PromiseRejectionEvent\", \"PushManager\", \"PushSubscription\",\n          \"PushSubscriptionOptions\", \"RTCCertificate\", \"RTCDTMFSender\",\n          \"RTCDTMFToneChangeEvent\", \"RTCDataChannel\", \"RTCDataChannelEvent\",\n          \"RTCDtlsTransport\", \"RTCEncodedAudioFrame\", \"RTCEncodedVideoFrame\",\n          \"RTCError\", \"RTCErrorEvent\", \"RTCIceCandidate\", \"RTCIceTransport\",\n          \"RTCPeerConnection\", \"RTCPeerConnectionIceErrorEvent\",\n          \"RTCPeerConnectionIceEvent\", \"RTCRtpReceiver\", \"RTCRtpSender\",\n          \"RTCRtpTransceiver\", \"RTCSctpTransport\", \"RTCSessionDescription\",\n          \"RTCStatsReport\", \"RTCTrackEvent\", \"RadioNodeList\", \"Range\",\n          \"RemotePlayback\", \"ReportingObserver\", \"ResizeObserver\",\n          \"ResizeObserverEntry\", \"ResizeObserverSize\", \"SVGAElement\", \"SVGAngle\",\n          \"SVGAnimateElement\", \"SVGAnimateMotionElement\",\n          \"SVGAnimateTransformElement\", \"SVGAnimatedAngle\", \"SVGAnimatedBoolean\",\n          \"SVGAnimatedEnumeration\", \"SVGAnimatedInteger\", \"SVGAnimatedLength\",\n          \"SVGAnimatedLengthList\", \"SVGAnimatedNumber\", \"SVGAnimatedNumberList\",\n          \"SVGAnimatedPreserveAspectRatio\", \"SVGAnimatedRect\",\n          \"SVGAnimatedString\", \"SVGAnimatedTransformList\", \"SVGAnimationElement\",\n          \"SVGCircleElement\", \"SVGClipPathElement\",\n          \"SVGComponentTransferFunctionElement\", \"SVGDefsElement\", \"SVGDescElement\",\n          \"SVGElement\", \"SVGEllipseElement\", \"SVGFEBlendElement\",\n          \"SVGFEColorMatrixElement\", \"SVGFEComponentTransferElement\",\n          \"SVGFECompositeElement\", \"SVGFEConvolveMatrixElement\",\n          \"SVGFEDiffuseLightingElement\", \"SVGFEDisplacementMapElement\",\n          \"SVGFEDistantLightElement\", \"SVGFEDropShadowElement\", \"SVGFEFloodElement\",\n          \"SVGFEFuncAElement\", \"SVGFEFuncBElement\", \"SVGFEFuncGElement\",\n          \"SVGFEFuncRElement\", \"SVGFEGaussianBlurElement\", \"SVGFEImageElement\",\n          \"SVGFEMergeElement\", \"SVGFEMergeNodeElement\", \"SVGFEMorphologyElement\",\n          \"SVGFEOffsetElement\", \"SVGFEPointLightElement\",\n          \"SVGFESpecularLightingElement\", \"SVGFESpotLightElement\",\n          \"SVGFETileElement\", \"SVGFETurbulenceElement\", \"SVGFilterElement\",\n          \"SVGForeignObjectElement\", \"SVGGElement\", \"SVGGeometryElement\",\n          \"SVGGradientElement\", \"SVGGraphicsElement\", \"SVGImageElement\",\n          \"SVGLength\", \"SVGLengthList\", \"SVGLineElement\",\n          \"SVGLinearGradientElement\", \"SVGMPathElement\", \"SVGMarkerElement\",\n          \"SVGMaskElement\", \"SVGMatrix\", \"SVGMetadataElement\", \"SVGNumber\",\n          \"SVGNumberList\", \"SVGPathElement\", \"SVGPatternElement\", \"SVGPoint\",\n          \"SVGPointList\", \"SVGPolygonElement\", \"SVGPolylineElement\",\n          \"SVGPreserveAspectRatio\", \"SVGRadialGradientElement\", \"SVGRect\",\n          \"SVGRectElement\", \"SVGSVGElement\", \"SVGScriptElement\", \"SVGSetElement\",\n          \"SVGStopElement\", \"SVGStringList\", \"SVGStyleElement\", \"SVGSwitchElement\",\n          \"SVGSymbolElement\", \"SVGTSpanElement\", \"SVGTextContentElement\",\n          \"SVGTextElement\", \"SVGTextPathElement\", \"SVGTextPositioningElement\",\n          \"SVGTitleElement\", \"SVGTransform\", \"SVGTransformList\", \"SVGUnitTypes\",\n          \"SVGUseElement\", \"SVGViewElement\", \"Scheduler\", \"Scheduling\", \"Screen\",\n          \"ScreenOrientation\", \"ScriptProcessorNode\", \"ScrollTimeline\",\n          \"SecurityPolicyViolationEvent\", \"Selection\", \"ShadowRoot\",\n          \"SharedWorker\", \"SourceBuffer\", \"SourceBufferList\", \"SpeechSynthesis\",\n          \"SpeechSynthesisErrorEvent\", \"SpeechSynthesisEvent\",\n          \"SpeechSynthesisUtterance\", \"SpeechSynthesisVoice\", \"StaticRange\",\n          \"StereoPannerNode\", \"Storage\", \"StorageEvent\", \"StylePropertyMap\",\n          \"StylePropertyMapReadOnly\", \"StyleSheet\", \"StyleSheetList\",\n          \"SubmitEvent\", \"SyncManager\", \"TaskAttributionTiming\", \"TaskController\",\n          \"TaskPriorityChangeEvent\", \"TaskSignal\", \"Text\", \"TextEvent\",\n          \"TextFormat\", \"TextFormatUpdateEvent\", \"TextMetrics\", \"TextTrack\",\n          \"TextTrackCue\", \"TextTrackCueList\", \"TextTrackList\", \"TextUpdateEvent\",\n          \"TimeRanges\", \"ToggleEvent\", \"Touch\", \"TouchEvent\", \"TouchList\",\n          \"TrackEvent\", \"TransitionEvent\", \"TreeWalker\", \"TrustedHTML\",\n          \"TrustedScript\", \"TrustedScriptURL\", \"TrustedTypePolicy\",\n          \"TrustedTypePolicyFactory\", \"UIEvent\", \"URLPattern\", \"UserActivation\",\n          \"VTTCue\", \"ValidityState\", \"VideoColorSpace\", \"VideoFrame\",\n          \"VideoPlaybackQuality\", \"ViewTimeline\", \"ViewTransition\",\n          \"VirtualKeyboardGeometryChangeEvent\", \"VisibilityStateEntry\",\n          \"VisualViewport\", \"WaveShaperNode\", \"WebGL2RenderingContext\",\n          \"WebGLActiveInfo\", \"WebGLBuffer\", \"WebGLContextEvent\", \"WebGLFramebuffer\",\n          \"WebGLProgram\", \"WebGLQuery\", \"WebGLRenderbuffer\",\n          \"WebGLRenderingContext\", \"WebGLSampler\", \"WebGLShader\",\n          \"WebGLShaderPrecisionFormat\", \"WebGLSync\", \"WebGLTexture\",\n          \"WebGLTransformFeedback\", \"WebGLUniformLocation\",\n          \"WebGLVertexArrayObject\", \"WebKitCSSMatrix\", \"WebKitMutationObserver\",\n          \"WebSocket\", \"WebSocketError\", \"WebSocketStream\", \"WheelEvent\", \"Window\",\n          \"WindowControlsOverlay\", \"WindowControlsOverlayGeometryChangeEvent\",\n          \"Worker\", \"XMLDocument\", \"XMLHttpRequest\", \"XMLHttpRequestEventTarget\",\n          \"XMLHttpRequestUpload\", \"XMLSerializer\", \"XPathEvaluator\",\n          \"XPathExpression\", \"XPathResult\", \"XSLTProcessor\"\n        ]),\n      },\n      methods: {\n        get classes() { return addExpansion(fetcher('function', /^[A-Z]/)) },\n        get functions() {  },\n        get objects() {  },\n      }\n    },\n\n    safari: {\n\n    }\n  }\n}\n\nexport const TypeExtensions = new Extension(Type)", "import { Extension } from '@nejs/extension'\n\n/**\n * The AsyncIterable class extends the concept of Iterable to asynchronous\n * operations. It allows creating iterable objects where each element can be\n * an asynchronous entity, like a Promise. This class is particularly useful\n * when dealing with asynchronous data sources, such as API responses, file\n * reading in chunks, or any other data that is not immediately available but\n * arrives over time.\n */\nexport class AsyncIterable {\n  /**\n   * Private field to store the elements of the async iterable.\n   * @private\n   */\n  #elements = [];\n\n  /**\n   * Constructs an instance of AsyncIterable. Similar to Iterable, it can be\n   * initialized with either an iterable object, an async generator function,\n   * or individual elements. The elements can be promises, direct values, or a\n   * mix of both. If the first argument is an iterable or an async generator\n   * function, the instance is initialized with the elements from the iterable\n   * or the generated elements from the async generator function, followed by\n   * any additional arguments. If the first argument is not an iterable or an\n   * async generator function, all arguments are treated as individual elements.\n   *\n   * @param {Iterable|AsyncGeneratorFunction|Promise|*} elementsOrFirstElement - \n   * An iterable object, an async generator function, a Promise, or the first \n   * element.\n   * @param {...Promise|*} moreElements - Additional elements if the first\n   * argument is not an iterable or an async generator function.\n   */\n  constructor(elementsOrFirstElement, ...moreElements) {\n    if (\n      elementsOrFirstElement != null &&\n      (typeof elementsOrFirstElement[Symbol.iterator] === 'function' ||\n       typeof elementsOrFirstElement[Symbol.asyncIterator] === 'function')\n    ) {\n      this.#elements = [...elementsOrFirstElement, ...moreElements];\n    } else if (\n      typeof elementsOrFirstElement === 'function' &&\n      elementsOrFirstElement.constructor.name === 'AsyncGeneratorFunction'\n    ) {\n      this.#elements = elementsOrFirstElement();\n    } else {\n      this.#elements = [elementsOrFirstElement, ...moreElements];\n    }\n  }\n\n  /**\n   * Implements the async iterable protocol. When an instance of AsyncIterable\n   * is used in a `for await...of` loop, this async generator function is\n   * invoked. It yields each element as a Promise, allowing asynchronous\n   * iteration. Elements that are not Promises are automatically wrapped in\n   * a resolved Promise to ensure consistency.\n   *\n   * @returns {AsyncGenerator} An async generator that yields each element as\n   * a Promise.\n   */\n  async *[Symbol.asyncIterator]() {\n    for await (const element of this.#elements) {\n      // No need to wrap as a promise here since `for await...of` can handle\n      // both Promises and non-Promise values.\n      yield element;\n    }\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Checks if a given value is an async iterable. This method determines if\n   * the provided value has a `Symbol.asyncIterator` property that is an async\n   * generator function. It's a precise way to identify if the value conforms\n   * to the async iterable protocol using an async generator function.\n   *\n   * Note: This method specifically checks for async generator functions. Some\n   * async iterables might use regular async functions that return an async\n   * iterator, which this method won't identify.\n   *\n   * @param {*} value - The value to be checked for async iterability.\n   * @returns {boolean} - Returns true if the value is an async iterable\n   * implemented using an async generator function, false otherwise.\n   */\n  static isAsyncIterable(value) {\n    const type = Object.prototype.toString.call(value?.[Symbol.asyncIterator]);\n    return type === '[object AsyncGeneratorFunction]';\n  }\n}\n\n/**\n * Being able to create a compliant `AsyncIterator` around any type of\n * iterable object. This can be wrapped around any type of object that\n * has a `[Symbol.asyncIterator]` property assigned to a generator\n * function.\n */\nexport class AsyncIterator {\n  /**\n   * Creates a new `AsyncIterator` object instance.\n   *\n   * @param {object|AsyncGeneratorFunction} asyncIterable any object that has a\n   * `[Symbol.asyncIterable]` property assigned to a generator function or an\n   * async generator function itself.\n   */\n  constructor(asyncIterable) {\n    if (typeof asyncIterable === 'function' &&\n        asyncIterable.constructor.name === 'AsyncGeneratorFunction') {\n      this.#asyncIterable = asyncIterable();\n    } else if (\n      !asyncIterable || \n      !Reflect.has(asyncIterable, Symbol.asyncIterator)\n    ) {\n      throw new TypeError(\n        'Value used to instantiate AsyncIterator is not an async iterable'\n      );\n    } else {\n      this.#asyncIterable = asyncIterable;\n    }\n    this.#asyncIterator = this.#asyncIterable[Symbol.asyncIterator]();\n  }\n\n  /**\n   * Returns a new `Array` derived from the iterable this object\n   * wraps.\n   *\n   * @returns {array} a new `Array` generated from the wrapped\n   * iterable. The method is generated from using an async for of\n   * loop.\n   */\n  async asArray() {\n    const array = []\n\n    for await (const value of this) {\n      array.push(value)\n    }\n\n    return array\n  }\n\n  /**\n   * Returns the actual iterable object passed to the constructor that\n   * created this instance.\n   *\n   * @returns {object} the object containing the `[Symbol.iterator]`\n   */\n  get asyncIterable() {\n    return this.#asyncIterable\n  }\n\n  /**\n   * The function retrieves the next value in the iterator. If the\n   * the iterator has run its course, `reset()` can be invoked to\n   * reset the pointer to the beginning of the iteration.\n   *\n   * @returns {any} the next value\n   */\n  async next() {\n    const result = await this.#asyncIterator.next();\n    if (result.done) {\n      return { value: undefined, done: true };\n    } else {\n      return { value: result.value, done: false };\n    }\n  }\n\n  /**\n   * Resets the async iterator to the beginning allowing it to be\n   * iterated over again.\n   */\n  async reset() {\n    this.#asyncIterator = this.#asyncIterable[Symbol.asyncIterator]();\n  }\n\n  /**\n   * The existence of this symbol on the object instances, indicates that\n   * it can be used in `for(.. of ..)` loops and its values can be\n   * extracted from calls to `Array.from()`\n   *\n   * @returns {AsyncIterable} this is returned since this object is already\n   * conforming to the expected JavaScript AsyncIterator interface\n   */\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n\n  /**\n   * The object from which its iterator functionality is derived.\n   *\n   * @type {object}\n   * @private\n   */\n  #asyncIterable = null;\n\n  /**\n   * The results of a call to the iterable's `[Symbol.asyncIterator]`\n   * generator function.\n   *\n   * @type {object}\n   * @private\n   */\n  #asyncIterator = null;\n}\n\nexport const AsyncIterableExtensions = new Extension(AsyncIterable)\nexport const AsyncIteratorExtensions = new Extension(AsyncIterator)"],
  "mappings": "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",
  "names": ["src_exports", "__export", "Classes", "Controls", "Extensions", "GlobalFunctionsAndProps", "InstancePatches", "Patches", "StaticPatches", "all", "src_default", "typeOf", "o", "CannotBeExtendedError", "owner", "key", "typeOf", "o", "MissingOwnerValue", "owner", "key", "PatchToggle", "patch", "preventRevert", "task", "toggle", "result", "depth", "options", "inspect", "objName", "status", "PatchEntry", "property", "owningObject", "condition", "descriptorOverrides", "isNullish", "value", "isKey", "types", "f", "isObject", "descriptor", "anotherObject", "bindAccessors", "depth", "options", "inspect", "name", "type", "writable", "Patch", "_Patch", "owner", "patches", "options", "patchesOwner", "overrides", "globalCondition", "key", "condition", "useOverrides", "useOwner", "PatchEntry", "error", "acc", "patchEntry", "_", "prettyEntries", "value", "pe", "metrics", "entries", "counts", "patch", "oDesc", "#equalDescriptors", "preventRevert", "PatchToggle", "conflicts", "appliedDescriptor", "e", "left", "right", "depth", "inspect", "type", "name", "keys", "entry", "#allPatchesForOwner", "allForOwner", "appliedOnly", "wrapInToggle", "applyOnRequest", "onlyApplied", "accumulator", "usage", "toggle", "dynName", "dynNameContainer", "applyTo", "fromString", "instance", "store", "symbol", "maybeSymbol", "useStore", "ignored", "string", "__", "prototype", "ownPropNames", "o", "innerKey", "object", "defaultName", "oneOf", "a", "valueOf", "valueOfAsString", "k", "v", "parts", "line", "primitives", "Extension", "_Extension", "Patch", "keyClassOrFn", "value", "owner", "options", "metadata", "key", "extension", "valid", "MissingOwnerValue", "descriptor", "CannotBeExtendedError", "input", "depth", "inspect", "exprs", "name", "extensions", "extensionValue", "ArrayExtensions", "Patch", "value", "thenValue", "elseValue", "isThenElse", "pIfArray", "ArrayPrototypeExtensions", "entry", "findFn", "entries", "VALUE", "doubleEqualsOkay", "element", "values", "truthy", "falsy", "keys", "o", "object", "acc", "key", "result", "position", "bv", "tv", "ev", "_then", "_else", "BigIntExtensions", "Patch", "value", "thenValue", "elseValue", "isThenElse", "pIsBigInt", "pIfBigInt", "BigIntPrototypeExtensions", "bv", "tv", "ev", "_then", "_else", "FunctionExtensions", "Patch", "fn", "descriptors", "acc", "key", "prototypeDescriptors", "value", "stringTag", "thenValue", "elseValue", "isThenElse", "getStringTag", "Class", "protoChain", "getPrototypeChainEntries", "pIsAsyncGenerator", "pIfAsyncGenerator", "pIsAsync", "pIfAsync", "pIsBigArrow", "pIfBigArrow", "pIsBound", "pIfBound", "pIsClass", "pIfClass", "pIsFunction", "pIfFunction", "pIsGenerator", "pIfGenerator", "FunctionPrototypeExtensions", "bv", "tv", "ev", "_then", "_else", "getStringTag", "value", "strict", "getPrototypeChainEntries", "object", "entries", "prototype", "descriptors", "acc", "key", "isClass", "isFunction", "FunctionExtensions", "CustomInspect", "GlobalFunctionsAndProps", "Patch", "boolValue", "thenValue", "elseValue", "_then", "_else", "object", "classPrototype", "options", "prototype", "toPrimitive", "base", "proto", "klass", "hint", "depth", "opts", "inspect", "stringKey", "numberKey", "targetKey", "property", "isNum", "root", "objects", "descriptor", "o", "k", "parent", "all", "a", "newRoot", "protos", "descriptors", "uniques", "current", "blendedPrototype", "JSONExtensions", "Patch", "string", "pattern", "decoder", "part", "decoded", "detail", "results", "MapExtensions", "Patch", "value", "thenValue", "elseValue", "isThenElse", "pIsMap", "pIfMap", "MapPrototypeExtensions", "strict", "key", "entryValue", "bv", "tv", "ev", "_then", "_else", "NumberExtensions", "Patch", "value", "which", "values", "num", "thenValue", "elseValue", "isThenElse", "numbers", "minValue", "maxValue", "pIsNumber", "pIfNumber", "NumberPrototypeExtensions", "bv", "tv", "ev", "_then", "_else", "Symkeys", "_Symkeys", "named", "associatedData", "token", "symName", "symbol", "forSymbol", "replaceWith", "result", "value", "providedName", "useDomain", "useSeparator", "domain", "separator", "postfix", "prototype", "map", "_", "target", "property", "receiver", "__", "object", "a", "e", "SymkeysExtension", "Extension", "JSONToggle", "PatchToggle", "JSONExtensions", "SymbolExtensions", "Patch", "named", "associatedData", "forSymbol", "replaceWith", "value", "allowOnlySymbols", "Symkeys", "name", "data", "SymbolPrototypeExtensions", "possibleData", "result", "revertToggle", "revert", "detail", "sgr", "string", "args", "jsonText", "index", "desc", "newDescription", "depth", "options", "inspect", "Descriptor", "_Descriptor", "#desc", "#object", "object", "key", "isObject", "isValidKey", "value", "depth", "options", "inspect", "wrap", "forKey", "bindAccessors", "descriptor", "hint", "hasGetter", "hasSetter", "property", "enumerable", "configurable", "getter", "setter", "writable", "knownKeys", "hasSome", "object_orProp", "DATA_KEYS", "validData", "ACCESSOR_KEYS", "validAccessor", "DescriptorExtensions", "Extension", "o", "t", "keys", "has", "Property", "_Property", "key", "descriptor", "toObject", "asKey", "k", "baseline", "result", "self", "is", "get", "set", "value", "writable", "colors", "bold", "s", "dim", "red", "green", "blue", "buffer", "keyPresent", "object", "eqeq", "compare", "a", "b", "element", "depth", "options", "inspect", "name", "prototype", "configurable", "enumerable", "storage", "constructor", "present", "props", "basic_accessor", "PropertyExtensions", "Extension", "initialValue", "symkeys", "SymbolExtensions", "isFn", "o", "isBool", "o", "isTrue", "isTruthy", "ObjectExtensions", "Patch", "destination", "sources", "copyObject", "object", "key", "value", "flag", "properties", "get", "set", "to", "getter", "setter", "storage", "store", "args", "isDescriptor", "Descriptor", "isObj", "kDescriptorStore", "obj", "_get", "_set", "storageKey", "_type", "_flag", "_desc", "more", "props", "storeKey", "makeStore", "isTruthy", "isFn", "isTrue", "symkeys", "innerGet", "innerSet", "entries", "prototype", "reducer", "entriesToUse", "entry", "useReducer", "accumulator", "descriptors", "acc", "strict", "owner", "stringTag", "thenValue", "elseValue", "isThenElse", "keys", "defaultValue", "definedAs", "accessorMeta", "descriptorBase", "extraDescriptors", "mapped", "a", "k", "symKey", "suppliedValue", "descriptorRest", "v", "bindAccessors", "result", "descriptor", "p", "Property", "possible", "descriptorOrDataOrAccessorArgs", "rest", "sorted", "b", "property", "pIsObject", "pIfObject", "pIsNullDefined", "pIfNullDefined", "pIsPrimitive", "pIfPrimitive", "pIsValidKey", "pIfValidKey", "pHasStringTag", "pGetStringTag", "pStripTo", "ObjectPrototypeExtensions", "bv", "tv", "ev", "_then", "_else", "deep", "visited", "source", "err", "isDataDesc", "keyedValue", "condition", "replacement", "ReflectExtensions", "Patch", "object", "keys", "key", "has", "isObject", "owner", "variants", "applyVariants", "descriptor", "isValidKey", "value", "result", "type", "thisArg", "entries", "acc", "position", "RegExpExtensions", "Patch", "greedy", "includeNewlines", "string", "strings", "RegExpEscape", "symbols", "locale", "known", "has", "code", "symbol", "opts", "currency", "fmt", "place", "instance", "self", "SetExtensions", "Patch", "value", "thenValue", "elseValue", "isThenElse", "pIsSet", "SetPrototypeExtensions", "iterables", "iterable", "element", "everyFn", "thisArg", "found", "findFn", "mapFn", "transformed", "reduceFn", "initialValue", "accumulator", "someFn", "bv", "tv", "ev", "_then", "_else", "parenthesisPair", "StringExtensions", "Patch", "value", "thenValue", "elseValue", "isThenElse", "prefix", "hex", "red", "green", "blue", "force", "alpha", "message", "useModes", "colors", "a", "color", "c", "arrayifyString", "s", "results", "i", "modes", "sgrModes", "mode", "codes", "open", "close", "_isColor", "colorIndex", "onOrder", "key", "offOrder", "result", "depth", "options", "inspect", "objectOrLines", "colorProperties", "indent", "indentCharacter", "inspector", "lineEnding", "maxLen", "perLine", "perLinePerProperty", "preProcess", "preReturn", "separator", "tab", "sgr", "validMapper", "f", "line", "getElements", "values", "context", "finalLines", "acc", "nextProp", "ifCombined", "lineProps", "index", "array", "sgrArgs", "v", "pIsString", "pIfString", "StringPrototypeExtensions", "offset", "tokens", "openToken", "closeToken", "start", "end", "leadingToken", "firstToken", "char", "lRange", "leading", "reversedLeadingToken", "sliceRange", "bv", "tv", "ev", "_then", "_else", "Deferred", "_Deferred", "#promise", "#reject", "#resolve", "#rejected", "#resolved", "#settled", "options", "config", "_resolve", "_reject", "resolve", "reject", "value", "reason", "depth", "inspect", "executor", "DeferredExtension", "Extension", "Introspector", "array", "toEntriesFrom", "owner", "accumulator", "key", "count", "value", "error", "keys", "entries", "metadata", "v", "t", "d", "typeNameOrTyperFn", "regExp", "searchClass", "searchFunction", "typer", "type", "typeName", "descriptor", "names", "bound", "a", "n", "classes", "functions", "objects", "properties", "symbols", "accessors", "result", "reportName", "IntrospectorExtensions", "Extension", "Iterable", "#elements", "elementsOrFirstElement", "moreElements", "element", "value", "Iterator", "_Iterator", "#mapEach", "iterable", "mapEach", "#iterable", "#iterator", "input", "output", "object", "keyFetcher", "keys", "entries", "key", "IterableExtensions", "Extension", "IteratorExtensions", "ParamParser", "_ParamParser", "parameters", "validator", "parser", "args", "parsers", "throwOnFail", "success", "result", "Parser", "ParamParserExtensions", "Extension", "toStringTag", "hasInstance", "ProxyHandlerResponse", "success", "value", "context", "instance", "ProxyHandler", "_ProxyHandler", "handler", "type", "args", "result", "error", "proxyHandlerType", "names", "name", "element", "PluggableProxy", "_PluggableProxy", "Class", "handlers", "options", "validHandlers", "h", "typeName", "handlersOfType", "target", "types", "failures", "thisArg", "argumentsList", "_fails", "_args", "key", "descriptor", "property", "receiver", "prototype", "ProxyHandlerExtensions", "Extension", "PluggableProxyExtensions", "PluggableProxyExtensionSet", "WeakRefExtensions", "Patch", "value", "isObject", "isNullDefined", "isValidKey", "ObjectExtensions", "isRegistered", "SymbolExtensions", "isValidReference", "WeakRefExtensions", "RefMap", "_RefMap", "#objectifyValues", "args", "setObjectification", "object", "key", "value", "useKey", "useValue", "defaultValue", "ref", "entries", "Iterable", "forEach", "entry", "dereferenced", "entriesIterator", "Iterator", "forEachFn", "thisArg", "strict", "_", "filterFn", "resultingEntries", "findFn", "result", "mapFn", "toRefMap", "mirrorObjectification", "errors", "needsObjectification", "detectNeed", "objectify", "VALUE", "transformed", "RefMapExtensions", "Extension", "RefSet", "_RefSet", "#objectifyValues", "setObjectification", "value", "values", "ref", "_", "forEachFn", "thisArg", "set", "dereferenced", "item", "dereferencedValue", "filterFn", "results", "findFn", "mapFn", "toRefSet", "mirrorObjectification", "mapped", "validRefSetOutput", "validRefSetOutputIfObjectified", "mappedItem", "#validWeakRefTarget", "RefSetExtensions", "Extension", "Type", "_Type", "value", "ofType", "tag", "mapped", "name", "type", "Introspector", "TypeExtensions", "Extension", "AsyncIterable", "#elements", "elementsOrFirstElement", "moreElements", "element", "value", "AsyncIterator", "asyncIterable", "#asyncIterable", "#asyncIterator", "array", "result", "AsyncIterableExtensions", "Extension", "AsyncIteratorExtensions", "StaticPatches", "ArrayExtensions", "BigIntExtensions", "FunctionExtensions", "JSONExtensions", "MapExtensions", "NumberExtensions", "ObjectExtensions", "ReflectExtensions", "RegExpExtensions", "SetExtensions", "StringExtensions", "SymbolExtensions", "InstancePatches", "ArrayPrototypeExtensions", "BigIntPrototypeExtensions", "FunctionPrototypeExtensions", "MapPrototypeExtensions", "NumberPrototypeExtensions", "ObjectPrototypeExtensions", "SetPrototypeExtensions", "StringPrototypeExtensions", "SymbolPrototypeExtensions", "Patches", "Extensions", "AsyncIterableExtensions", "AsyncIteratorExtensions", "DeferredExtension", "DescriptorExtensions", "IntrospectorExtensions", "IterableExtensions", "IteratorExtensions", "ParamParserExtensions", "PluggableProxyExtensions", "ProxyHandlerExtensions", "PropertyExtensions", "RefMapExtensions", "RefSetExtensions", "SymkeysExtension", "TypeExtensions", "Classes", "extension", "fnOrClass", "Controls", "filter", "owner", "patches", "toFilterFn", "_", "GlobalFunctionsAndProps", "all", "dest", "entriesReducer", "accumulator", "key", "entry", "Descriptor", "staticPatchReducer", "patch", "ownerName", "instancePatchReducer", "descriptor", "results", "src_default", "toFilterFn", "filter", "owner", "extension", "filterFn", "elements", "_", "element", "elementStr"]
}
